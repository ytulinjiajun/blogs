* blogs-linux-active
** DONE [#D] Theme:curl命令									   :@Blog:@Linux:
    SCHEDULED:<2017-09-11 一>
	- State "DONE"       from "WAITTING"   [2017-09-11 一 15:30]
--curl命令是一个利用URL规则在命令行下工作的文件传输工具

--支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具

--作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、
从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征
做网页处理流程和数据检索自动化，curl可以祝一臂之力。


安装：
Ubuntu下，只需一条命令即可安装curl：
--sudo apt-get install curl libcurl3 libcurl3-dev php5-curl


Blog creation time:[2017-09-11 一 15:24]
** WAITTING [#D] Theme:kali bugs							   :@Blog:@Linux:
    SCHEDULED:<2017-09-13 三>
--C-L键按下之后，无法跳转到terminal的底部，使用鼠标滑轮手动滚动到 底部时，再次使用
C-L想将光标当前位置置顶时，terminal卡死，需要杀死进程才行

--在普通用户下，使用sudo emacs /etc/xxx进行编辑时，无法使用中文输入法，而直接
切换到root后使用emacs /etc/xxx进行编辑时，就可以使用中文输入法

Blog creation time:[2017-09-13 三 10:16]
** WAITTING [#D] Theme:netstat								   :@Blog:@Linux:
    SCHEDULED:<2017-09-14 四>
--功能：用于打印linux系统网络的状态信息,列出系统上所有的网络套接字连接情况，包括 
tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字

--参数：
(1) -a:显示侦听和未侦听的套接字，即列出当前所有的连接
输出：
>> Proto:被套接字使用的协议，有tcp, udp, udpl, raw四种
>> Recv-Q:没有被连接到这个套接字的用户程序复制的字节数
>> Send-Q:没有被远程主机认可的字节数

备注：该命令列出 tcp, udp 和 unix 协议下所有套接字的所有连接，然而这些信息还不够详细，管理员往往需要查看某个协议或端口的具体连接情况


Blog creation time:[2017-09-14 四 15:20]
** DONE [#D] Theme:安装Debian								   :@Blog:@Linux:
    SCHEDULED:<2017-09-14 四>
	- State "DONE"       from "WAITTING"   [2017-09-15 五 10:24]
(1)安装：
--Debian官网:https://www.debian.org/
--CD/USB ISO映像(在第三行第二列，比较小，仔细找)
--选择：通过 BitTorrent 下载 CD/DVD 映像文件
--选择：Official jigdo files for the stable release --->DVD amd64或者i386
--选择：debian-9.1.0-amd64-DVD-1.iso.torrent   
备注：还有debian-9.1.0-amd64-DVD-2.iso.torrent 和 debian-9.1.0-amd64-DVD-3.iso.torrent  
这两个是软件包，可以自己下载
--制作U盘启动盘，工具：rufus-2.16.exe(网址：http://rufus.akeo.ie/)
--使用U盘安装

(2)配置：
--优化工具：下载扩展插件：workspace to dock
Blog creation time:[2017-09-14 四 21:27]
** DONE [#D] Theme:解决软件安装过程中的依赖关系的心得		   :@Blog:@Linux:
    SCHEDULED:<2017-09-15 五>
	- State "DONE"       from "WAITTING"   [2017-09-16 六 20:39]
(1)正常途径：
>> dpkg -i xxx.deb
>> apt -f install 
>> dpkg -i xxx.deb
	上面的三条指令几乎就是所有.deb类型的包安装的泛型，其原理如下：
	一般情况下，拿到一个.deb的包之后，可以使用dpkg -i xxx.deb来安装，此时，有百分之90
以上的情况都会提示说缺少依赖，但是呢，该软件xxx的状态信息已经存放在/var/lib/dpkg/status
文件里面了，那紧接着使用apt -f install来强制安装，其原理是下面的包管理机制所述，apt去
遍历分析整个/var/lib/dpkg/status的过程中自然会发现 xxx 这个软件的依赖中有软件包没有安装，
自然会去安装这些检测到的包了
	如此依赖，卸载命令sudo apt autoremove xxx --purge的原理也就很明了了，显然，系统会去
将/var/lib/dpkg/status中软件xxx登记的信息给抹除掉，之后安装其他软件时才不会报错！

(2)存放软件状态信息的文件：/var/lib/dpkg/status
>> 当使用dpkg -s xxx时，该命令会从该文件中找到xxx这个软件，然后原封不动的将里面的信息
输出到屏幕，使用该命令，不难发现会显示该软件xxx的所有依赖关系
>> 这个文件很重要，因为每次使用apt安装软件时，apt会事先去遍历这个文件，分析文件中各个
软件的依赖信息，这样做的原因不难猜测，你想啊，如果你现在安装的软件包当中依赖到了一个包，
暂且记为pack.xx,而这个pack.xx在你过去某个时刻，安装某一个软件时作为依赖安装过一次，
那么，现在你正在安装的这个软件用到这个包pack.xx的时候，你是再安装一遍呢，还是不要安装，
答案是显然的，肯定是不用安装的，那么，apt又如何知道pack.xx以前安装过呢？

(3)包管理机制：
包管理器提供一种机制：每个软件在安装之后，都会在/var/lib/dpkg/status这个文件下登记状态，
这里面记录了每个软件包的名称，大小，版本，依赖关系，描述信息等等，在安装一个软件之前，
首先去遍历这个文件下所有软件的依赖关系这一部分，确定以前从没有安装过该软件以及其所依赖的包
之后，才会去安装，否则就略过

(3)缺什么补什么：
	理想很丰满，现实很残酷，实际在安装过程中（1）所述的方法80%都会成功，有15%从原理上说
压根就不可能（比如兼容性问题），有5%还是值得争取一下的，其失败的原因通常是因为源仓库
里面无法满足待安装软件内部依赖包的版本，或者是源仓库里面没有某些依赖包等，针对后者，通常，
可以想办法从外部获取缺少的依赖包进行安装即可。对于前者，得动一番手脚，下面以安装网易云音乐
为例进行阐述：
>> dpkg -i netease-cloud-music_1.0.0-2_amd64_Ubuntu16.04.deb
备注：
缺少几个依赖包，其中，有一个叫做libfontconfig1 (>=2.11.94)的比较特殊，该条目明确
说明netease-cloud-music这个软件依赖于libfontconfig1 (>=2.11.94)，但是系统的源仓库中
只有libfontconfig1 2.11.0-6.7+b1，原因已经告诉用户了，针对依赖包libfontconfig1，安装
过程中需要其版本(>=2.11.94)，知道了原因，就好解决问题了

>> 安装缺少的依赖：
sudo aptitude install xxx yyy zzz ...  libfontconfig1
备注：
--在此处一定要使用aptitude,测试发现apt-get好像无法处理，至于原因嘛，查资料得知，aptitude 
解决依赖关系比 apt-get 更智能，它有一个优点就是会自动记录哪些包是"自动安装"
(即因依赖关系而安装)的, 总之，试一下就知道了
--一个依赖可能会引出其他依赖，新出现的依赖也将其添加进来，知道不再有新的依赖时，就算完事了
--这一步骤最后还是会显示上面说的那个比较特殊的libfontconfig1，版本太新，找不到，没关系，
那安装时忽略版本就是了

>> 解决 libfontconfig1 的版本问题
sudo dpkg --ignore-depends=libfontconfig1 -i netease-cloud-music_1.0.0-2_amd64_Ubuntu16.04.deb

>> 安装完成了吗？
到目前为止，网易音乐安装并可以正常使用了，在终端下输入netease-cloud-music,就能启动网易音乐
的界面并播放音乐，然而，事情真的结束了吗？你在使用apt install xxx安装另一个软件试试，会报告
一个关于libfontconfig1的错，还是说版本不对，聪明的你大概已经想到了，我们前面说，apt以及
aptitude在使用时，首先会去遍历/var/lib/dpkg/status这个文件中的依赖信息，OK，我们来理一下
关于libfontconfig1的思路：
第一个“>>”条目中，使用了dpkg安装网易音乐，结果，在/var/lib/dpkg/status中登记了该软件的
信息，而信息中有个依赖信息中出现了libfontconfig1 (>=2.11.94)；
第二个“>>”条目中，使用了aptitude安装缺少的依赖，其中，安装了libfontconfig1，不用说，安装的
肯定是源仓库中唯一有的2.11.0-6.7+b1版本
第三个“>>”条目中，使用 dpkg --ignore-depends=libfontconfig1 -i xxx在忽略libfontconfig1
依赖问题的前提安装了网易音乐，之后就可以使用该软件了
然而，矛盾在于：系统中实际安装了2.11.0-6.7+b1版本的libfontconfig1，而/var/lib/dpkg/status
中登记的还是libfontconfig1 (>=2.11.94)，再次使用apt时，遍历/var/lib/dpkg/status的时候，
apt是会发现这个问题的，所以就输出一条错误信息：
netease-cloud-music：Depends:libfontconfig1 (>=2.11.94) but 2.11.0-6.7+b1 is 
installed

>> 修改依赖文件
知道了问题的根源就在于/var/lib/dpkg/status中登记的还是libfontconfig1 (>=2.11.94)，
那么，将 (>=2.11.94) 从该文件中去掉，问题就解决了，完毕！

Blog creation time:[2017-09-15 五 16:37]
** DONE [#D] Theme:解决Debian使用apt安装软件时要求插入光盘的问题 :@Blog:@Linux:
    SCHEDULED:<2017-09-15 五>
	- State "DONE"       from "WAITTING"   [2017-09-15 五 10:24]
--原因：Debian安装后，/etc/apt/sources.list中开头几行默认优先从dvd光盘安装软件,而非从网上下载

--解决方案：
Debian系统自带一个叫做Software update的软件，专门用来管理源，打开该软件配置一下即可
Blog creation time:[2017-09-15 五 09:10]
** DONE [#D] Theme:diff详解(生成补丁文件)					   :@Blog:@Linux:
   SCHEDULED:<2017-10-01 日>
   - State "DONE"       from "WAITTING"   [2017-10-01 日 18:14]
1. 基础框架
   1. 范式：diff OPTIONS... TAG1  TAG2
   2. 情况一，TAG1与TAG2均是文件
	  1. 这种情况是最为简单的，diff命令比较的是这两个文件的内容
	  2. 特殊标识‘-’代表标准输入，diff -u - b.txt <a.txt >c.txt 等价于 diff -u a.txt b.txt >c.txt
	  3. 这种情况按照下面的三种方式：正常模式，上下文模式，合并模式进行操作
   3. 情况二，TAG1与TAG2之间有其一是文件，比如TAG1是文件，其一是目录，比如TAG2是目录
	  1. 命令： diff -u a.txt dir/
	  2. 该命令会且仅会将a.txt同dir/a.txt相比较
	  3. diff -u - dir/ <a.txt在该情况下是不合法的，即，不支持标准输入
   4. 情况三，TAG1与TAG2均是目录
      1. 比较的基本原则是：同一目录深度处， 有名字相同的文件，进行比较，有名字相同的目录，则进入该目录，同时双方的目录深度各自加一，然后进行文件遍历
	  2. 目录的比较一般都需要加上-rcanshu
2. 研究对象
   1. 原始文件： a.txt
	  应该杜绝文章中的错别子。
	  
	  但是无论使用
	  *全拼，双拼
	  *还是五笔
	  
	  是人就有可能犯错,软件更是如此。
	  
	  犯了错，就要扣工资！
	  
	  改正的成本可能会很高。
   2. 目标文件: b.txt
      应该杜绝文章中的错别字。
	  
	  但是无论使用
	  *全拼，双拼
	  *还是五笔
	  
	  是人就有可能犯错,软件更是如此。
	  
	  改正的成本可能会很高。
	  
	  但是“只要眼球足够多，所有的bug都好捉“，
	  这就是开源的哲学之一
   3. 备注： 在 diff [选项] [FILE1] [FILE2] 中，定义FILE1为原始文件，FILE2为目标文件
3. 正常模式(normal diff)
   1. 命令：diff a.txt b.txt >c.txt
   2. 差异输出：
	  1c1
	  < 应该杜绝文章中的错别子。
	  ---
	  > 应该杜绝文章中的错别字。
	  9,10d8
	  < 犯了错，就要扣工资！
	  < 
	  11a10,12
	  > 
	  > 但是“只要眼球足够多，所有的bug都好捉“，
	  > 这就是开源的哲学之一
   3. 要点
	  1. 正常模式的基本原则：需要对原始文件做出怎样的操作之后，才能用与目标文件匹配
	  2. 正常模式是diff命令的默认模式
	  3. 默认模式的输出结果比较符合计算机的思维方式，但是，不太直观，所以，提供了contex-mode和unified-mode，使得人们能更好的理解
	  4. git diff使用的是unified-mode,即，合并模式
   4. 语法分析：(正常模式语法分析的重要原则是：需要对原始文件做出怎样的操作“a d c”之后，才能用与目标文件匹配)
	  1. [数字1，数字2] + 字母 + [数字3,数字4]格式分析： 如上结果中的 9,10d8
		 1. 字母: a=add ; c=change ; d=delete
		 2. [数字1，数字2]：  9,10 表示原始文件中的第[9,10]行，注意是闭区间，包含第9行和第10行
		 3. [数字3，数字4]：  8 表示目标文件中的第8行
		 4. 9,10d8的含义：对原始文件的第9行到第10行，做出删除的操作后，可以同目标文件的第8行匹配
	  2. 以<开始的行： 标识这是属于原始文件专有的行
	  3. 以>开始的行： 标识这是属于目标文件专有的行
	  4. ---： 原始文件和目标文件的分隔符
4. 上下文模式(context diff)
   1. 命令： diff -c a.txt b.txt >c.txt
   2. 差异输出：
	  *** a.txt	2017-09-30 16:11:33.961502252 +0800
      --- b.txt	2017-09-30 16:12:27.869501287 +0800
      ***************
      *** 1,4 ****
      ! 应该杜绝文章中的错别子。
	  
      但是无论使用
      *全拼，双拼
      --- 1,4 ----
      ! 应该杜绝文章中的错别字。
	  
      但是无论使用
	  *全拼，双拼
	  ***************
	  *** 6,11 ****
	  
      是人就有可能犯错,软件更是如此。
	  
      - 犯了错，就要扣工资！
      - 
      改正的成本可能会很高。
      --- 6,12 ----
	  
      是人就有可能犯错,软件更是如此。
	  
      改正的成本可能会很高。
      + 
      + 但是“只要眼球足够多，所有的bug都好捉“，
      + 这就是开源的哲学之一
   3. 要点
	  1. 在输出的差异文件中，无论+ - !出现在原始文件块还是目标文件块中，其含义均是表示需要对原始文件做出操作才能与目标文件相匹配
	  2. 命令中的 -c 正是标识上下文模式的关键选项 
   4. 语法分析(上下文模式语法分析的重要原则是：需要对原始文件做出怎样的操作“+ - ！”之后，才能与目标文件匹配)
	  1. 原始文件标识： 第一行以3个***开头，标识的是原始文件，该行记录了原始文件的文件名和时间戳
	  2. 目标文件标识： 第二行以3个---开头，标识的是目标文件，该行记录了目标文件的文件名和时间戳
	  3. 分隔符： 第三行15个***************是分隔符
	  4. 原始文件，差异定位语句： *** 1,4 ****
		 1. ***： 原始文件，差异定位语句开始标志
		 2. 1,4： 本差异小节的内容，位于原始文件的第[1,4]行
		 3. ****： 差异定位语句结束标志
	  5. 目标文件，差异定位语句： --- 1,4 ----
		 1. ---： 目标文件，差异定位语句开始标志
		 2. 1,4： 本差异小节的内容，位于目标文件的第[1,4]行
		 3. ----： 差异定位语句结束标志
	  6. 两个差异定位语句之间的内容称为一个差异小节
      7. 差异小节操作符：
	     1. + 表示，原始文件需要增加这一行，才能同目标文件匹配
	     2. - 表示，原始文件需要删除这一行，才能同目标文件匹配
	     3. ! 表示，原始文件需要经过修改，才能同目标文件匹配
5. 合并模式(unified diff)
   1. 命令： diff -u a.txt b.txt >c.txt
   2. 差异输出：
	  --- a.txt	2017-09-29 14:55:40.091131063 +0800
 	  +++ b.txt	2017-09-29 15:00:00.075126407 +0800
 	  @@ -1,4 +1,4 @@
 	  -应该杜绝文章中的错别子。
 	  +应该杜绝文章中的错别字。
	  
 	  但是无论使用
 	  *全拼，双拼
 	  @@ -6,6 +6,7 @@
	  
 	  是人就有可能犯错,软件更是如此。
	  
 	  -犯了错，就要扣工资！
	  - 
   	  改正的成本可能会很高。
	  + 
   	  +但是“只要眼球足够多，所有的bug都好捉“，
   	  +这就是开源的哲学之一
   3. 要点
	  1. 合并模式是比较重要的模式，因为git集成的diff使用的就是该模式，因此务必掌握
      2. 命令中的 -u 正是标识合并模式的关键选项
   4. 语法分析
	  1. 原始文件标识： 第一行以3个---开头，标识的是原始文件，该行记录了原始文件的文件名和时间戳 
      2. 目标文件标识： 第二行以3个+++开始，标识的是目标文件，该行记录了目标文件的文件名和时间戳
      3. 原始文件专有行：以-号开始的行，表示只出现在原始文件中的行，从打补丁命令patch的角度看，表示该行需要删除
      4. 目标文件专有行：以+号开始的行，表示只出现在目标文件中的行，从打补丁命令patch的角度看，表示该行需要增加
      5. 公共行：以空格开始的行，表示在原始问价和目标文件中都出现的行
      6. 差异定位语句： @@ -6,6 +6,7 @@
	     1. @@： 差异定位语句开始标志
	     2. -6，6： 本差异小节的内容，位于原始文件中的位置是：从第6行开始,之后的6行
	     3. +6,7： 本差异小节的内容，位于目标文件中的位置是：从第6行开始，之后的7行
	     4. @@： 差异定位语句的结束标志
      7. 差异小节：两个差异定位语句之间的内容构成一个差异小节
6. 文件同目录之间的比较
   1. 命令： diff a.txt dir/
   2. a.txt会且仅会同dir/a.txt进行比较，即，即使dir/sub-dir/a.txt存在，且使用-r,比较也无法进行
7. 目录同目录之间的比较(最重要，项目管理常用！！！)
   1. 目录与目录比较的要领： 
      1. 当原始目录和目标目录在各自的递归(指定-r选项)过程中,在相同深度的地方,出现名字相同的文件时，才会对这个名字相同的文件做比较
	  2. 当原始目录和目标目录在各自的递归(指定-r选项)过程中,在相同深度的地方，出现名字相同的目录时，才会各自进入这个名字相同的目录，并goto 1
	  3. 一旦在相同深度的地方，找到名字相同的文件时，比较的原则就演变为文件同文件之间的比较,将上面所述的3中模式！
   2. 目录比较时，4个重要的选项
      1. -u: unified,采用合并模式生成补丁文件
	  2. -q: 只列举出两个文件有无差异，而不进行比较
	  3. -r: 递归比较目录中的子目录，其本质要点是：原始目录和目标目录，在相同深度的位置，是否有相同名字(文件，目录)
	  4. -N: 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录，文件A 若使用-N参数，则diff会将文件A 与一个空白的文件比较；该选项能确保补丁文件能正确地处理已经创建或删除文件的情况
   3. 生成补丁文件的最终命令： diff -u -Nr old-package/ new-package/ 
Blog creation time:[2017-10-01 日 08:48]
** DONE [#D] Theme:patch详解(打补丁)						   :@Blog:@Linux:
   SCHEDULED:<2017-10-01 日>
   - State "DONE"       from "WAITTING"   [2017-10-01 日 18:13]
1. 当patch的对象是一个文件
   1. 打补丁命令，版本升级：patch old-version.txt <diff.patch  
   2. 去除补丁命令，版本回退：patch -R  new-version.txt <diff.patch  
   3. 原则：
      1. 明确自己是想进行版本升级，还是版本回退，如果是进行版本升级，则使用打补丁命令，如果是进行版本回退，则进行去除补丁命令
	  2. 明确哪个是老版本，哪个是新版本，其方法是less diff.patch，补丁头处，以---开始的是原始文件，即老版本；以+++开始的是目标文件，即新版本
	  3. 在明确想要版本升级还是版本回退，以及分清楚哪个是老版本，哪个是新版本之后，严格根据上面的1,2条所示的命令，即可达到目的
2. 当patch的对象是一个目录(工程中常用，非常重要)
   1. 背景：
	  1. 发起了一个工程项目，并完成了它的初始版本，工程的源代码放置在linux/这个目录树下面
	  2. 该版本只包含了最基础的配置但可满足用户的基本需求，初始版本的大小为3GB，版本号为linux1.0
	  3. 将这个3GB大小的软件上传到ftp服务器，供广大用户免费下载使用
	  4. 随后，该工程项目逐步添加一些功能,对linux1.0进行了一些优化，删减了一些源代码，修复了一些bug，编译之后形成linux2.0,该版本的大小为4.8GB
	  5. 使用命令diff -uNr linux1.0/ linux2.0/,制作出补丁文件linux2.0.patch,该补丁的大小为36MB
	  6. 将这个36MB大小的linux2.0.patch上传到ftp服务器，供广大用户免费下载进行升级
	  7. 广大用户下载了一个36MB大小的补丁文件，然后按照下面介绍的打补丁的方法，对第一次下载的3GB大小的linux1.0执行打补丁操作
	  8. 使用命令patch -p0 <linux2.0.patch，这样就将linux1.0的源代码升级成linux2.0的源代码
	  9. 广大用户完成升级之后，发现linux2.0不稳定，很不爽，因此对刚升级的linux2.0的源代码进行去除补丁操作，会退回linux1.0的源代码
	  10. 使用命令patch -p0 -R <linux2.0.patch,这样，又穿梭回linux1.0了，棒棒哒
	  11. 广大用户中有一部分人很喜欢linux2.0中新增的一些功能，因此，找到了导致linux2.0不稳定的那个bug，并报告给该项目的发起者让它进行紧急修复该bug
	  12. 该项目的发起者收到该bug后，发现是linux/arch/alpha/boot/目录下出了问题，项目发起者立即火速修补了代码的bug，重新编译之后形成linux2.0.1,该版本大小为4.9GB
	  13. 使用命令diff -uNr linux2.0/arch/alpha/boot/ linux2.0.1/arch/alpha/boot/ >linux2.0.1.patch,该补丁的大小为7MB
	  14. 广大用户又下载了这个7MB大小的补丁文件，然后按照下面介绍的打补丁的方法，对本地的linux2.0执行打补丁操作
	  15. 使用命令patch -p1 <linux2.0.1
	  16. 现在广大可以愉快的使用linux2.0.1而不会出现不稳定的问题了
	  17. 该方案的优点
		  1. 用户只需下载一次3GB的linux1.0,之后就只用下载36M的linux2.0.patch而不用下载4.8GB的linux2.0就能获得linux2.0的源代码
		  2. 工程项目的发起者只用上传36M的linux2.0.1.patch，而不用每fix一个bug就上传几个G的工程源代码
		  3. 用户拿着补丁文件能随意的在linux1.0和linux2.0之间穿梭
   2. 打补丁命令，版本升级： patch -p(num) <diff.patch    
   3. 去除补丁命令，版本回退：patch -R -p(num) <diff.patch
   4. 操作步骤：
	  1. 明确自己是想进行版本升级，还是版本回退，如果是进行版本升级，则使用打补丁命令，如果是进行版本回退，则进行去除补丁命令
	  2. 明确哪个是老版本，哪个是新版本，其方法是less diff.patch，补丁头处，以---开始的是原始文件，即老版本；以+++开始的是目标文件，即新版本 
      3. 确定-p(num)中的num,一般为0，或者1，或者2，其意义需要参照补丁文件的补丁头，假设diff.patch的补丁头如下所示：
         --- linux-2.6.25_android/arch/alpha/boot/misc.c 2010-05-06 01:56:42.565397700 -0700
         +++ linux-2.6.29_android/arch/alpha/boot/misc.c 2010-05-06 00:51:06.000000000 -0700

         -p0：代表忽略0层目录，即从光标所在的当前目录中查找linux-2.6.25_android/arch/alpha/boot/misc.c，然后进行patch操作
		 -p1：代表忽略1层目录，即从光标所在的当前目录中查找arch/alpha/boot/misc.c，然后进行patch操作
		 -p2：代表忽略2层目录，即从光标所在的当前目录中查找alpha/boot/misc.c，然后进行patch操作
      4. 明确光标应该定位到哪个目录   
         --- linux-2.6.25_android/arch/alpha/boot/misc.c 2010-05-06 01:56:42.565397700 -0700
         +++ linux-2.6.29_android/arch/alpha/boot/misc.c 2010-05-06 00:51:06.000000000 -0700

         patch -p0 <diff.patch 由于忽略0层目录，所以应当进入到linux-2.6.25_android/目录下时，才能执行该操作
         patch -p1 <diff.patch 由于忽略1层目录，所以应当进入到linux-2.6.25_android/arch/目录下时，才能执行该操作
         patch -p2 <diff.patch 由于忽略2层目录，所以应当进入到linux-2.6.29_android/arch/alpha/目录下时，才能执行该操作
   5. 思考：为什么要有-p(num)参数
	  1. 一个工程可以看作一个目录树，很有可能我们只对该目录树下面第n层深度目录处的某个目录进行了修改，因此只用对该子目录打补丁就行，此时就可忽略掉前面的n层目录，直接对该子目录打补丁，即-p(num)使得我们可以对目录树下的任意子目录打补丁而不是对整个工程进行打补丁
	  2. 一个工程可能是合作的产物，所以会有很多人对它进行打补丁操作，由于不同的人对文件或目录的命名方式会不同，所以导致自己本地的该目录名可能与服务器上的该目录名不同步，此时如果你还是使用对整个工程进行打补丁的方法，那么由于目录名不同步，必然无法递归进入到这个原本已经经过修改的存在差异的目录中去，出现漏打补丁的现象，所以，在多人合作的项目中，务必使用-p(num)参数，过滤掉不是你负责的那些目录，直接定位到你负责的目录下去打补丁，这样既能能做到互不干扰，又能避免漏打补丁
   6. 工程合作项目打补丁的思考
	  1. 一个工程项目一般由多个成员共同开发，由于任务分工必然会存在交叉工作，因此如果在交叉代码处出现了bug，而双方都去制作了补丁来修补这个bug的话,很可能因为文件或目录的命名不一致的问题导致第二个打补丁的人在这些命名不一致的目录处出现漏打补丁的现象
	  2. 建议，最好尽量做到分工明确，交叉的地方，由双方协作共同生成补丁，然后打一次补丁即可
   7. patch操作的4个重要参数
	  1. -p(num): num是一个数字，表示，使用patch命令给 package-dir/ 打补丁时，忽略掉前num个目录层“/”，一般用-p0,-p1
	  2. -R: 给新对象打补丁，将其还原为旧对象
	  3. -E: 如果发现空文件，就删除它
Blog creation time:[2017-10-01 日 09:46]
** WAITTING [#D] Theme:正则表达式							   :@Blog:@Linux:
    SCHEDULED:<2017-10-17 二>
1. 知识点
   1. 处理字符串的手段 = 支持正则表达式的工具 +  正则表达式
   2. 正则表达式给出字符串的表示法, 它的作用只是以行为单位表示出指定字符串
   3. 支持正则表达式的工具给出处理字符串的方法, 它的作用是处理正则表达式给出的字符串
   4. 正则表达式是字符串处理的标准依据
   5. 正则表达式不是通配符,通配符代表的是bash接口的一个功能,而正则表达式是字符串的表示法
   6. 常见的支持正则表达式的工具: grep,awk,sed
   7. 支持通配符的工具: ls,cd等bash的接口命令均支持通配符
   8. 语系直接影响正则表达式的结果:
	  1. LANG=C: 0 1 2 3 ... 8 9 A B C D ... X Y Z a b c d ... x y z
	  2. LANG=zh_CN: 0 2 3 4 ... 8 9 a A b B c C d D ... x X y Y z Z
	  3. 针对LANG=C使用正则表达式: [A-Z] = A B C D ... X Y Z
	  4. 针对LANG=zh_CN使用正则表达式: [A-z] = A b B c C ...x X y Y z Z
	  5. 备注: 可以使用export LANG=C来设置语系
   9. 为了免疫语系对正则表达式结果的影响,给出了一些特殊的符号来代表特定的集合:
	  1. [:digit:]: 代表数字的集合: [0-9]
	  2. [:lower:]: 代表小写字母集合: [a-z]
	  3. [:upper:]: 代表大写字母集合: [A-Z]
	  4. [:alpha:]: 代表小写字母,大写字母的集合: [a-z] | [A-Z]
	  5. [:alnum:]: 小写字符,大写字母,数字的集合: [0-9] | [a-z] | [A-Z]
2. 正则表达式泛型: '元字符'
3. 正则表达式的元字符
   1. 关于元字符的重要说明:
      1. 元字符是对字符串的一种描述(更像一种范式),每个元字符规范一种类型的串
	  2. 元字符不带任何"感情色彩",仅仅是刻画符合这个元字符规范的串
	  3. 元字符描绘的对象是字符(包括回车,空格,换行等),不是单词,不是串,搞清楚这一点这是非常重要,大多数文档为了好看,经常以单词来示范,这是一个误区,下面的解释中特别以键盘随便敲击的asdf来强调这一点
	  4. 元字符描绘哪个目标文件中的串? 在目标文件中匹配到符合元字符范式的串以行为单位输出? 这两个重要的问题跟元字符无关,只跟正则表达式查找工具(如:grep,awk,sed等)相关
   2. asdf: (非元字符),拿整个 'asdf', 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	  1. 示例: grep -n 'hello world' a.txt
	  2. 解释: 在a.txt中,所有存在hello world的行都会被匹配, 然后以带行号的形式,将这些行输出
   3. [asdf]: 依次拿[]中的字符, 去逐字符匹配目标文件,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
      1. 示例: grep -n 'a[df]g' a.txt
	  2. 解释: 在a.txt中,所有存在adg和afg的行都会被匹配,然后以带行号的形式,将这些行输出
   4. [^a.sD!f]: 从效果上理解, 拿着整个'a.sD!f' 去和目标文件匹配, 若没有匹配成功(在grep中,这里说的串被解释成行), 则满足该范式;
      1. 示例: grep -n 'I like dog!' a.txt
	  2. 解释: 在a.txt中, 所有不存在I like dog!的行被锁定,然后以带行号的形式,将这些行输出
	  3. ^在此处有取反的意思
   5. ^asdf: 拿着整个 'asdf' , 去和目标文件匹配, 若匹配成功,而恰好 asdf  又在串的开始位置(在grep中,这里说的开始位置被解释为行首), 则满足该范式;
      1. 示例: grep -n '^#' a.txt
	  2. 解释: 在a.txt中, 所有以#开头的行都会被匹配,然后以带行号的形式,将这些行输出
   6. $asdf: 拿着整个 'asdf' , 去和目标文件匹配, 若匹配成功,而恰好 asdf  又在串的结束位置(在grep中,结束位置定义为行尾),则满足该范式;
      1. 示例: grep -n '$!' a.txt
	  2. 解释: 在a.txt中,所有以!结尾的行都会被匹配,然后以带行号的形式,将这些行输出
   7. \x: 拿着x(代表任意字符的转义), 去和目标文件匹配, 若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行),则满足该范式
      1. 示例: grep -n '\"' a.txt
	  2. 解释: 在a.txt中,所有含有双引号的行都会被匹配,然后以带行号的形式,将这些行输出
	  3. 备注: grep -n '\'' a.txt是错误的,此时应当写为 grep -n \' a.txt
   8. ess*: 依次拿着 es,ess,esss ... 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	  1. 重点: * 代表可以重复*前面的字符s任意次数(0次,1次...),上面的es是重复0次时匹配到的,注意,e不能被匹配
      2. 示例: grep -n 'es*' a.txt
	  3. 解释: 在a.txt中,所有存在e,es,ess,esss...的行都会被匹配,然后以带行号的形式,将这些行输出
   9. ess+: 依次拿着 ess,esss ... 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	  1. 重点: + 代表可以重复+前面的字符s大于等于1次(1次,2次...),上面的ess是重复1次时匹配到的,注意,es不能被匹配
   10. o\{2\}: 目标文件中,2个o连续出现(oo)的串将被匹配
 	   1. 注意,对于grep来说,o\{2\}的含义是2个及以上的o连续出现(oo,ooo,oooo ...)
	   2. eo\{2\}中,同样也只关注o连续出现的次数,不用关注e连续出现的次数
   11. o\{2,\}: 目标文件中,2或者2个以上的o连续出现(oo,ooo,oooo)的串将被匹配
   12. o\{1,3\}: 目标文件中,连续出现o的个数最少为1个,最多为3个的串将被匹配
   13. do\(es)?: 依次拿着 do 或者 does 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
   14. e.e : 在目标文件中, 匹配 'e任何单个字符e',  若匹配成功,,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	   1. 重点: 点 . 有且仅有单个字符,注意了,一定有一个字符,而且仅仅只有一个字符 edfe是不会匹配的
	   2. 示例: grep -n 'o.o' a.txt
	   3. 解释: 在a.txt中,所有存在o字符o的行都会被匹配,然后以带行号的形式,将这些行输出
Blog creation time:[2017-10-17 二 13:32]
** WAITTING [#D] Theme:grep命令							:@Blog:@Linux:ATTACH:
    SCHEDULED:<2017-10-17 二>
1. 文本搜索工
2. 以行为单位
3. 具支持正则表达式
4. 接收的输入: 文件,标准输入流
5. 经典示例
   1. grep -n 'the' a.txt b.txt ... 
      1. 从文件序列a.txt,b.txt,c.txt ... 中,区分大小写的匹配含有关键字符串'the'的所有行
	  2. 以带行号的形式将匹配到的这些行打印到标准输出
	  3. -n: 输出时显示行号
   2. grep -nv 'the' a.txt b.txt ...
      1. 从文件序列a.txt,b.txt,c.txt ... 中,区分大小写的匹配含有关键字符串'the'的所有行,
	  2. 以带行号的形式将除匹配到的行之外的所有行打印到标准输出
	  3. -v: 方向选择
   3. grep -ni 'the' a.txt b.txt ...
	  1. 从文件序列a.txt,b.txt,c.txt ... 中,不区分大小写的匹配含有关键字符串'the'的所有行
	  2. 以带行号的形式将匹配到的所有行打印到标准输出
	  3. -i: 不区分大小写
   4. grep -nvi 'the' a.txt b.txt ...
	  1. 从文件序列a.txt,b.txt,c.txt ... 中,不区分大小写的匹配含有关键字符串'the'的所有行
	  2. 以带行号的形式将除匹配到的行之外的所有行打印到标准输出
Blog creation time:[2017-10-17 二 15:33]
** DONE [#D] theme:sed命令									   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:40]
*** sed介绍
>> sed英文全称是stream editor,流编辑器，它是一个简单而强大的文本解析转换工具

>>在1973-1974年期间由贝尔实验室的Lee E. McMahon开发，今天，它已经运行在所有的主流操作系统上了，
	
>>支持正则表达式

>>可以从文件中接受类似于管道的输入

>>可以接受来自标准输入流的输入

>>功能同awk类似，差别在于，sed简单，对列处理的功能要差一些，awk的功能复杂，对列处理的功能比较强大

>>一次处理一行内容,处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令
处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，
直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。

>>用于：文本替换，选择性的输出文本文件，从文本文件的某处开始编辑，无交互式的对文本文件进行
编辑，自动编辑一个或多个文件，简化对文件的反复操作，编写转换程序等
*** sed的工作原理
sed的内部实现遵循简单的工作流：读取，执行和显示
--读取：sed从输入流(标准输入流，文件，管道)读取一行，并存储在专用buff中
--执行：sed命令对专用的buff中的执行命令
--显示：将专用buff中由命令执行后的行发送到输出流，发送之后，专用buff会被清空
结论：
>> 行，是sed处理的基本单位
>> sed相关的命令作用于专用buff中的行，对输入流中的数据没有影响
*** sed命令的两种调用形式
>> 命令模式：sed [option] 'sed_command' target_filename
>> 脚本模式：sed [option] -f command_script_files target_filename
其中，命令模式使用单引号指定要执行的命令，而脚本模式则指定了包含sed命令的脚本文件

--[option]:
-e ：直接在命令行模式上进行sed动作编辑，此为默认选项；
-f ：将sed的动作写在command_script内，-f command_script_files则可以运行其内部的动作；
-n ：默认情况下(-e)，模式空间中的内容在处理完成后将会打印到标准输出，该选项用于阻止该行为
-r ：sed 的动作支持的是延伸型正规表示法的语法(默认是基础正规表示法语法)；
-i ：直接修改目标文件的内容，而不是输出到终端 

Blog creation time:[2017-09-01 五 10:39]
