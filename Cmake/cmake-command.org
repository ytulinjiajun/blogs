* WAITTING [#C] Theme:cmake-command                                  :@Cmake:
*** <<get_filename_component>>  :Scripting Commands:
#+BEGIN_SRC 
get_filename_component(<VAR> <FileName> <COMP> [CACHE])
#+END_SRC
将<VAR>设置为<FileName>的一个组件，其中<COMP>是以下之一：
DIRECTORY = Directory without file name
NAME      = File name without directory
EXT       = File name longest extension (.b.c from d/a.b.c)
NAME_WE   = File name without directory or longest extension
PATH      = Legacy alias for DIRECTORY (use for CMake <= 2.8.11)
路径以正斜线返回，没有后斜线。总是考虑最长的文件扩展名。如果指定了可选的CACHE参数，则结果变量将被添加到缓存中。

示例: /home/ljj/workspace/project/stm32/system/CMakeLists.txt
#+BEGIN_SRC 
get_filename_component(STM32_CMAKE_DIR ${CMAKE_CURRENT_LIST_FILE} DIRECTORY)
message("CMAKE_CURRENT_LIST_FILE=${CMAKE_CURRENT_LIST_FILE}")
message("STM32_CMAKE_DIR=${STM32_CMAKE_DIR}")
#+END_SRC
如果 <COMP> 是 DIRECTORY,则 <VAR> 的值(STM32_CMAKE_DIR)就是: /home/ljj/workspace/project/stm32/system/
如果 <COMP> 是 NAME, 则 <VAR> 的值就是(STM32_CMAKE_DIR)就是: CMakeLists.txt
*** <<set>> :Scripting Commands:
作用: 为 普通变量,cache变量,环境变量 赋值,请参阅 [[cmake-language(7)]] 变量 文档以了解正常变量和缓存条目的范围和交互
说明: <value>...标识此命令需要零个或者多个参数,若给出多个参数(set(tmp 2 GREATER 1)),则这些参数被连接成一个list的形式(2;GREATER;1),零个参数将会导致正常的变量被隐式的 [[unset]] 掉
**** Set Normal Variable
 #+BEGIN_SRC 
 set(<variable> <value>... [PARENT_SCOPE])
 #+END_SRC
1. 不使用 PARENT_SCOPE 的情况下: 当前目录中定义的变量只能在: 当前目录, 子目录, 子目录的子目录...  中使用,无法传递到其父目录中使用
2. 使用 PARENT_SCOPE 的情况下:  当前目录中定义的变量有且只能在其直接父目录中使用(注意:在当前目录无法使用,在其子目录无法使用,在其子目录的子目录无法使用,在其父目录的父目录无法使用 
3. 如果<value>的值有多个,如 set(t a.c b.c c.c d.c),则t会自动变为一个list
备注: 实现变量全局共享的另外一个方法是使用 [[set_property]] 命令
**** Set Environment Variable
#+BEGIN_SRC 
set(ENV{<variable>} <value>...)
#+END_SRC 
作用: 将当前进程环境变量设置为给定值
示例: set(ENV{[[CC]]} "gcc")
**** Set Cache Entry
#+BEGIN_SRC 
set(<variable> <value>... CACHE <type> <docstring> [FORCE])
#+END_SRC
- 持久缓存的有关知识可参考 [[Cache]]

- 作用: 设置给定的缓存<变量>（缓存条目）

- 作用域: 持久缓存变量在: 当前目录,子目录,子目录的子目录... 父目录,父目录的父目录中都是可见的,但是一定得在递归调用点之后才有效
(比如当前目录tt中add_subdirectory(subdir)命令会引起工作目录转移到subdir中,如果在subdir中的CMakeLists.txt中定义的CACHE变量,在tt目录中想要使用
该变量,只能在add_subdirectory命令之后才有效,在其之前无效)

- 由于缓存条目旨在提供用户可设置的值，因此默认情况下不会覆盖现有的缓存条目,使用 FORCE 选项覆盖现有条目

- <type> 必须是下面指定中的一个:
- BOOL: 布尔ON / OFF值, cmake-gui（1）提供了一个复选框
- FILEPATH: 磁盘上文件的路径。 cmake-gui（1）提供了一个文件对话框
- PATH: 磁盘上目录的路径。 cmake-gui（1）提供了一个文件对话框
- STRING: 一行文字。如果设置了STRINGS缓存条目属性，cmake-gui（1）将提供一个文本字段或一个下拉选择
- INTERNAL: 一行文字。 cmake-gui（1）不显示内部条目。它们可能被用来在变量间持久地存储变量。这种类型的使用意味着FORCE。

- 必须将<docstring>指定为一行文本，提供cmake-gui（1）用户呈现选项的快速摘要

- 如果缓存条目在调用之前不存在，或者给出FORCE选项，则缓存条目将被设置为给定值。而且，当前作用域中的任何正常变量绑定都将被删除，以将新缓存的值显示给任何紧随其后的计算

- 高速缓存条目可能在调用之前存在，但如果用户通过-D <var> = <value>选项在cmake（1）命令行上创建，而没有指定类型，则不会设置类型集
在这种情况下，set命令将添加类型。此外，如果<type>是PATH或FILEPATH，并且命令行上提供的<value>是相对路径，则set命令将把路径视为相对于当前工作目录并将其转换为绝对路径
*** <<list>> :Scripting Commands:
    1. 泛型1: list(LENGTH <list> <output variable>) 
	     1. set(tmp a b c d e f)
	     2. list(LENGTH tmp len)
	     3. message(STATUS "len=${len}")
	     4. 返回: 6
    2. 泛型2: list(GET <list> <element index> [<element index> ...] <output variable>)
	     1. set(tmp1 a b c d e f)
	     2. list(GET tmp1 3 5 tmp2)
	     3. message(STATUS "tmp2=${tmp2}")
	     4. 返回: d;f
	     5. 备注: 3 5代表元素的编号,含义为取列表中编号为3和5的元素,列表的编号从0开始
    3. 泛型3: list(REVERSE <list>)
	     1. set(tmp1 a b c d e f)
	     2. message(STATUS "tmp1=${tmp1}")
       3. list(REVERSE tmp1)
	     4. message(STATUS "tmp1=${tmp1}")
	     5. 返回: tmp1=a b c d e f; tmp1=f e d c b a
    4. 泛型4: list(FIND <list> <value> <output variable>)
	     1. set(tmp1 a b c d e f)
       2. list(FIND tmp1 b tmp2)
       3. message(STATUS "tmp2=${tmp2}")	
       4. 返回: 1  
       5. 备注: <value>只能是一个元素; <output variabes>是<value>在列表中的位置; 列表中元素的编号从0开始; 当没有找到<value>时,返回-1
    5. 泛型5: list(APPEND <list> [<element> ...])
       1. set(tmp1 a b c d e f)
       2. list(APPEND tmp1 3 h 7 m )
       3. message(STATUS "tmp1=${tmp1}")
       4. 返回: a b c d e f 3 h 7 m
    6. 泛型6: list(INSERT <list> <element_index> <element> [<element> ...])
       1. 作用: 在编号为<element_index>的元素前面插入元素
       2. set(tmp1 a b c d e f)
       3. list(INSERT tmp1 3 f 7 9 0)
       4. message(STATUS "tmp1=${tmp1}")
       5. 返回: a b c f 7 9 0 d e f
       6. 备注: 元素编号从0开始
    7. 泛型7: list(REMOVE_ITEM <list> <value> [<value> ...])
       1. set(tmp1 a b c d e f)
       2. list(REMOVE_ITEM tmp1 c d)
       3. message(STATUS "tmp1=${tmp1}")
       4. 返回: a b e f
    8. 泛型8: list(REMOVE_AT <list> <index> [<index> ...])
       1. set(tmp1 a b c d e f)
       2. list(REMOVE_AT tmp1 2 4)
       3. message(STATUS "tmp1=${tmp1}")
       4. 返回: a b d f
       5. 备注: <index>可以为负数: list(REMOVE_AT tmp1 -2 -5),返回 a c d f
       6. 注意,如果为负数,则最后一个数的编号是-1
    9. 泛型9: list(REMOVE_DUPLICATES <list>)
       1. 作用: 移除列表中重复的元素
       2. set(tmp1 a b a d a f)
       3. list(REMOVE_DUPLICATES tmp1)
       4. message(STATUS "tmp1=${tmp1}")
       5. 返回:  a b d f
    10. 泛型10: list(SORT <list>)
       1. set(tmp1 e b 3 d c 2 a f 1)
       2. list(SORT tmp1)
       3. message(STATUS "tmp1=${tmp1}")
       4. 返回: 1 2 3 a b c d e f
    11. 泛型11: list(FILTER <list> <INCLUDE|EXCLUDE> REGEX <regular_expression>)
          1. set(tmp1 e b 4 d c 2 a f 1)
          2. list(FILTER tmp1 INCLUDE REGEX [0-9])
          3. message(STATUS "tmp1=${tmp1}")
          4. 返回: 4 2 1
          5. 备注: <INCLUDE|EXCLUDE>给出过滤后保留哪一部分, REGEX标识后面接正则表达式,更多正则表达式的知识参考 [[string]]()
*** <<string>> :Scripting Commands:
    1. 泛型1: string(FIND <string> <substring> <output variable> [REVERSE])
       1. 作用: 从串<string>中找出子串<substring>的位置,将子串中第一个元素在串中首次出现的位置的编号存储在变量中
       2. string(FIND "li njim aj un" "ji" tmp)
       3. message(STATUS "tmp=${tmp}")
       4. 返回: 4
       5. 备注: 如果找不到子串,则返回-1,比如<substring>为in就会返回-1,为i n就会返回1
    2. 泛型2: string(REPLACE <match_string> <replace_string> <output variable> <input> [<input>...])
       1. string(REPLACE "i n" "**" tmp "li njim aj un" " i nm pq")
       2. message(STATUS "tmp=${tmp}")
       3. 返回: l**jim aj un **m pq
    3. 泛型3: string(REGEX MATCH <regular_expression> <output variable> <input> [<input>...])
       1. string(REGEX MATCH [b-f] tmp "a d" "b c")
       2. message(STATUS "tmp=${tmp}")
       3. 返回: d
       4. 注意: 匹配正则表达式中第一个遇到的字符
    4. 泛型4: string(REGEX MATCHALL <regular_expression> <output variable> <input> [<input>...])
       1. string(REGEX MATCHALL [b-f] tmp "a de" "b c")
       2. message(STATUS "tmp=${tmp}")
       3. 返回: d;e;b;c
    5. 泛型5: string(REGEX REPLACE <regular_expression> <replace_expression> <output variable> <input> [<input>...])
       1. string(REGEX REPLACE [b-f] "*" tmp "a de m" "h b c g")
       2. message(STATUS "tmp=${tmp}")
       3. 返回: a ** mh * * g
    6. 泛型6: string(APPEND <string variable> [<input>...])
       1. set(tmp "hello world")
       2. string(APPEND tmp "lin" "jia jun")
       3. message(STATUS "tmp=${tmp}")
       4. 返回: hello worldlinjia jun
    7. 泛型7: string(PREPEND <string variable> [<input>...])
       1. set(tmp "hello world")
       2. string(PREPEND tmp "lin" "jia jun")
       3. message(STATUS "tmp=${tmp}")
       4. 结果: 理论上是 linjia junhello world,但是该版本的cmake测试不支持PREPEND
    8. 泛型8: string(CONCAT <output variable> [<input>...])
       1. string(CONCAT tmp "lin " "jia jun")
       2. message(STATUS "tmp=${tmp}")
       3. 返回: lin jia jun
    9. 泛型9: string(TOLOWER <string1> <output variable>)
       1. string(TOLOWER "LIN JIA JUN" tmp)
       2. message(STATUS "tmp=${tmp}")
       3. 结果: lin jia jun
    10. 泛型10: string(TOUPPER <string1> <output variable>)
        1. string(TOUPPER "lin jia jun" tmp)
        2. message(STATUS "tmp=${tmp}")
        3. 结果: LIN JIA JUN
    11. 泛型11: string(LENGTH <string> <output variable>)
        1. string(LENGTH "lin jia jun" tmp)
        2. message(STATUS "tmp=${tmp}")
        3. 结果: 11
    12. 泛型12: string(SUBSTRING <string> <begin> <length> <output variable>)
        1. string(SUBSTRING "lin jia jun" 2 4 tmp)
        2. message(STATUS "tmp=${tmp}")
        3. 返回: n ji
        4. 备注: 字符串编号从0开始
    13. 泛型13: string(STRIP <string> <output variable>)
        1. string(STRIP "   lin     jia jun  " tmp)
        2. message(STATUS "tmp=${tmp}")
        3. 结果: "lin jia jun"
    14. 泛型14: string(GENEX_STRIP <input string> <output variable>)
        1. 从输入字符串中去除任 [[generator expressions ]] 表达式并将结果存储在输出变量中
    15. 泛型15: string(COMPARE LESS <string1> <string2> <output variable>)
        1. 比较字符串,然后将true或者false存储在输出变量当中
    16. 泛型16: string(COMPARE GREATER <string1> <string2> <output variable>)
        1. 比较字符串,然后将true或者false存储在输出变量当中
    17. 泛型17: string(COMPARE EQUAL <string1> <string2> <output variable>)
        1. 比较字符串,然后将true或者false存储在输出变量当中
    18. 泛型18: string(COMPARE NOTEQUAL <string1> <string2> <output variable>)
        1. 比较字符串,然后将true或者false存储在输出变量当中
    19. 泛型19: string(COMPARE LESS_EQUAL <string1> <string2> <output variable>)
        1. 比较字符串,然后将true或者false存储在输出变量当中
    20. 泛型20: string(COMPARE GREATER_EQUAL <string1> <string2> <output variable>)
        1. 比较字符串,然后将true或者false存储在输出变量当中
    21. 泛型16: string(<HASH> <output variable> <input>)
        1. 计算输入字符串的加密哈希
        2. 支持的<HASH>算法名称是: MD5, SHA1, SHA224, SHA256, SHA384, SHA512, SHA3_224, SHA3_256, SHA3_384, SHA3_512 
    22. 泛型17: string(ASCII <number> [<number> ...] <output variable>)
        1. 将所有数字转换为相应的ASCII字符
    23. 泛型18: string(CONFIGURE <string1> <output variable> [@ONLY] [ESCAPE_QUOTES])
        1. 像 [[configure_file]]() 转换一个文件那样,转换一个字符串
    24. 泛型19: string(RANDOM [LENGTH <length>] [ALPHABET <alphabet>] [RANDOM_SEED <seed>] <output variable>)
        1. string(RANDOM LENGTH 6 tmp)
        2. message(STATUS "tmp=${tmp}")
        3. 生成一个6位数的随机数,随机数由大小写字母和数字构成
    25. 泛型20: string(TIMESTAMP <output variable> [<format string>] [UTC])
        1. string(TIMESTAMP tmp "%Y年-%m月-%d日 %H:%M:%S")
        2. message(STATUS "tmp=${tmp}")
        3. 结果: 2017年-11月-17日 13:27:07
        4. <format string>:
           1. %%        A literal percent sign (%).
           2. %d        The day of the current month (01-31).
           3. %H        The hour on a 24-hour clock (00-23).
           4. %I        The hour on a 12-hour clock (01-12).
           5. %j        The day of the current year (001-366).
           6. %m        The month of the current year (01-12).
           7. %b        Abbreviated month name (e.g. Oct).
           8. %B        Full month name (e.g. October).
           9. %M        The minute of the current hour (00-59).
           10. %s        Seconds since midnight (UTC) 1-Jan-1970 (UNIX time).
           11. %S        The second of the current minute.60 represents a leap second. (00-60)
           12. %U        The week number of the current year (00-53).
           13. %w        The day of the current week. 0 is Sunday. (0-6)
           14. %a        Abbreviated weekday name (e.g. Fri).
           15. %A        Full weekday name (e.g. Friday).
           16. %y        The last two digits of the current year (00-99)
           17. %Y        The current year.
    26. 泛型21: string(MAKE_C_IDENTIFIER <input string> <output variable>)
        1. string(MAKE_C_IDENTIFIER hello.c tmp)
        2. message(STATUS "tmp=${tmp}")
        3. 结果: hello_c 
    27. 泛型22: string(UUID <output variable> NAMESPACE <namespace> NAME <name> TYPE <MD5|SHA1> [UPPER])
        1. 根据RFC4122基于组合值<namespace> （其本身必须是有效的UUID）的哈希来创建一个唯一的唯一标识符（又名GUID）<name>
        2. 如果需要，可以用可选UPPER标志请求大写字母表示
*** <<foreach>> :Scripting Commands:
#+BEGIN_SRC 
foreach(loop_var arg1 arg2 ...)
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
endforeach(loop_var)
#+END_SRC
    在foreach和匹配endforeach之间的所有命令都被记录而不被调用,一旦计算到了endforeach，
在foreach命令中列出的每个参数都会调用记录的命令列表一次,在循环的每次迭代之前，${loop_var} 将被设置为一个具有列表中当前值的变量

示例:
#+BEGIN_SRC 
    1) set(mylist arg1 arg2 arg3)
    2) foreach(loop_var ${mylist})
    3) message(STATUS “${loop_var}”)
    4) endforeach(loop_var)	  
#+END_SRC
返回： arg1 arg2 arg3


#+BEGIN_SRC 
foreach(loop_var RANGE total)
foreach(loop_var RANGE start stop [step])
#+END_SRC
Foreach也可以迭代生成的数字范围。这个迭代有三种类型：
- 指定单个数字时，范围将包含0到“total”的元素
- 指定两个数字时，范围将包含从第一个数字到第二个数字的元素
- 第三个可选数字是用于从第一个数字迭代到第二个数字的增量

示例:
#+BEGIN_SRC 
     1) set(result 0)
     2) foreach(_var RANGE 0 100)
     3) math(EXPR result "${result}+${_var}")
     4) endforeach()
     5) message("from 0 plus to 100 is:${result}")
     6) 
#+END_SRC
返回： 5050
备注：如果是foreach(_var RANGE 30),则表示从0~30,如果是foreach(_var RANGE 4 10 2),则表示从4~10，步长为2

#+BEGIN_SRC 
foreach(loop_var IN [LISTS [list1 [...]]]
                    [ITEMS [item1 [...]]])
#+END_SRC
- 迭代 items 的精确列表
- LISTS 选项列出要被遍历的列表值变量,包括空元素（一个空字符串是一个零长度列表）。 （注意宏参数不是变量。）
- ITEMS 选项结束参数解析并在迭代中包含其后面的所有参数
*** <<function>> :Scripting Commands:
#+BEGIN_SRC 
          1. function(<name>  [arg1 [arg2 [arg3 ...]]])
      	  2. COMMAND1(... arg1 ...)
      	  3. COMMAND1(... arg2 ...)
      	  4. COMMAND1(... arg3 ...)
          5. COMMAND1(... ARGC ...)
          6. COMMAND2(... ARGV1 ...)
          7. COMMAND3(... ARGV2 ...)
	        8. ......
       	  9. COMMAND4(... ARGVN ...)
          10. endfunction(<name>)
#+END_SRC
作用: 定义一个名为<name>的函数

function()与[[macro]]()的区别: 在宏中设置的的变量在可以在外部被访问到,而在函数中设置的变量是局部的,外部无法访问

函数的语法以及参数的传递同macro()别无二致,参考它即可

	想要使得函数内部定义的变量可以被外部访问到也有可行的方法: function(T tmp)  set(${tmp} "hello" PARENT_SCOPE)  endfunction(T) 
外部就可以 T(V2)message(STATUS "V2=${V2}"),返回hello,注意set(${tmp} ... PARENT_SCOPE)的写法(必须这样写),tmp想象成C语言中的函数
传入指针和传入变量的问题就可以理解为什么是${tmp}而不是tmp了,使用 PARENT_SCOPE 是因为函数会构建一个局部作用域

说明: 除非函数 <name> 被调用,否则在function()以及endfunction()之间的命令不会被调用

注意: 函数内部的变量应当让他外部不可见,如果非要让外部可见,那么最好使用macro
*** <<macro>>  :Scripting Commands:
#+BEGIN_SRC 
    1. macro(<name>  [arg1 [arg2 [arg3 ...]]])
    2. COMMAND1(... arg1 ...)
    3. COMMAND1(... arg2 ...)
    4. COMMAND1(... arg3 ...)
    5. COMMAND1(... ARGC ...)
    6. COMMAND2(... ARGV1 ...)
    7. COMMAND3(... ARGV2 ...)
    8. ......
    9. COMMAND4(... ARGVN ...)
   10. endmacro(<name>)
#+END_SRC         
1. 作用: 定义一个名为<name>的宏

2. 调用宏示例:
#+BEGIN_SRC 
   1. 在cmake/xxx.make中给出如下宏定义
   2. macro(macro_test arg1 arg2)
   3. message(STATUS "ARGC=${ARGC}")                                               
   4. message(STATUS "ARGV0=${ARGV0}")                                             
   5. message(STATUS "ARGV1=${ARGV1}")                                             
   6. message(STATUS "ARGV2=${ARGV2}")                                             
   7. message(STATUS "ARGN=${ARGN}")                                               
   8. endmacro(macro_test)     
   9. 
   10. 在CMakeLists.txt中给出如下代码
   11. include(cmake/xxx.make)
   12. macro_test("hello" "word" "hi")
#+END_SRC
结果: 
   1. ARGC = 3
   2. ARGV0 = hello
   3. ARGV1 = world
   4. ARGV2 = hi
   5. ARGV =  hello;world;hi
   6. ARGN = hi

参数说明: 假设存在宏定义 macro(T arg1 arg2), 调用 T("t1" "t2" "t3" "t4"),
   1. ARGC 记录传入参数的个数: 4
   2. ARGV0: 记录第1个传入参数的值: t1 
   3. ARGV1: 记录第2个传入参数的值: t2
   4. ARGV2: 记录第3个传入参数的值: t3
   5. ARGV3: 记录第4个传入参数的数值: t4
   6. ARGV: 记录传入的所有参数列表: t1;t2;t3;t4
   7. ARGN: 记录超出宏定义参数的那些参数: t3;t4

   宏参数(如ARGV,ARGC)不是变量,而if(<variabes>)要求一个变量,这意味着if(DEFINED ARGV1)的写法是错误的,
可以书写为if(DEFINED ${ARGV1}),通常的做法是先使用set(list_var "${ARGV1}")将宏参数赋值给一个变量,然后用这个变量去传递给if(DEFINED list_var)

   宏不等同于编程语言里面的函数,宏不允许递归调用  

6. macro() 与 [[function]]() 的区别在于: 在宏中设置的的变量在外部被访问到,而在函数中设置的变量是局部的
*** <<execute_process>> :Scripting Commands:
#+BEGIN_SRC 
execute_process(COMMAND <cmd1> [args1...]]
                [COMMAND <cmd2> [args2...] [...]]
                [WORKING_DIRECTORY <directory>]
                [TIMEOUT <seconds>]
                [RESULT_VARIABLE <variable>]
                [RESULTS_VARIABLE <variable>]
                [OUTPUT_VARIABLE <variable>]
                [ERROR_VARIABLE <variable>]
                [INPUT_FILE <file>]
                [OUTPUT_FILE <file>]
                [ERROR_FILE <file>]
                [OUTPUT_QUIET]
                [ERROR_QUIET]
                [OUTPUT_STRIP_TRAILING_WHITESPACE]
                [ERROR_STRIP_TRAILING_WHITESPACE]
                [ENCODING <name>])
#+END_SRC
作用: 运行一个或多个命令的给定序列，并与每个进程的标准输出并行输入到下一个的标准输入。所有进程都使用一个标准错误管道。

参数说明:
COMMAND: 一个子进程命令行,CMake直接使用操作系统API执行子进程。所有参数都通过VERBATIM传递给子进程。没有使用中间shell，因此shell运算符（如>）被视为正常参数
如果需要按顺序执行多个命令，可使用多个带有单个COMMAND参数的execute_process()调用
WORKING_DIRECTORY: 该参数指定的目录将被设置为子进程的当前工作目录
TIMEOUT: 如果子进程没有在指定的秒数内完成（允许分数），子进程将被终止
RESULT_VARIABLE: 该变量将被设置为包含最后一个子进程的结果。这将是来自最后一个子代的整数返回代码或描述错误条件的字符串
RESULTS_VARIABLE <variable>: 变量将被设置为包含所有进程的结果作为列表，按照给定的COMMAND参数的顺序。每个条目都是来自相应子代的整数返回代码或描述错误条件的字符串。
OUTPUT_VARIABLE, ERROR_VARIABLE: 名称变量将分别设置为标准输出和标准错误管道的内容。如果为两个管道命名了相同的变量，则它们的输出将按照生成的顺序进行合并。
INPUT_FILE, OUTPUT_FILE, ERROR_FILE: 指定的文件将分别附加到第一个进程的标准输入，最后一个进程的标准输出或所有进程的标准错误。如果同一文件同时被命名为输出和错误，那么它将被用于两者。
OUTPUT_QUIET, ERROR_QUIET: 标准输出或标准错误结果将被忽略
ENCODING <name>: 在Windows上，用于解码进程输出的编码。在其他平台上忽略。有效的编码名称是：NONE, AUTO, ANSI, OEM, UTF8

备注: 如果同一管道有多个OUTPUT_ *或ERROR_ *选项，则不指定优先级。如果没有给出OUTPUT_ *或ERROR_ *选项，输出将与CMake进程本身的相应管道共享。
execute_process()命令是exec_program()的一个更新的更强大的版本，但是为了兼容性保留了旧的命令。 CMake在构建系统生成之前正在处理项目时运行这两个命令。
使用add_custom_target（）和add_custom_command（）来创建在构建时运行的自定义命令。

使用示例: 
#+BEGIN_SRC 
  execute_process(COMMAND unzip -o -d ${STM32_TOOLKITS_DIR}/STM32Cube/STM32Cube${STM32_FAMILY} ${STM32Cube_ARCHIVE_FULL})
#+END_SRC
结果: CMake回去调用系统的shell,执行unzip命令解压指定的文件到指定的目录

*** <<file>> :Scripting Commands:
    1. 泛型1: file(WRITE | APPEND <filename> <content>...)
       1. 作用: 写/追加<content>所示的内容到指定文件<filename> 
	     2. WRITE: 写内容到文件<filename>,如果<filename>不存在,则创建并写入内容,如果<filename>已经存在,则覆盖
	     3. APPEND: 追加内容到文件<filename>,如果如果<filename>不存在,则创建并写入内容,如果<filename>已经存在,则追加在其后面
	     4. <filename>: 指定的文件,如果该文件是一个带路径的文件如 test/a.txt 如果目录test不存在,则创建
	     5. 备注: 如果这个文件是一个 build input, 则当这个文件的内容改变时,使用[[configure_file]]()来更新这个文件
    2. 泛型2: file(READ <filename> <variable> [OFFSET <offset>] [LIMIT <max-in>] [HEX])
	     1. 作用: 从文件<filename>中读内容,存储在该变量<variabes>内
	     2. 可以从给定的<offset>个字节开始，最多读取<max-in>个字节
	     3. HEX选项会将数据转换为十六进制表示（对二进制数据有用）
    3. 泛型3: file(STRINGS <filename> <variable> [<options>...])
	     1. 作用: 从文件<filename>解析ASCII字符串的列表,然后存储在变量<variabes>内
	     2. 文件中的二进制数据将会被忽略,回车（\ r，CR）字符被忽略
	     3. 注意: 解析的是ASCII,有UNICOUDE编码的中文等是无法解析的,解析的意思就是遍历文件中的所有ASCII字符,读取出来存在指定变量内
	     4. <options>:
	        1. LENGTH_MAXIMUM <max-len>: 只考虑至多给定长度的字符串
	        2. LENGTH_MINIMUM <min-len>: 只考虑最少给定长度的字符串
          3. LIMIT_COUNT <max-num>: 限制要提取的不同字符串的数量
	        4. LIMIT_INPUT <max-in>: 限制从文件读取的输入字节数
          5. LIMIT_OUTPUT <max-out>: 限制要存储在<变量>中的总字节数
	        6. NEWLINE_CONSUME: 将换行符（\ n，LF）作为字符串内容的一部分，而不是终止于它们
          7. NO_HEX_CONVERSION: 除非给出此选项，否则Intel Hex和Motorola S-record文件将在读取时自动转换为二进制文件
	        8. REGEX <regex>: 只考虑匹配给定正则表达式的字符串
          9. ENCODING <encoding-type>: 考虑给定编码的字符串。目前支持的编码是：UTF-8，UTF-16LE，UTF-16BE，UTF-32LE，UTF-32BE。如果没有提供ENCODING选项，并且文件有一个字节顺序标记，那么ENCODING选项将被默认为遵守字节顺序标记
    4. 泛型4: file(<HASH> <filename> <variable>)
	     1. 作用: 计算<filename>内容的加密散列并将其存储在<variable>中
	     2. 支持的<HASH>算法名称是由字符串（<HASH>）命令列出的
    5. 泛型5: file(GLOB <variable> [LIST_DIRECTORIES true|false] [RELATIVE <path>] [<globbing-expressions>...])
	     1. 作用: 生成匹配<globbing-expressions>的文件列表并将其存储到<variable>中
       2. Globbing表达式与正则表达式类似，但要简单得多
       3. 默认情况下，GLOB列出目录,如果LIST_DIRECTORIES设置为false，则结果中的目录将被忽略
       4. 如果指定了RELATIVE标志，结果将作为给定路径的相对路径返回,结果将按照字典顺序排列
       5. 不建议使用GLOB从源代码树中收集源文件列表。如果在添加或删除源时没有更改CMakeLists.txt文件，则生成的生成系统无法知道何时要求CMake重新生成。
       6. Globbing表达式的几个例子:
	        1. *.cxx: 匹配所有扩展名为cxx的文件
          2. *.vt?: 匹配所有扩展名为vta,...,vtz的文件
          3. f[3-5].txt: 匹配f3.txt, f4.txt, f5.txt
    6. 泛型6: file(GLOB_RECURSE <variable> [FOLLOW_SYMLINKS] [LIST_DIRECTORIES true|false] [RELATIVE <path>] [<globbing-expressions>...])
	     1. GLOB_RECURSE模式将遍历匹配目录的所有子目录并匹配文件
       2. 只有在给定FOLLOW_SYMLINKS或策略CMP0009未设置为NEW的情况下才会遍历符号链接的子目录
       3. 默认情况下，GLOB_RECURSE从结果列表中省略目录,将LIST_DIRECTORIES设置为true将目录添加到结果列表中
       4. 如果给定FOLLOW_SYMLINKS或策略CMP0009未设置为OLD，则LIST_DIRECTORIES将符号链接视为目录
       5. Globbing表达式: /dir/*.py: 匹配/ dir和子目录中的所有python文件
    7. 泛型7: file(RENAME <oldname> <newname>)
	     1. 作用: 在从<oldname>到<newname>的文件系统中删除文件或目录，以原子方式替换目标
    8. 泛型8: file(REMOVE [<files>...])
    9. 泛型9: file(REMOVE_RECURSE [<files>...])
    10. 泛型10: file(MAKE_DIRECTORY [<directories>...])
    11. 泛型11: file(RELATIVE_PATH <variable> <directory> <file>)
    12. 泛型12: file(TO_CMAKE_PATH "<path>" <variable>)
        1. 作用: 将<path>转换为cmake风格的path
        2. 示例: file(TO_CMAKE_PATH "/usr/bin/" mypath)
        3. 结果: message("mypath=${mypath}") ---->  /usr/bin
    13. 泛型13: file(TO_NATIVE_PATH "<path>" <variable>)
    14. 泛型14: file(DOWNLOAD <url> <file> [<options>...])
    15. 泛型15: file(UPLOAD   <file> <url> [<options>...])
    16. 泛型16: file(TIMESTAMP <filename> <variable> [<format>] [UTC])
    17. 泛型17: file(GENERATE OUTPUT output-file  <INPUT input-file|CONTENT content> [CONDITION expression])
    18. 泛型18: file(<COPY|INSTALL> <files>... DESTINATION <dir> [FILE_PERMISSIONS <permissions>...] [DIRECTORY_PERMISSIONS <permissions>...] [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS] [FILES_MATCHING] [[PATTERN <pattern> | REGEX <regex>] [EXCLUDE] [PERMISSIONS <permissions>...]] [...])
    19. 泛型19: file(LOCK <path> [DIRECTORY] [RELEASE] [GUARD <FUNCTION|FILE|PROCESS>] [RESULT_VARIABLE <variable>] [TIMEOUT <seconds>])
*** <<find_file>> :Scripting Commands:
#+BEGIN_SRC 
find_file (<VAR> name1 [path1 path2 ...])
#+END_SRC
#+BEGIN_SRC 
find_file (
          <VAR>
          name | NAMES name1 [name2 ...]
          [HINTS path1 [path2 ... ENV var]]
          [PATHS path1 [path2 ... ENV var]]
          [PATH_SUFFIXES suffix1 [suffix2 ...]]
          [DOC "cache documentation string"]
          [NO_DEFAULT_PATH]
          [NO_CMAKE_PATH]
          [NO_CMAKE_ENVIRONMENT_PATH]
          [NO_SYSTEM_ENVIRONMENT_PATH]
          [NO_CMAKE_SYSTEM_PATH]
          [CMAKE_FIND_ROOT_PATH_BOTH |
           ONLY_CMAKE_FIND_ROOT_PATH |
           NO_CMAKE_FIND_ROOT_PATH]
         )
#+END_SRC
作用: 该命令用于查找指定文件的完整路径

参数说明: 
<VAR>: cache entry, 存储该命令的结果, 如果找到文件的完整路径，则结果将存储在变量中，除非变量被清除，否则不会重复搜索。如果没有找到，则结果将是<VAR> -NOTFOUND，并且在下次调用相同变量的find_file时再次尝试搜索。
NAMES: 为文件的完整路径指定一个或多个可能的名称,当使用这个名称来指定带和不带版本后缀的名字时，建议首先指定不带版本名称，这样可以在分发之前找到本地构建的包。
HINTS, PATHS: 指定要搜索的目录以及默认位置。 ENV var子选项从系统环境变量中读取路径。这两个参数的区别是 HINTS 在 PATHS 之前搜索,以及 PATHS 是硬编码猜测
PATH_SUFFIXES: 指定额外的子目录用与检查每个目录位置下方的这些子目录的位置
DOC: 指定<VAR>缓存条目的文档字符串
NO_DEFAULT_PATH: 如果指定了该关键字,则不会将其他路径添加到搜索中。如果没有指定 [[NO_DEFAULT_PATH]]，搜索过程如下：
1. 在 cmake-specific cache variables 指定的路径将会被搜索, 通常这些路径是在命令行上使用-DVAR=value传递进来的,这些值被解释为 ;-list 形式的列表,如果传递 [[NO_CMAKE_PATH]]，可以跳过这个
2. 在特定于cmake的环境变量中指定的搜索路径。这些都是在用户的shell配置中设置的，因此使用主机的本地路径分隔符（;在Windows和UNIX上）。如果传递 [[NO_CMAKE_ENVIRONMENT_PATH]]，可以跳过这个。
3. 搜索 [[HINTS]] 选项指定的路径
4. 搜索标准系统环境变量,如果指定了 [[NO_SYSTEM_ENVIRONMENT_PATH]]，这可以被跳过
5. 搜索当前系统平台文件中定义的cmake变量,如果指定了 [[NO_SYSTEM_ENVIRONMENT_PATH]] ,可以跳过该搜索
6. 搜索由 [[PATHS]] 选项指定的路径或在命令的简写版本中。这个典型的硬编码猜测

备注:
1. [[CMAKE_FIND_ROOT_PATH]] 指定一个或多个目录作为所有其他搜索目录的前缀, 默认情况下，CMAKE_FIND_ROOT_PATH是空的
2. [[CMAKE_SYSROOT]] 变量也可以用来指定一个目录作为前缀。设置CMAKE_SYSROOT也有其他影响。有关更多信息，请参阅该变量的文档。
3. 默认情况下，首先搜索 CMAKE_FIND_ROOT_PATH 中列出的目录，然后搜索 CMAKE_SYSROOT 目录，然后搜索non-rooted 目录。默认行为可以通过设置 [[CMAKE_FIND_ROOT_PATH_MODE_INCLUDE]] 进行调整
4. 上面3中所述的的行为,在每次调用的基础上可以使用下面的选项上手动覆盖：
   1. [[CMAKE_FIND_ROOT_PATH_BOTH]] 按上述顺序搜索
   2. [[ONLY_CMAKE_FIND_ROOT_PATH]] 只搜索 re-rooted 目录以及 [[CMAKE_STAGING_PREFIX]] 下面给出的目录
   3. [[NO_CMAKE_FIND_ROOT_PATH]] 不使用 [[CMAKE_FIND_ROOT_PATH]] 变量
5. 一旦所有调用的的一个成功，结果变量将被设置并存储在缓存中，这样就不会再有搜索

示例:
#+BEGIN_SRC 
set(STM32Cube_DIR ${STM32_TOP_DIR}/STM32Cube_FW_F4_V1.18.0/Drivers)
find_file(tmp_src NAMES stm32f4xx_hal_eth.c
  PATH_SUFFIXES STM32F4xx_HAL_Driver/Src
  HINTS ${STM32Cube_DIR}
  NO_DEFAULT_PATH)
message(STATUS "tmp_src=${tmp_src})
#+END_SRC
结果: tmp_src = ${STM32_TOP_DIR}/STM32Cube_FW_F4_V1.18.0/Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_eth.c
备注: 如果没有找到该文件,则tmp_src=tmp_src-NOTFOUND
*** <<find_path>> :Scripting Commands:
理论知识同 [[find_file]]()

示例:
#+BEGIN_SRC 
set(STM32Cube_DIR ${STM32_TOP_DIR}/STM32Cube_FW_F4_V1.18.0/Drivers)
find_path(tmp_inc NAMES stm32f4xx_hal_eth.h
  PATH_SUFFIXES STM32F4xx_HAL_Driver/Inc
  HINTS ${STM32Cube_DIR}
  NO_DEFAULT_PATH)
message(STATUS "tmp_inc=${tmp_inc})
#+END_SRC
结果: tmp_inc = ${STM32_TOP_DIR}/STM32Cube_FW_F4_V1.18.0/Drivers/STM32F4xx_HAL_Driver/Inc/
备注: 如果没有找到该文件,则tmp_inc=tmp_inc-NOTFOUND
*** <<find_package>> :Scripting Commands:
Module模式:
#+BEGIN_SRC 
find_package(<package> 
             [version] [EXACT] 
             [QUIET] [MODULE] [REQUIRED] 
             [[COMPONENTS] [components...]]
             [OPTIONAL_COMPONENTS components...]
             [NO_POLICY_SCOPE])
#+END_SRC
参数说明: 
<package>: 待查找的package名,该名字同 CMAKE_MODULE_PATH 路径下给定的 Find<package>.cmake 中的<package>严格一致
[version]: 该参数提供一个格式为 major[.minor[.patch[.tweak]]] 版本号,要求所发现的软件包应该兼容与该版本兼容
[EXACT]: 该参数要求版本必须精确匹配,如果在查找模块内部没有给出[版本]和/或组件列表的递归调用，相应的参数将自动从外部调用（包括[版本]的EXACT标志）转发。版本支持目前仅在逐个包的基础上提供
[QUIET]: 当搜索到package时，通过变量和包本身记录的“导入目标”提供特定于软件包的信息, 如果指定了该选项,在找不到package时则会禁用掉消息
[REQUIRED]: 如果找不到包，该选项将停止处理并显示错误消息
[COMPONENTS]: 可以在该选项之后列出package中特定组件列表,列出的这些列表均是package中的元素

备注: 
1. [[CMAKE_MODULE_PATH]] 提供了<package>的查找路径,要求在该路径下面必须存在 Find<package>.cmake
2. Find<package>.cmake 所做的工作其实就是将特定的的一些文件制作成一个标准的package,这个package的制作有一些基本的规范,通常在package的最后都会加入下面的两句:
include(FindPackageHandleStandardArgs) 
find_package_handle_standard_args(STM32HAL DEFAULT_MSG STM32HAL_INCLUDE_DIR STM32HAL_SOURCES)
其中: 
STM32HAL同Find<package>.cmake中的<package>名一致

原理: 
    在Find<package>.cmake中对一组文件进行组织,在最后使用这两句语句制作了一个名为 STM32HAL 的package, 该 package 内部总共提供了 ${STM32HAL_INCLUDE_DIR}
以及${STM32HAL_SOURCE}这些元素, 而 [[find_package]](STM32HAL COMPONENTS gpio tim REQUIRED)这样的命令则会在 CMAKE_MOUDLE_PATH给定的路径(Find<package>.cmake所在路径)中
查找Find<package>.cmake,然后加载 STM32HAL 这个 package 下面的 gpio tim 等组件

制作与调试package:
    从上面的原理不难看出,要想使用 find_package(xxx)命令,则要求t是一个符合一定规范的package,这个规范有如下要求:
1. 存在 Find<xxx>.cmake,该文件正是制作规范的package的那个文件
2. 存在set(CMAKE_MOUDLE_PATH "path"),其中path就是 Find<xxx>.cmake文件所在的路径,如此的话 find_package(xxx)才能加载到xxx这个package
注意: 
一个package是否制作成功,一个最重要的测试手段就是在调用完毕 find_package(STM32HAL COMPONENTS gpio tim REQUIRED)之后,打印一下
find_package_handle_standard_args(STM32HAL DEFAULT_MSG STM32HAL_INCLUDE_DIR STM32HAL_SOURCES)中提供的 STM32HAL_INCLUDE_DIR 以及  STM32HAL_SOURCES


知识拓展: 
1. <package>_FIND_COMPONENTS 背后的秘密:
   在命令 find_package(STM32HAL COMPONENTS gpio tim REQUIRED)中,希望加载　gpio tim　这两个组件，这两个组件参数是如何与Find<package>.cmake中指定的内容关联起来的，
经过大胆的猜测可谨慎的测试之后，发现之所以能以这样的方式传递，是因为在Find<package>.cmake中有一个变量同find_package中的　COMPONENTS 关键字所呼应，
这个变量是 STM32HAL_FIND_COMPONENTS,(可以归纳为 <package>_FIND_COMPONENTS), 实质上, COMPONENTS 关键字后面的列表是作为实参传递给 <package>_FIND_COMPONENTS 这个
变量的,也就是说,如果在find_package()中如果不指定 COMPONENTS 关键字,可以将 <package>_FIND_COMPONENTS 这个变量默认设置为全部组件, 缺省 COMPONENTS 加载时,就加载全部
组件, 如果指定了 COMPONENTS 关键字,加载时,就只加载指定组件

2. 加载了源文件还是头文件?
   在大多数情况下,一组想要制作成 package 的文件通常都是源文件可头文件一一对应的,因此,在 Find<xxx>.cmake中务必实现既加载源文件,也加载头文件,可以使用 find_path 和
find_file 实现


Config模式
#+BEGIN_SRC 
find_package(<package> [version] [EXACT] [QUIET]
             [REQUIRED] [[COMPONENTS] [components...]]
             [CONFIG|NO_MODULE]
             [NO_POLICY_SCOPE]
             [NAMES name1 [name2 ...]]
             [CONFIGS config1 [config2 ...]]
             [HINTS path1 [path2 ... ]]
             [PATHS path1 [path2 ... ]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_PACKAGE_REGISTRY]
             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing.
             [NO_CMAKE_SYSTEM_PATH]
             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH])
#+END_SRC
*** <<find_library>> :Scripting Commands:
**** 命令:
#+BEGIN_SRC 
     find_library (
     1. <VAR>
     2. name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
     3. [HINTS path1 [path2 ... ENV var]]
     4. [PATHS path1 [path2 ... ENV var]]
     5. [PATH_SUFFIXES suffix1 [suffix2 ...]]
     6. [DOC "cache documentation string"]
     7. [NO_DEFAULT_PATH]
     8. [NO_CMAKE_PATH]
     9. [NO_CMAKE_ENVIRONMENT_PATH]
     10. [NO_SYSTEM_ENVIRONMENT_PATH]
     11. [NO_CMAKE_SYSTEM_PATH]
     12. [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH]
     15. )
#+END_SRC
**** 参数解析:
1. <VAR>: 存储查找结果,如果找到了库文件,则将该文件(带绝对路径)存储在该变量内,如果没找到,该变量的值为<VAR>-NOTFOUND
2. name | NAMES name1 [name2 ...] [NAMES_PER_DIR] 
   1. name: 指定查找一个库
   2. NAMES: 指定查找一个或者更多个待搜索库的名字,当给NAMES选项赋予多个值时，默认情况下这个命令会一次考虑一个名字并搜索每个目录
   3. NAMES_PER_DIR选项告诉该命令一次考虑一个目录，并搜索其中的所有名称
   4. 给予NAMES选项的每个库名首先被认为是库文件名，然后考虑平台特定的前缀（例如lib）和后缀（例如.so）,因此可以直接指定libfoo.a等库文件名
3. [HINTS path1 [path2 ... ENV var]]
   1. 指明除了默认位置之外,还要搜索的目录
   2. ENV var 子选项从系统环境变量中读取路径
4. [PATHS path1 [path2 ... ENV var]]
   1. 指明除了默认位置之外,还要搜索的目录
   2. ENV var 子选项从系统环境变量中读取路径
5. [PATH_SUFFIXES suffix1 [suffix2 ...]]
   1. 指定补充子目录,如此便会检查每个搜索路径下面含有补充子目录的目录,比如: /home/ljj/t1 是PATHS中的指定搜索的目录,那么默认会到该路径下面搜索,但是不会搜索/home/ljj/t1/tmp
   2. 如果给出该选项为 tmp, 除了到 /home/ljj/t1下面搜索,还会到/home/ljj/t1/tmp下面搜索
6. [DOC "cache documentation string"]
   1. 之后的参数用来作为cache中的注释字符串
7. NO_DEFAULT_PATH: 如果指定了该选项，那么搜索的过程中不会有其他的附加路径,如果没有指定该选项，搜索过程如下：
   1. 搜索在cmake-specific cache 变量中指定的路径, 从命令行以-DVAR=value的形式传入,这些值被解释为 [[lists]] 如果传递了 NO_CMAKE_PATH，可以跳过这个路径的搜索
   2. 
8. NO_CMAKE_PATH: 默认会搜索cmake特有的cache变量中被指定的路径(这些变量是在用cmake命令行时，通过-DVAR=value指定的变量),如果指定了该选项,则跳过该搜索路径,但是还包括如下的路径
   1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 [[CMAKE_PREFIX_PATH]] 中的每一个前缀
   2. [[CMAKE_LIBRARY_PATH]]
   3. [[CMAKE_FRAMEWORK_PATH]]
9. NO_CMAKE_ENVIRONMENT_PATH: 默认会搜索cmake特有的环境变量中被指定的路径,这是用户在shell配置中设置的变量,如过指定了该选项, 则跳过该搜索路径,但是还包括如下的路径
   1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 CMAKE_PREFIX_PATH 中的每一个前缀
   2. CMAKE_LIBRARY_PATH
   3. CMAKE_FRAMEWORK_PATH
10. NO_SYSTEM_ENVIRONMENT_PAT: 默认会搜索标准的系统环境变量,如果指定了该选项，这些环境变量中的路径会被跳过,但是搜索的路径还包括：PATH LIB
11. NO_CMAKE_SYSTEM_PATH: 默认会搜索当前系统平台文件中定义的cmake变量,如果指定了该选项,这些变量中的路径将会被跳过,但是还包括如下的路径
    1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 [[CMAKE_SYSTEM_PREFIX_PATH]] 中的每一个前缀
    2. [[CMAKE_SYSTEM_LIBRARY_PATH]]
    3. [[CMAKE_SYSTEM_FRAMEWORK_PATH]]
12. [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH]



   6. 搜索由PATHS或者精简版命令中指定的路径 
如果找到了库文件,搜索过程将不再重复，除非该变量被清空,如果没有找到库文件,下次使用相同变量调用find_library()命令时，搜索过程会再次尝试

       * 如果找到的库是一个框架，那么<VAR>将被设置为框架<fullPath> /A.framework的完整路径。当框架的完整路径被用作库时，CMake将使用-framework A和-F <fullPath>将框架链接到目标
       * 


       * CMake变量[[CMAKE_FIND_ROOT_PATH]]指定一个或多个目录作为所有其他搜索目录的前缀
       * [[CMAKE_SYSROOT]]变量也可以用来指定一个目录作为前缀
       * 默认情况下，首先搜索CMAKE_FIND_ROOT_PATH中列出的目录,然后搜索CMAKE_SYSROOT目录，然后搜索非根目录的目录。默认行为可以通过设置[[CMAKE_FIND_ROOT_PATH_MODE_LIBRARY]]进行调整
       * 在13中所示的行为可以通过下面的参数覆盖
         1. CMAKE_FIND_ROOT_PATH_BOTH: 按照13所述的顺序搜索
         2. ONLY_CMAKE_FIND_ROOT_PATH: 不使用CMAKE_FIND_ROOT_PATH变量
         3. NO_CMAKE_FIND_ROOT_PATH: 只搜索re-rooted目录以及[[CMAKE_STAGING_PREFIX]]下的目录
       * 默认的搜索顺序的设计逻辑是按照使用时从最具体到最不具体。通过多次调用find_library命令以及NO_*选项，可以覆盖工程的这个默认顺序
       * 如果设置了[[CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX]]变量，所有的搜索路径将被正常测试，附带后缀，并且所有匹配的lib /替换为lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/
         1. 如果[[FIND_LIBRARY_USE_LIB32_PATHS]]全局属性被设置，所有的搜索路径将被正常测试，32 /附加，lib /所有匹配替换为lib32 /。如果至少启用了project（）命令支持的一种语言，则会自动为已知需要的平台设置此属性
         2. 如果[[FIND_LIBRARY_USE_LIB64_PATHS]]全局属性被设置，所有的搜索路径将被正常地测试，64 /追加，并且所有匹配的lib /替换为lib64 /。如果至少启用了project（）命令支持的一种语言，则会自动为已知需要的平台设置此属性
       * 变量CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX将覆盖FIND_LIBRARY_USE_LIB32_PATHS，FIND_LIBRARY_USE_LIBX32_PATHS和FIND_LIBRARY_USE_LIB64_PATHS全局属性
*** <<find_program>> :Scripting Commands:
*** <<add_custom_command>> :Project Commands:
作用: 增加自定义的 "构建规则" 来生成构建系统
**** Generating Files
#+BEGIN_SRC 
add_custom_command(OUTPUT output1 [output2 ...]
                   COMMAND command1 [ARGS] [args1...]
                   [COMMAND command2 [ARGS] [args2...] ...]
                   [MAIN_DEPENDENCY depend]
                   [DEPENDS [depends...]]
                   [BYPRODUCTS [files...]]
                   [IMPLICIT_DEPENDS <lang1> depend1
                                    [<lang2> depend2] ...]
                   [WORKING_DIRECTORY dir]
                   [COMMENT comment]
                   [DEPFILE depfile]
                   [VERBATIM] [APPEND] [USES_TERMINAL]
                   [COMMAND_EXPAND_LISTS])
#+END_SRC
作用: 官方的定义: 自定义一个命令来生成指定的输出文件; 我对它的理解: 自定义一个 makefile 中提到的概念, "规则"

	在 makefile 中, "规则"的概念是十分重要的,简单回顾一下, "规则" 由 "目录","依赖","命令" 构成, 下面就是一条最基本的规则:
#+BEGIN_SRC 
hello.o: hello.c hello.h def.h
[RET] gcc -c $^ -o $@
#+END_SRC
	当"依赖列表"中的任意一个的时间戳比"目标"还新时,就会触发"命令",命令所做的事情通常就是生成或重建 "目标", 在该命令 add_custom_command()中,
OUTPUT 关键字后面给出的就是一个"目标"或者"目标列表"(对应与Makefile中多目标规则的概念), 通常一般都只给出一个"目标";DEPENDS 关键字后面给出的
则相当于makefile中的"依赖列表"; COMMAND关键字后面给出的则对应于makefile中的命令,除此之外,其他的选项均可看做附加选项

参数说明:
OUTPUT: "目标", "规则"被"触发"之后,"命令"得以执行,执行的结果是生成"目标",也就是 OUTPUT 关键字后面对应的那个 文件

DEPENDS: "依赖", "规则"的"命令"在执行之前,或许会依赖于其他 "规则" 的 "目标", 即,  该关键字后面给出的就是其他 "规则" 的 "目标", 在同一个 CMakeLists.txt中,
如果该关键字后面给出的值("依赖")是其他 add_custom_command  ("规则") 的 OUTPUT("目标"), 那么,CMake将会自动的把那个 add_custom_command 带入到这个 add_custom_command
所构建的 "目标" 中来; 如果未指定DEPENDS，则只要OUTPUT丢失，该规则就会触发, 如果该命令实际上不创建OUTPUT(伪目标,即不是一个文件)，那么该规则将始终被触发; 如果 DEPENDS 后面
指定了任何由 [[add_custom_target]](), [[add_executable]](), 或者 [[add_library]]() 所构建的目标,那么,一个 目标级别 的依赖关系就会被创建，以确保该目标在使用此自定义规则的任何目标之前构建
此外，如果目标是可执行文件或库，则会创建 文件级别 的依赖关系，以便在重新编译目标时重新运行自定义命令。参数可以使用 [[generator expressions]]

COMMAND: "命令", "规则"被"触发","命令" 将会得到执行, 如果指定了多个COMMAND，它们将按顺序执行，但不一定组成有状态的shell或批处理脚本,
如果要运行一个完整的脚本，可使用 [[configure_file]]() 命令或 [[file]](GENERATE) 命令来创建它，然后指定一个COMMAND来启动它; 可选的ARGS参数是为了向后兼容性，通常将被忽略

COMMENT: 在构建时,执行命令之前显示给定的消息
**** Build Events
#+BEGIN_SRC 
add_custom_command(TARGET <target>
                   PRE_BUILD | PRE_LINK | POST_BUILD
                   COMMAND command1 [ARGS] [args1...]
                   [COMMAND command2 [ARGS] [args2...] ...]
                   [BYPRODUCTS [files...]]
                   [WORKING_DIRECTORY dir]
                   [COMMENT comment]
                   [VERBATIM] [USES_TERMINAL])
#+END_SRC
作用: 添加自定义命令到一个诸如库或者可执行文件这样的目标,这对于在构建目标之前或之后执行操作很有用。该命令成为目标的一部分，并将只在目标本身被构建时执行。如果目标已经建立，命令将不会执行。

add_custom_command 定义了一个新的命令，这个命令与<target> 指定的 building 建立起关联, 这要求 <target> 必须在当前 CMakeLists.txt中定义,如果在其他 CMakeLists 中定义可能不会被指定

参数说明:
TARGET: 该关键字后面的参数指明添加该自定义命令到哪个目标
PRE_BUILD: 指明该命令在目标执行任何其他规则之前运行, 这仅在Visual Studio 8或更高版本上受支持。对于所有其他生成器，PRE_BUILD将被视为PRE_LINK
PRE_LINK: 指明该命令在编译源代码之后，在链接二进制文件或运行静态库的库管理器或归档工具之前运行,对于由 [[add_custom_target]]()创建的目标,该选项不会被定义
POST_BUILD: 在目标内的所有其他规则执行后运行
*** <<add_custom_target>> :Project Commands:
     :LOGBOOK:
     CLOCK: [2017-12-10 日 21:11]--[2017-12-10 日 21:51] =>  0:40
     :END:
#+BEGIN_SRC 
add_custom_target(Name [ALL] [command1 [args1...]]
                  [COMMAND command2 [args2...] ...]
                  [DEPENDS depend depend depend ... ]
                  [BYPRODUCTS [files...]]
                  [WORKING_DIRECTORY dir]
                  [COMMENT comment]
                  [VERBATIM] [USES_TERMINAL]
                  [COMMAND_EXPAND_LISTS]
                  [SOURCES src1 [src2...]])
#+END_SRC
作用: 添加一个没有输出的目标(伪目标)，所以它总会被构建
	
添加一个给名的目标, 这个给定名的目标执行给定的命令, 这个目标没有输出文件，可以理解为Makefile中的伪目标, 并且即使命令尝试创建具有目标名称的文件，也总是被视为已过时.
如果想要生成一个有输出文件的目标, 可使用 [[add_custom_command]]()命令; 默认情况下，没有任何东西依赖于该伪目标目标, 可以使用 [[add_dependencies]] ()命令添加依赖关系

Name: 伪目标目标名
ALL:  指示应将此目标添加到默认的构建目标，以便每次都运行
DEPENDS: 在同一个CMakeLists.txt中, 使用 [[add_custom_command]]() 命令调用创建的参考文件和自定义命令的输出文件。当目标被建立时，它们将会被更新。
使用 [[add_dependencies]]()命令添加对其他目标的依赖关系。
COMMAND: "命令", "规则"被"触发","命令" 将会得到执行, 如果指定了多个COMMAND，它们将按顺序执行，但不一定组成有状态的shell或批处理脚本,
如果要运行一个完整的脚本，可使用 [[configure_file]]() 命令或 [[file]](GENERATE) 命令来创建它，然后指定一个COMMAND来启动它;
如果COMMAND指定了一个由 [[add_executable]]() 创建的可执行目标名,它会自动被在构建时创建的可执行文件的位置替换。此外，还将添加目标级依赖项，以便在此自定义目标之前构建可执行目标
该选项是可选的，如果没有指定，将会创建一个空目标。
COMMENT: 在构建时执行命令之前显示给定的消息
*** <<add_dependencies>>  :Project Commands:
#+BEGIN_SRC 
add_dependencies(<target> [<target-dependency>]...)
#+END_SRC
作用: 使top-level <target> 依赖于其他  top-level <target> 目标，以确保它们在 <target> 之前构建,
top-level 是由 [[add_executable]]()，[[add_library]]() 或 [[add_custom_target]]() 等命令创建的目标。

说明: 这意味着该命令中的<target> 是在 [[add_executable]]()，[[add_library]]() 或 [[add_custom_target]]() 创建的目标之后进行创建的
*** <<add_library>> :Project Commands:
**** Normal Libraries
1. 命令: add_library(<name> [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 [source2 ...])
2. 作用: 将上述命令中列出的源文件编译到到一个名为<name>的库里面
3. <name> 是全局唯一的,假定name为tmp,则最终生成libtmp.a或者libtmp.so,具体生成静态库还是动态库依赖于选项, 请参阅 [[OUTPUT_NAME]] 目标属性的文档以更改最终文件名<name>
4. STATIC: 静态库,在链接阶段,同其他目标一起被全部链接成可执行文件
5. SHARED: 动态库,在链接阶段,其库名,函数名同其他目标一起链接成可执行文件,在运行期间动态加载
6. MODULE: 插件,不会同其他目标一起被链接成可执行文件,但是,可以在运行期间使用类似dlopen的功能动态加载
7. 如果被有显式指出 [STATIC | SHARED | MODULE] 中的任何一个,默认值是 STATIC 还是 SHARED 取决于变量 [[BUILD_SHARED_LIBS]] 是否为ON (为ON则默认为动态库)
8. 如果库的类型是 SHARED 和 MODULE，则 [[POSITION_INDEPENDENT_CODE]] 目标属性自动设置为ON
9. SHARED或STATIC库可以用 FRAMEWORK 目标属性标记来创建OS X框架
10. 如果库不导出任何符号，则不能将其声明为SHARED库,例如，在Windows上,一个不导出非托管符号的 resource DLL or a managed C++/CLI DLL 可能需要声明成一个MODULE库而不是SHARED库,这是因为CMake希望SHARED库在Windows上始终有一个关联的导入库
11. 默认情况下,库文件将会在构建树目录的位置被创建,当然了,请参阅 [[ARCHIVE_OUTPUT_DIRECTORY]], [[LIBRARY_OUTPUT_DIRECTORY]], [[RUNTIME_OUTPUT_DIRECTORY]] 来改变这个位置
12. EXCLUDE_FROM_ALL: 如果指定了该选项,在创建库时,相应的属性就会被设置,详情参阅 [[EXCLUDE_FROM_ALL]] 的文档
13. source1 [source2 ...]: 加入库的源文件列表,该参数可以使用 $<...> 这样的  “generator expressions” ,详情参考 [[ cmake-generator-expressions(7)]]
14. 有关定义生成系统属性的更多信息，请参阅 [[cmake-buildsystem（7）]]手册
15. 另请参阅 [[HEADER_FILE_ONLY]]，了解在某些源被预处理的情况下如何处理，以及想要在IDE中使用原始源又该如何处理
**** Imported Libraries
1. 命令: add_library(<name> <SHARED|STATIC|MODULE|OBJECT|UNKNOWN> IMPORTED [GLOBAL])
2. 一个 [[IMPORTED library target]] 引用一个位于项目外部的库文件,不会生成规则来构建它, 并且 [[IMPORTED]] 目标属性是 true 
3. <name>的范围只在创建它的目录中，但GLOBAL选项扩展了它的可见性, 以至于它可以像在项目中构建的任何目标一样被引用
4. 导入库对于像 [[target_link_libraries]]（）这样的命令的方便引用很有用
5. 有关导入的库的详细信息通过设置名称以IMPORTED_和INTERFACE_开头的属性指定
6. 最重要的属性是 [[IMPORTED_LOCATION]]（及其预配置变体[[IMPORTED_LOCATION_ <CONFIG>]]），它指定主库文件在磁盘上的位置。有关更多信息，请参阅 IMPORTED_ * 和 INTERFACE_ * 属性的文档
**** Object Libraries
1. 命令: add_library(<name> OBJECT <src>...)
2. 对象库的特点是,对象库编译源文件，但不会将其对象文件存档或链接到库中,即,对象库不能被链接
3. 相反，由add_library（）或add_executable（）创建的其他目标可以使用形式为$ <TARGET_OBJECTS：objlib>的表达式引用对象作为源,其中,objlib是一个对象库的名
4. 例如:
#+BEGIN_SRC 
	add_library(... $<TARGET_OBJECTS:objlib> ...)
	add_executable(... $<TARGET_OBJECTS:objlib> ...)
#+END_SRC
该例子给出的代码,将objlib的对象文件包含在一个库和一个可执行文件中
1. 对象库可能只包含编译，头文件和其他不会影响正常库链接的源文件（例如.txt）
2. 它们可能包含生成此类源的自定义命令，但不包含PRE_BUILD，PRE_LINK或POST_BUILD命令
3. 一些本地构建系统可能不喜欢只有对象文件的目标，所以考虑将至少一个真实的源文件添加到任何引用$ <TARGET_OBJECTS：objlib>的目标
**** Alias Libraries
1. 命令: add_library(<name> ALIAS <target>)
2. 创建一个 [[Alias Target]] 使得<name>可以用于在后续命令中引用<target>
3. <name>不会作为一个 make target 出现在 generated buildsystem 中
4. <target>可能不是一个[[Imported Target]] 或 ALIAS
5. ALIAS目标可以用作可链接的目标，也可以用作从中读取属性的目标
6. 可以使用 if(TARGET) 子命令测试 Alias_Target的存在性
7. <name>不能用来修改<target>的属性，也就是说，它不能用作 [[set_property]]（），[[set_target_properties]]（），[[target_link_libraries]]（）等的操作数
8. 一个ALIAS目标可能不能被安装或导出
**** Interface Libraries
1. 命令: add_library(<name> INTERFACE [IMPORTED [GLOBAL]])
2. 作用: 创建一个 [[Interface Library]]
3. 一个 INTERFACE 库目标不会直接创建构建输出，尽管它可能具有设置的属性，并且可以安装，导出和导入
4. 通常使用以下命令将INTERFACE_ *属性填充到接口目标上：
   1. [[set_property]]()
   2. [[target_link_libraries]](INTERFACE)
   3. [[target_include_directories]](INTERFACE)
   4. [[target_compile_options]](INTERFACE)
   5. [[target_compile_definitions]](INTERFACE)
   6. [[target_sources]](INTERFACE)
5. 像其他的目标一样,它被用作 [[target_link_libraries]]()的参数
6. 一个 INTERFACE 导入的目标也可以用这个签名来创建, 一个IMPORTED库目标引用在项目外定义的库
7. 目标名称的范围在创建它的目录中，但GLOBAL选项扩展了可见性, 它可以像在项目中构建的任何目标一样被引用,IMPORTED库对于像target_link_libraries（）这样的命令的方便引用很有用
*** <<add_executable>> :Project Commands:
#+BEGIN_SRC 
泛型1: add_executable(<name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...])
#+END_SRC
- 作用: 使用源文件列表中指定的源文件来构建可执行目标<name>
- <name>对应于逻辑目标名字，并且在工程范围内必须是全局唯一的
- 默认情况下，可执行文件将会在构建树的路径下被创建，对应于该命令被调用的源文件树的路径。如果要改变这个位置，查看[[RUNTIME_OUTPUT_DIRECTORY]]目标属性的相关文档
- 果要改变最终文件名的<name>部分，查看[[OUTPUT_NAME]]目标属性的相关文档
- 如果指定了WIN32选项,那么, WIN32_EXECUTABLE 这个属性将会在目标被创建的时候被设置
- 如果指定了MACOSX_BUNDLE选项，对应的属性会附加在创建的目标上,查看MACOSX_BUNDLE目标属性的文档可以找到更多的细节
- 如果指定了EXCLUDE_FROM_ALL选项，对应的属性将会设置在被创建的目标上。查看EXCLUDE_FROM_ALL目标属性的文档可以找到更多的细节
- 源文件列表source1 [source2 ...] 到 add_executable 可以使用语法为$<...> 的 “生成器表达式”,更多信息查看 [[cmake-generator-expressions]]
#+BEGIN_SRC 
泛型2: add_executable(<name> IMPORTED [GLOBAL])
#+END_SRC

#+BEGIN_SRC 
泛型3: add_executable(<name> ALIAS <target>)
#+END_SRC
*** <<target_include_directories>> :Project Commands:
#+BEGIN_SRC 
target_include_directories(<target> [SYSTEM] [BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> [items1...]
  [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
#+END_SRC
1. 作用： 当编译一个给定目标时，指定编译过程中使用到的 include directory
2. 要求： <target> 必须是一个已经被 [[add_executable]]() 或者 [[add_library]]()创建的目标，同时，不能是一个 [[IMPORTED]] 目标
3. [SYSTEM]: 如果指定了该选项，就等于告诉编译器，这个目录是作为 system include directory
4. [BEFORE]： 如果指定该选项，则内容将被预置到属性而不是被追加
5. <INTERFACE|PUBLIC|PRIVATE> [items1...]：指定参数的scope
   1. PUBLIC和PRIVATE items 将会构成<target>的[[INCLUDE_DIRECTORIES]]属性
   2. PUBLIC和INTERFACE items 将会构成<target>的[[INTERFACE_INCLUDE_DIRECTORIES]]属性
6. 如果[SYSTEM] 同 PUBLIC 或者 INTERFACE 一起被指定，将会构成<target>的[[INTERFACE_SYSTEM_INCLUDE_DIRECTORIES]]属性
6. 被指定的 include directory 可能是绝对路径或者是相对路径
7. 该命令的参数可能会使用语法为$<...>的“generator expressions”，详情查阅[[cmake-generator-expressions(7)]]
*** <<link_directories>> :Project Commands:
#+BEGIN_SRC 
link_directories(directory1 directory2 ...)
#+END_SRC
- 指定链接器应该搜索库的路径

- 该命令仅适用于调用后创建的目标

- 这个命令的相对路径被解释为相对于 current source directory ，见CMP0015。

备注: 
	官方文档上说该命令很少需要,推荐使用 [[find_library]]() 这两个命令  [[find_package]](), 我当时很执着,一定非得使用这两个命令来替代 link_directories, 可是,
我显然进入了一个误区, 人家说很少需要, 并没说该命令是一个将要丢弃的命令,于是乎, 我走错了方向:
	库, 可以是一个外部库,这样的库的特点是: 已经存在, 当然, 也可以是一个在CMakeLists.txt中使用 [[add_library]]() 创建的库. 对于外部库来说, 使用 find_library()命令 
来查找自然是没有什么问题的, 返回该外部库的绝对路径, 可是对于 CMakeLists.txt 中使用 add_library() 创建的库来说,这是有问题的:
  - sept1: 使用 cmake -H. -B_builds 这一命令生成 Makefile 文件
  - sept2: 使用 make --build _builds 来处理 Makefile 文件

  想想这两个过程有什么问题: 在CMakeLists.txt中使用 add_library(tmp STATIC hello.c) 命令创建的库 libtmp.a 是在 make --build _builds 之后才生成的, 然而,
命令 find_library(mytmp NAMES tmp PATH ...) 在 cmake -H. -B_builds 时就会在指定路径下查找 libtmp.a 这个库, 显然是找不到的, 因此 mytmp 的值是 tmp-NOFOUND,
此时, 如果在CMakeLists.txt中有使用 target_link_libraries(main ${mytmp})来引用 libtmp.a 这个库的话, 在 sept1 阶段就会产生一个错误:
  CMake Error: The following variables are used in this project, but they are set to NOTFOUND 

总结: link_directories() 命令用于内部库查找, find_library() 用于一个已经存在了的外部库   

测试小插曲: 
#+BEGIN_SRC 
当前目录下的CMakeLists.txt:
...

add_subdirectory(dir)

find_library(mytmp NAMES tmp HINTS  /home/ljj/workspace/tmp/find_library/lib)

message(STATUS "mytmp=${mytmp}")

if(EXISTS ${mytmp})
  add_executable(main main.c)
  target_link_libraries(main ${mytmp})
endif()
#+END_SRC
#+BEGIN_SRC 
子目录dir目录下面的CMakeLists.txt:

add_library(tmp STATIC hello.c)
#+END_SRC
   这一个有意思的测试,能帮助更好的理解link_directories()和find_library()之间的微妙关系:
   第一次使用 cmake -H. -B_builds是不会报错,但是,mytmp=mytmp-NOFOUND, 接着使用 cmake --build _builds时,会生成libtmp.a,
接着再次重复一遍第一次的两个命令,就可以生成可执行文件 main 了
*** <<target_link_libraries>> :Project Commands:
作用： 当链接一个给定的目标时，指定使用到的library或者flags
**** Overview
#+BEGIN_SRC 
target_link_libraries(<target> ... <item>... ...)
#+END_SRC
1. <target>： 必须已经在当前目录中使用 [[add_executable]]()或者[[add_library]]()完成创建
2. <item>： 每个item可能是下面的情况
   1. A library target name
   2. A full path to a library file
   3. A plain library name:
   4. A link flag
   5. A debug, optimized, or general keyword immediately followed by another <item>
**** Libraries for a Target and/or its Dependents
#+BEGIN_SRC 
target_link_libraries(<target>
                      <PRIVATE|PUBLIC|INTERFACE> <item>...
                     [<PRIVATE|PUBLIC|INTERFACE> <item>...]...)
#+END_SRC
1. PUBLIC, PRIVATE and INTERFACE 关键字用于指明在一个命令中的 link dependencies 和 link interface
2. 标识 PUBLIC 的Libraries and targets 会被链接到 link interface,并且成为link interface的一部分
3. 标识 PRIVATE 的Libraries and targets 会被链接到 link interface,但是不会成为link interface的一部分
4. 标识 INTERFACE 的 Libraries and targets 会被添附到 link interface,但是不用于链接<target>
**** Libraries for both a Target and its Dependents
#+BEGIN_SRC
target_link_libraries(<target> <item>...)
#+END_SRC
说明： 从文档的说明中，该用法同 target_link_libraries(<target> LINK_PUBLIC <lib>...)貌似一致
**** Libraries for a Target and/or its Dependents (Legacy)
#+BEGIN_SRC 
target_link_libraries(<target>
                      <LINK_PRIVATE|LINK_PUBLIC> <lib>...
                     [<LINK_PRIVATE|LINK_PUBLIC> <lib>...]...)
#+END_SRC
1. LINK_PUBLIC and LINK_PRIVATE modes 可以用于在一个命令中指明 the link dependencies and the link interface
2. 标识LINK_PUBLIC的Libraries and targets会被链接到 [[INTERFACE_LINK_LIBRARIES]] 并成为其中的一部分
3. 标识LINK_PRIVATE的Libraries and targets会被链接到 [[INTERFACE_LINK_LIBRARIES]] 但是不会成为其中的一部分
4. 如果 policy CMP0022 的值不是NEW,他们也会成为 [[LINK_INTERFACE_LIBRARIES]] 的一部份
**** Libraries for Dependents Only (Legacy)
#+BEGIN_SRC 
target_link_libraries(<target> LINK_INTERFACE_LIBRARIES <item>...)
#+END_SRC
1. LINK_INTERFACE_LIBRARIES模式添加这个库到[[INTERFACE_LINK_LIBRARY]]属性，而不是使用这个库来进行链接
2. 此用法仅用于兼容性，优先选择INTERFACE模式
**** Cyclic Dependencies of Static Libraries
**** Creating Relocatable Packages
*** <<configure_file>>
#+BEGIN_SRC 
configure_file(<input> <output>
               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]
               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])
#+END_SRC    
2. 作用: 将文件复制到其他位置并修改其内容, 一个典型的用法是让普通文件(.h)也能使用CMake中的变量
3. 意义: 实现 CMAKE 语法同源代码之间的交互
3. <input>: 输入文件,可以带绝对路径或者相对路径(注意这句话,必须是一个带路径的文件),但是必须是一个文件而不能是目录,如果使用相对路径,则会参考 [[CMAKE_CURRENT_SOURCE_DIR]]
4. <output>: 输出文件,该文件可以不存在,在执行时创建,可以带绝对路径或者相对路径,也可以是一个目录, 如果是相对路径,则会参考 [[CMAKE_CURRENT_BINARY_DIR]] ,如果是一个目录,
文件名就等于输入文件名
5. [COPYONLY]: 只是将<input>文件中的内容原原本本的复制到<>复制文件而不替换任何变量引用或其他内容,此选项不能与 NEWLINE_STYLE 一起使用
6. [ESCAPE_QUOTES]: 这是 configure_file(<input> <output>) 的默认行为, 所有被替换的变量将会按照C语言的规则被转义,如<input>中定义了
set(tmp "${PROJECT_NAME"}),复制到<output>中以后就会展开为 set(tmp "STM32F407ZGT6"), 如果定义了 project(STM32F407ZGT6) 的话
7. [@ONLY]: 只有@VAR@格式的变量会被替换而${VAR}格式的变量则会被忽略,这对于配置使用${VAR}语法的脚本非常有用
8. [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF]]: 指定输出文件的换行样式
9. 经典用法:
#+BEGIN_SRC 
	 1. # ${PROJECT_SOURCE_DIR}/cmake/CutCode_Config.h.in
	 2. #cmakedefine EN_USART1 @EN_USART1@  
	 3. 
	 4. # CMakeLists.txt
   5. #set(EN_USART1 1)
	 6. 
   7. configure_file(${PROJECT_SOURCE_DIR}/cmake/CutCode_Config.h.in ${PROJECT_SOURCE_DIR}/bin/CutCode_Config.h) 
#+END_SRC
结果: 在${PROJECT_SOURCE_DIR}/bin 目录下创建 CutCode_Config.h 头文件, 内容是 #define EN_USART1 1
10. 相似的命令 [[add_definitions]](-DFOO) 用于向源代码传递FOO是否定义,因此,在源代码中只能使用ifdef FOO ... endif来条件编译
11. [[configure_file]](config.h.in config.h)则可以参照config.h.in中的 #cmakedefine xx @tmp@ 语句生成config.h (define xx 1),源文件中include "config.h"以后可以使用条件编译裁剪内容
12. 总结: add_definitions()以及configure_file()搭配条件编译可以实现对源代码内容的裁剪,而cmake自身的语法又可以选择性编译某几个源文件,因此,cmake可以实现非常灵活的裁剪
