* 精华
1. 提交总是找HEAD!
2. git checkout ref
   1. 检出新分支
   2. 使得HEAD指向ref
   3. 随后的新提交挂接在该新分支上
3. git reset --hard ref: 改变HEAD的指向
4. 让分支的分支指针头(master)指向其他分支(游离分支)的技巧:
   1. 首先,使用checkout命令,切换至master分支(让HEAD指向master)
   2. 然后,使用reset命令,让HEAD指向另一分支(游离分支)的某个提交
* DONE [#D] theme:我的工具网站
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1. git 官方网站：http://git-scm.com
2. 廖雪锋：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
   Blog creation time:[2017-09-05 二 08:01]
* WAITTING [#D] theme:基本概念
1. 工作区：一个等待进行版本控制的目标目录
2. 版本库：当使用git init对一个工作区进行初始化之后，在工作区下产生一个名为.git的文件夹，该文件夹就称为版本库
3. 正确使用版本控制系统的方法是：一次提交只完成一件事
   1. 或是完成一个新功能
   2. 或是修改一个bug
   3. 或是写完一节内容
   4. 或是添加一副图片
   5. 注意：不要在下班才想起进行一次提交，那样的话git就降格成文件备份系统了
4. 环节
   1. 工作区  ----(1)--->  暂存区
   2. 暂存区  ----(2)--->  分支
   3. 工作区  ----(3)--->  分支
   4. 暂存区  ----(4)--->  工作区
   5. 分支    ----(5)--->  暂存区
   6. 分支    ----(6)--->  工作区 　
   7. 研究清楚，标编号上面6个环节中：单个文件的传递，所有文件传递，的相关操作方法，git的知识点就全了
5. 版本库干净： 当工作区 = 暂存区 = 对象库（最新）提交 ===> 版本库干净（使用git status无任何状态）
6. 思维逻辑: 从树形结构看版本库
   1. 错误的思维: 开发从树的根部到枝干进行.你可能会在想创建分支的过程:
	  1. 开发成员1,以master分支上的第1次提交,作为branch1分支的分支起点,在该分支上产生若干提交,形成第一个分支
	  2. 开发成员2,以master分支上的第1次提交,作为branch2分支的分支起点,在该分支上产生若干提交,形成第二个分支
	  3. 开发成员3,以master分支上的第1次提交,作为branch3分支的分支起点,在该分支上产生若干提交,形成第三个分支
	  4. ......
	  5. 开发成员n,以master分支上的第1次提交,作为branchn分支的分支起点,在该分支上产生若干提交,形成第n个分支
	  6. 结论: 版本库是从根到枝干的开发! 但是,不好意思,这个结论是错的
   2. 正确的思维: 开发从树的枝干到根部进行
      1. 根,可以看做系统的输出,即最终版本,枝干可以看成系统的输入,即各个分支的提交,开发的目的是为了得到根
	  2. 其实上面错误思维里面的所谓的根只是一个"假根",通常master分支上的第一次提交只是一个工程项目的基础设施而已,而并非结果
	  3. 项目的发起者在master分支上提交了一次该项目的"基础设施",该提交只包含了一些必备的初始化,驱动等等,相当于kernal
	  4. 项目的参与者以master分支上的第一次提交为分支起点,创建只属于自己的分支,所以一开始,每个参与者获得相同的"原料"
	  5. 项目的发起者自己想要开发,也需要以master创建一个自己的分支,比如master-manager,只有它才有权限在master生成根
	  6. 每个参与者在自己的分支上做属于自己模块的开发,然后不断向master-manager分支合并,master-manger认为开发的差不多了,可以生成第二个版本(根)的 时候,他会向master合并
Blog creation time:[2017-09-23 六 22:36]
* WAITTING [#D] theme:对象库解析
1. index:
   1. 该文件是一个二进制文件,本质上，是一个包含文件索引的目录树
   2. 使用git add xx-file之后，xx-file这个文件的文件名将会挂接在index这个文件的目录树上
   3. 然而，xx-file这个文件的实际内容并没有存储在index这个文件中，而是存储在.git/objects目录这个对象库中
   4. index中xx-file这个文件的索引和对象库.git/objects中xx-file这个文件的实体建立起对应关系
   5. index的真实面目：所有加入版本库的文件形成目录树；目录树上挂接着接受版本控制的文件（其中，每个挂接的文件主要提供三部分信息：第一，该文件的文件名；第二，该文件的文件大小，第三，最近一次使用扫描工作区改动的命令(如git status,git diff等)时，所扫描到的文件的最新的时间戳）；目录树同对象库中相应的文件形成对应
2. objects/:
   1. 使用git add xx-file将xx-file文件加入到版本库之后，文件名，大小，时间戳等信息登记在index文件的目录树上，xx-file文件内部的真实内容则存储在.git/object/这个对象库中
   2. 对象库.git/object/中的文件同index中的目录树有着对应关系(我猜想，index中的目录树好比一个指针链表，每一个节点下存放指针类型的文件名，指向对象库中的对应文件)
3. branches/
4. HEAD
5. config
6. hooks/
7. info/
8. refs
9. packed-refs
10. description
11. logs/
12. 对象库解析
	1. 对象库.git/obj/ ： 直观图解参看《git权威指南p87》
	   1. 对象库的本质一个双向链表，当前分支(比如master)是该链表的头指针,HEAD则是指向头指针的指针
	   2. 该链表的结点是一个又一个的commit，当前分支(比如master)可以在这些commit结点前后来回移动
	   3. 结点的指针域的值是commit类型的ID，该双向链表的就是通过这些ID值组织起来的
	   4. 结点的数据域由三部分构成：tree类型的ID,parent类型的ID,用户标识
		  1. tree类型是一个结构体类型,其成员是blob类型的指针，blob类型可以理解为文件类型，所以这些blob类型的指针就指向真正的文件
		  2. 每个blob类型的文件均有一个ID
	2. 寻址ID：git cat-file -p ID
	   1. ID值总是一个指针类型，要么指向commit结点，要么指向tree类型的结构体，要么指向blob类型的文件
	   2. 我们总可以使用:git cat-file -p ID,来解析指针ID的值,取得该指针下的值
	   3. 常规步骤是先使用git lg查看commit类型的ID,然后通过该ID就能逐一解析出tree类型的ID以及blobn类型的ID
	3. 查看对象库中文件内容
	   1. 查看当前分支对应的提交内容：git cat-file commit HEAD
	   2. 查看指定分支(比如master)对应的提交: git cat-file commit master
	   3. 查看当前分支下某文件的内容: git cat-file blob HEAD:<TAB补全>
	   4. 查看指定分支(比如master)下某文件的内容： git cat-file blob master:<TAB补全>
	4. 获取ID类型：git cat-file -t ID
	   1. 从上面对象库的分析中可以知道，git提供了如下3种类型的ID，对于给定ID，使用git cat-file -t ID，来了解该ID的类型
	   2. commit: 使用git lg查看到的ID就是commit类型的ID
	   3. tree:  
	   4. blob:
	5. 获取,分支以及HEAD，的ID: git rev-parse master;  git rev_parse HEAD
	6. HEAD,master,^,~的关系
	   1. HEAD指向当前分支，所以，HEAD就理解为当前分支
	   2. 分支是对象库的头指针，所以分支指向对象库的最新提交
	   3. master属于分支，是分支里面比较特殊的一个分支，称为主分支
	   4. 当且仅当存在master分支时，HAED自然就指向master
	   5. HEAD～n,指向当前分支，最新提交的第n个父提交，HEAD~1 等价于 HEAD^
Blog creation time:[2017-09-26 二 08:42]
* DONE [#D] theme:安装
1. 检查是否安装：dpkg -s git
2. 安装： sudo apt-get install git
3. 查看版本： git --version
Blog creation time:[2017-09-05 二 08:03]
* DONE [#D] theme:配置
1. 本地配置：　git config -e
   1. 配置文件路径：workspace/.git/config
   2. 作用域：该文件下的配置，只在该workspace／中有效
   3. 优先级：最高
2. 全局配置：　git config --global -e
   1. 配置文件路径：　~/.gitconfig　
   2. 作用域：该文件下的配置，对当前用户的所有的版本库均有效
   3. 优先级：高于系统配置，低于全局配置
   4. 用户标识配置：git config --global user.name "linjiajun"
   5. 用户邮件配置：git config --global user.email "ytulinjiajun@163"
   6. 开启颜色显示：git config --global color.ui true
   7. 说明：用户标识和用户邮件必须进行配置，因为git会使用到这两个信息来标识提交者身份
3. 系统配置：　git config --system -e
   1. 配置文件路径：　/etc/gitconfig
   2. 作用域：该文件下的配置，对所有用户的所有版本库均有效
   3. 优先级：最低
   4. 配置别名：git config --system alias.sta status
4. 读取配置：　git config --global user.name 回车
5. 更改配置：　git config --system alias.co checkout
6. 删除配置：　git config --unset core.bare
7. 备注： 建议将配置文件上传到github,用到时直接clone到指定路径即可！
* DONE [#D] theme:SSH
1. 生成SSH秘钥： ssh-keygen -t rsa -C "ytulinjiajun@163.com"
   1. -t  用于指定加密类型，常见的有RSA和DSA加密方式，默认是DSA;
   2. -C 作为批注
   3. 三次回车，按默认路径.ssh以及不需要密码安装即可
2. 在Github上添加密钥： Account Setting -> SSH Key -> Add SSH Key
   复制~/.ssh/ssh-ras 的内容到 key 区域
3. 验证SSH配置是否成功： ssh -T git@github.com
   Hi username! You've successfully authenticated ,but GitHub does not provide shell access
5. 创建一个本地版本库： git init
6. 关联远程库： git rmt git@github.com:ytulinjiajun/GitHub-Lin.git
6. 从github克隆一个版本库验证SSH配置是否成功：git clone git@github.com:ytulinjiajun/GitHub-Lin.git
Blog creation time:[2017-09-05 二 08:04]
* WAITTING [#D] theme:搭建git服务器
1. 基于标准的SSH搭建git服务器
   1. 服务器管理员在服务器上创建一个账号:git-server,专门用于git开发
   2. 客户端用户自己生成公钥和私钥: ssh-keygen -t rsa -C "ytulinjiajun@163.com" -f ~/.ssh/github
	  1. 在实际运用中,一个客户端用户可能需要使用多套秘钥对,如github使用一套,自己搭建的ssh-server需要一套
	  2. -f用于定制生成的秘钥的名字为一个有意义的名,如github.pub,而不是简单的id_ras.pub之类的
   3. 服务器管理员收集各个客户端用户的公钥,放在key/下面
   4. 将这些客户端的公钥/key/*依次添加进服务器/home/git-server/.ssh/authorized_keys文件内部
	  1. 方法一:直接在服务器上使用git-server账号操作: cat key/user1.pub >> ~/.ssh/authorized_keys
	  2. 方法二:远程操作: ssh-copy-id -i user1.pub@192.168.19.10 (效果同方法一样)
	  3. 备注: 这意味着任何人只要只要被服务器管理员执行过上面的免密码登录的操作后,这个人也可以让别人免密码,这意味着git-server是一个公开的服务器
   5. 测试4是否成功: ssh git-server@192.168.19.10,如果不需要密码即可登录表示配置成功
   6. 客户端新建配置文件:~/.ssh/config
	  1. 作用: 上面的2给出,客户端可以生成多套秘钥对,那么,执行登录指令时,计算机如何知道要使用哪个公钥呢?该配置主要就解决该问题
	  2. 新建~/.ssh/config,并写入配置
		 #+BEGIN_SRC 
		 host git-lin-server     # 相当于一个代号,登录时使用该代号即可加载该代号下面的配置
		   user git-server  # 远程服务器上专门用于git的用户
           hostname 192.168.19.10 # 远程服务的ip地址
           port 22  # 远程服务器ssh服务使用的端口号
           identityfile ~/.ssh/git-server-key  # git-lin使用哪个公钥
		 #+END_SRC
   7. ssh登录: ssh git-lin-server
   8. 执行git命令
	  1. git clone git-lin-github:ytulinjiajun/emacs.d.git
2. 基于Gitlite搭建git服务器
   1. 相关网址:
	  1. gitolite官方源代码:  http://github.com/sitaramc/gitolite
	  2. 官方学习文档(英文): http://gitolite.com/gitolite/
	  3. gitolite官方推荐资料(中文):https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-Gitolite
   2. Gitolite介绍:
	  1. gitolit是一款Perl语言开发的Git服务管理工具
	  2. gitolite的设计灵感来源于Gitosis,目前其功能已经超过Gitosis
	  3. gitolite提供两个功能: 身份认证; 权限控制
	  4. git本身不提供权限控制,当搭建完毕标准SSH服务器之后,而在团队开发中就会出现,任何人能对任何版本库执行任何操作,在团队开发中,这样的情况是非常糟糕的
	  5. git没有提供身份认证和权限控制的功能,而基于SSH的gitolite正是针对这一需求而设计,从某种意义上弥补了git的不足
	  6. gitolite在安装过程中,会指定一个gitolite管理员(提供该用户在客户端的秘钥),之后在git账号的家目录下的repositories/下生成一个名为gitolite-admin.git的版本库
	  7. gitolite-admin.git版本库只能被gitolite管理员所clone和push
	  8. gitolite管理员在客户端执行: git clone git@server:gitolite-admin.git,在本地得到一个名为gitolite-admin的仓库(和服务器上的gitolite-admin.git内容不同)
	  9. gitolite管理员clone到本地的gitolite-admin仓库里面有一个config/和keydir/,前者用于实现权限控制,后者用于实现身份认证
	  10. gitolite-admin/config/gitolite.conf,就是用于实现权限限制的配置文件,而gitolite-admin/keydir/下面则保存参与项目开发的程序员自己客户端上的公钥
	  11. gitolite针对config/gitolite.conf专门提供一套配置语法用于限制参与项目开发的所有程序员对repositories/下面的各个版本库中的分支,里程碑,文件,目录等的读,写权限
	  12. gitolite管理员将参与项目开发的所有程序员的公钥收集过来,重命令,然后放在gitolite-admin/keydir/下面,在该目录下面的程序员就能参与项目的开发中来
	  13. gitolite管理员在本地版本库gitolite-admin中执行: git push,将11,12中做的配置推送到服务器的gitolite-admin.git中,配置生效后,就能实现身份认证和权限限制的目的
	  14. 备注: 服务器git账号的密码只有gitolite管理员才知道, 在keydir/下面提交过公钥的程序员,无法直接使用ssh git@server的形式登录服务器的git账号来取得shell,但是却可以使用如push,pull等命令,至于reset或者git checkout等命令则需要依据config/gitolite.conf中的权限而定;不在keydir/下面提交过公钥的程序员,可以使用ssh git@server的形式登录服务器的git账号来取得shell,但是前提是,你得知道git账号的密码(只有gitolite管理员才有),这正是我们希望的结果
   3. Gitolite安装
      1. 建议参照源代码下面的README.markdown来进行操作 
	  2. 前提: 
         1. 事先安装了Git,且版本必须在1.6.6以上,且服务器要提供SSH服务
		 2. 事先安装了perl
		 3. 事先搭建好了SSH服务器,且该服务器的账号命名为git
	  3. 安装步骤: 由gitolite管理员来操作
	     1. 在服务器上创建一个用户账号: git
		 2. 在该账号的家目录下新建目录和文件: .ssh/authorized_keys
		 3. gitolite预备管理员在自己的客户端生成SSH秘钥对,然后使用sftp将生成的公钥gitolite-admin.pub 给 put 到服务器上
		 4. 登录到服务器(非远程),在家目录下面下载gitolite的源代码: git clone git@github.com:sitaramc/gitolite.git
		 5. 创建gitolite的安装路径: mkdir -p $HOME/bin
		 6. 安装: gitolite/install -to $HOME/bin
		 7. 指定gitolite的管理员: gitolite setup -pk $HOME/gitolite-admin.pub
		    1. 该操作之后 gitolite-admin.pub 这个公钥的所有者正式设置为 gitolite 的管理员
			2. 该操作会将 gitolite-admin.pub 添加至~/.ssh/authorized-keys中,这在标准SSH中意味着,该用户可以使用 ssh git@server 免密码直接远程登录服务器git账号
			3. 在这里,意味着: 第一,gitolite管理员再也无法使用ssh git@server 登录服务器的git账号取得shell了;
			4. 第二,gitolite是唯一一个可以使用git clone 将gitolite-admin.git 这个配置相关的版本库克隆到本地,修改,然后push上去使配置生效的人
			5. 当然了只有gitolite管理员才有gitolite-admin.git的读写和强制更新的权限是在gitolite-admin.git/config/gitolite.conf中配置的,也可以让其他人拥有此权限
		 8. 客户端登录配置: ~/.ssh/config
			1. 该配置在客户端完成,将ssh连接的参数配置在该文件中是一种非常好的习惯
			2. 该文件的identityfile特别重要,它指定了本次ssh连接使用哪个秘钥文件来进行认证,当.ssh/下面有多个*.pub存在时,该参数必须进行配置
			3. 配置说明:
			   #+BEGIN_SRC 
		       host gitolite-admin     # 相当于一个代号,登录时使用该代号即可加载该代号下面的配置
		       	 user git  # 远程服务器上专门用于git的用户账户
                 hostname 192.168.19.10 # 远程服务的ip地址
                 port 22  # 远程服务器ssh服务使用的端口号
                 identityfile ~/.ssh/gitolite-admin  # git-lin使用哪个公钥
		       #+END_SRC	 
		 9. 克隆gitolite-admin.git到本地: git clone git-server:gitolite-admin.git
		 10. 备注: 到此为止,gitolite已经在服务器上安装完毕,并且,还将服务器假设员的客户端账号设置为服务器上gitolite唯一的管理员
		 11. 备注2: 能克隆gitolite-admin.git并管理然后推送的人只有该管理员
   4. Gitolite管理员的那些事: (本地完成)
	  1. 配置文件管理
		 1. 默认配置文件: gitolite-admin/conf/gitolite.conf
		 2. 扩展配置文件:
			1. 在gitolite.conf中加入语句: include "*.conf"
			2. 在gitolite-admin/conf/中新建配置文件repo-stm32.conf
			3. 在gitolite-admin/conf/中新建配置文件repo-qt.conf
			4. 在repo-stm32.conf中编写stm32这个仓库的配置
			5. 在repo-qt.conf中编写qt这个仓库的配置
			6. 将配置push服务器使之生效
		 3. 编写配置的原则: 宏观的配置(如组,管理员等)应当在gitolite.conf中完成,而仓库的配置应当扩展出来,在自己的配置文件中配置
		 4. 约定:
			1. 注释: #
			2. 组标识:
			   1. 管理员组: @admin = admin1 admin2 
			   2. 开发成员组: @developers = user1  user2  @team1
			   3. 仓库组: @repo-groups1 = repo1 repo2  ---  repo  @repo-groups1
			   4. all组:  指代所有成员,或者所有仓库(用在3时)
			   5. 对路径授权: RW NAME/ = user1
			   6. 对正则表达式引用授权: RW refs/... = user
			3. 仓库标识: repo repo-stm32
			4. 扩展配置文件: include "foo/bar.conf" 或者 include "*.conf"
		 5. 配置文件模板
            #+BEGIN_SRC
            @who-can-create-shared-repo = gitolite-admin ljj-test
         
            repo shared-repo/CREATOR/[a-z]..*
                 C       =   @who-can-create-shared-repo
                 RW+CD   =   CREATOR

            repo personal-repo/CREATOR/[a-z]..*
	             C       =   @all 
	             RW+CD   = CREATOR
            #+END_SRC            
	  2. 权限控制
		 1. 管理员组:
			1. 管理员组语法: @admin = admin1 admin2
			2. 管理员组的必要性: 一个人管理gitolite的所有仓库,可能会忙不过来,此时,可以设置多个gitolite管理员
			3. @admin: gitolite系统内建标识,代表管理员组,加入管理员组的用户具有gitolite管理员的权限
			4. @all: gitolite系统内建标识,代表所有用户
		 2. 用户组:
			1. 用户组语法: @team1 = devlp1 devlp2 @team3
			2. 用户组的必要性: gitolite是版本控制系统的权限管理工具,因此实际情况很可能是这样的:
			   1. 版本控制系统中有很多个独立的仓库A,B,C,D...
			   2. 项目的参与者均通过上面3介绍的新增用户的方法加入到 gitolite 体系中,项目参与者的除了gitolite-admin这个管理员之外,还有很多人,按编号为1,2,3,4...
			   3. 成员1既在仓库A中有任务分工,又在仓库B中有任务分工
			   4. 成员2只在仓库B中有任务
			   5. 成员3既在仓库A中有任务分工,又在仓库C中有任务分工
			   6. 成员4比较厉害,在仓库B,C,D中都有任务分工
			   7. 当仓库的数量趋向无穷多,项目参与者的数量趋向无穷多,则,仓库,项目参与者之间的关系就会变得非常复杂,因此,gitolite权限控制语法中提供分组的概念
			   8. (仓库A : 成员1 成员3), (仓库B : 成员2 成员4), (仓库C : 成员3 成员4), (仓库D : 成员4)
			3. 备注: 组可以嵌套,表示@team3中的所有用户都加入到用户组@team1中去
			4. 用户组的意义: 给出了仓库可研发人员的对应,为仓库里面的分支,里程碑,目录,文件和研发人员的对应做出宏观的铺垫
         3. 通配符仓库模块格式: repo subdir-repo-name/.+$ <回车+缩进> 授权指令 
			1. repo: gitolite系统内建关键字,用来标识仓库
			2. subdir-repo-name/:位于服务器git账号家目录~/repositories/下的一个子目录
			3. .+$: 正则表达式,表示所有仓库
			4. <回车+缩进>: 配置文件格式所要求
			5. 授权指令: 稍后再叙
			6. 备注: 想要使用通配符仓库模块,需要在服务器git账户家目录下面的.gitolite.rc中添加语句: $GL_WILDREPOS = 1;
			7. 说明: 通配符仓库语法定义了一组仓库的规则,该语法使用正则表达式匹配一组仓库而不是特指某个具体的仓库
			8. 作用: 通配符仓库模块主要用于配置多个仓库的共性配置,个性配置则通过单个仓库配置模块的语法来实现
         4. 单个仓库模块格式: repo repo-name <回车+缩进> 授权指令
			1. repo: gitolite系统内建关键字,用来标识仓库
			2. repo-name: 服务器git账户家目录中(~/repositories/*.git)的一个具体的仓库,以服务器的~/repositories/作为根
			3. <回车+缩进>: 配置文件格式所要求
			4. 授权指令: 稍后再叙
			5. 9. 仓库的意义: 用户组的配置给出了仓库和研发人员对应关系,而仓库的配置给出了仓库和研发人员对应关系的具体实现
			6. 仓库是gitolite系统进行权限控制的基本对象
			7. 2. 注意: 在配置某个用户在该仓库中的权限之前,应当先配置该用户的用户组
		 5. 仓库的授权指令格式: <权限> [零个或多个正则表达式的匹配,或者引用] = <user> [<user> ...]
			1. 授权的两个阶段
			   1. 第一阶段: gl-auth-command检查
				  1. 读权限检查: 检查是否具有R, RW, RW+之一,如果有,则指定的用户对整个仓库(包含分支)均可读
				  2. 写权限检查: 检查是否具有RW,RW+,C之一,若果有,则通过第一阶段的写权限检查,准备第二阶段的写权限检查
				  3. 创建权限检查: 检查通配符仓库模块中,是否具有C权限,如果有,则指定用户可以 创建,读,写 和正则表达式匹配的仓库
			   2. 第二阶段: update钩子脚本检查
				  1. 写权限检查: 针对推送的操作的各分支, 精细的进行逐一检查是否具有写权限,若果有,则进行写授权
				  2. 基于路径的写授权也是发生在这个阶段
            2. 权限语法:
			   1. gitolite的权限语法的判定方式
			      1. 传统模式: 只采用 R,RW,RW+,- 关键字的授权,判定为传统模式的授权
			      2. 扩展模式: 在<权限>中出现: RWC, RW+C, RWD, RW+D, RWCD, RW+CD 之一的,则判定为扩展模式授权
				  3. 备注: 扩展模式能够使用更加精细的授权,因此,建议使用扩展模式的授权,下面的讲解也是基于扩展模式授权
		       2. 独立描述: C, D, M, R, W, +, - 
			      1. -: 不允许有任何权限
			      2. R: 决定允许允许有:访问,clone,fetch的权限
			      3. W: 决定是否允许有push的权限
			      4. C: 决定是否允许有创建ref的权限
			      5. D: 决定是否允许有删除ref的权限
			      6. M: 决定是否允许有拒绝包含了 merge commit 的 commit sequence的权限 (即只接受直线序列的提交,不接受合并提交.该功能很少使用)
			   3. 实际使用(见表): -, R, RW, RW+, RWC,RW+C, RWD, RW+D, RWCD, RW+CD
			3. [零个或多个,正则表达式的匹配,或者引用]
			   1. 你不可能对用户将要push的所有可能的branch和tag名写规则,唯一明智的方法就是使用正则表达式
			   2. 如果没有在授权指令中提供该选项,则相当于提供refs/.*作为引用参数
			   3. gitolite中使用到的正则表达式源字符
				  1. [asdf]: 依次拿[]中的字符, 去逐字符匹配目标文件,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
                     1. 示例: grep -n 'a[df]g' a.txt
	                 2. 解释: 在a.txt中,所有存在adg和afg的行都会被匹配,然后以带行号的形式,将这些行输出
				  2. ess*: 依次拿着 es,ess,esss ... 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	                 1. 重点: * 代表可以重复*前面的字符s任意次数(0次,1次...),上面的es是重复0次时匹配到的,注意,e不能被匹配
                     2. 示例: grep -n 'es*' a.txt
	                 3. 解释: 在a.txt中,所有存在e,es,ess,esss...的行都会被匹配,然后以带行号的形式,将这些行输出
				  3. e.e : 在目标文件中, 匹配 'e任何单个字符e',  若匹配成功,,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	                 1. 重点: 点 . 有且仅有单个字符,注意了,一定有一个字符,而且仅仅只有一个字符 edfe是不会匹配的
	                 2. 示例: grep -n 'o.o' a.txt
	                 3. 解释: 在a.txt中,所有存在o字符o的行都会被匹配,然后以带行号的形式,将这些行输出
                  4. ess+: 依次拿着 ess,esss ... 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	                 1. 重点: + 代表可以重复+前面的字符s大于等于1次(1次,2次...),上面的ess是重复1次时匹配到的,注意,es不能被匹配
				  5. $asdf: 拿着整个 'asdf' , 去和目标文件匹配, 若匹配成功,而恰好 asdf  又在串的结束位置(在grep中,结束位置定义为行尾),则满足该范式;
                     1. 示例: grep -n '$!' a.txt
	                 2. 解释: 在a.txt中,所有以!结尾的行都会被匹配,然后以带行号的形式,将这些行输出
			4. <user> [<user> ...]
	  3. 新增用户:
		 1. gitolite管理员从参与项目的开发者那些收集公钥,并将公钥按照ytulinjiajun@163.com.pub的方式统一命令
		 2. 将统一命名之后的公钥拷贝到keydir中
		 3. 将新增的公钥文件添加进版本库: git add keydir
		 4. 提交新增修改: git commit -m "add user: dev1 dev2 dev3"
		 5. 同步到服务器,完成用户添加: git push
		 6. 执行完毕push操作之后,将会发现在服务器的git账户的~/.ssh/authorized_keys中追加了新增用户的公钥
		 7. 这意味着该用户加入到研发团队中来,但是新增的普通用户仍然还没有读,写,克隆服务器上git/repositories/*.git的权限
		 8. 事情还没完,接下来需要配置用户对gitolite管理的所有版本库git/repositories/*.git的权限进行控制,见下面的权限控制
	  4. 删除用户:
		 1. 由gitolite-admin在gitolite-admin.git/keydir/中删除目标用户的公钥
		 2. 由gitolite-admin在gitolite-admin.git/conf/gitolite.conf中去除有关该用户的配置
	  5. 更换管理员
		 1. 更换管理员的本质,就是由老管理员自己在gitolite-admin.git/keydir/gitolite-admin.pub中的内容换成新管理员客户端的公钥
		 2. 操作: more new-gitolite-admin.pub >gitolite-admin.git/keydir/gitolite-admin.pub ,然后提交
	  6. 创建新版本库
		 1. 说明:
		    1. 在gitolite.git/keydir/的一个公钥,对应一个具体的加入git服务器的成员,而该公钥的名字就是gitolite系统承认的用户名
		    2. 配置代码里面的CREATOR关键字指代的正是gitolite.git/keydir/下公钥名字的集合
		 2. clone方式的创建:
			1. 管理员在gitolite.git/config/gitolite.conf中加入以下语句
			   #+BEGIN_SRC 
			   repo shared-repo/CREATOR/[a-z]..*
                    C       =   @can_create-repo
                    RW+CD   =   CREATOR
			   #+END_SRC
			   #+BEGIN_SRC 
			   repo personal-repo/CREATOR/[a-z]..*
                    C       =   @all
                    RW+CD   =   CREATOR
			   #+END_SRC
			2. 确保上面1中所述的事,必要的的话,先创建秘钥
			3. 创建版本库(服务器+本地): git clone git@server:shared-repo/CREATOR/test
			4. 至此,在服务器和本地就创建了一个名为test的版本库(CREATOR注意替换为相应的名)
			5. 备注: 在服务器上创建的版本库只能
         3. push方式的创建
			1. 初始化版本库: git init
			2. 注册远程信息: git remote add rmt-origin git@server:personal-repo/CREATOR/test
			3. 管理员在gitolite.git/config/gitolite.conf中加入以下语句
			   #+BEGIN_SRC 
			   repo shared-repo/CREATOR/[a-z]..*
                    C       =   @can_create-repo
                    RW+CD   =   CREATOR
			   #+END_SRC
			   #+BEGIN_SRC 
			   repo personal-repo/CREATOR/[a-z]..*
                    C       =   @all
                    RW+CD   =   CREATOR
			   #+END_SRC
  			4. 确保上面1中所述的事,必要的的话,先创建秘钥
			5. 创建版本库(服务器): git push origin master
			6. 特别注意: 在注册远程信息时,版本库test.git要写成test,即不可带后缀".git",否则会创建失败
	  7. 异地管理
		 1. 场景描述:
			1. 作为gitolite管理员,我希望在公司,在家,在办公路上等,的任意一台电脑上,都能克隆到gitolite-admin.git,以便随时进行管理
			2. 作为gitolite项目参与者,我希望在公司,在家,在办公路上等,的任意一台电脑上, 都能拥有该有的权限以便随时随地进行开发
		 2. 可行性分析:
			1. 无论是gitolite的管理员还是项目参与者,约定好了它们在gitolite-admin/keydir/下面都唯一只有一个公钥(虽然每个用户可以有多个公钥)
			2. gitolite-admin/keydir/目录下的公钥一旦push到服务器,就会将下面的公钥存储至服务器git账号家目录下~/.ssh/authorized_keys中去
			3. gitolite管理员的秘钥肯定在服务器上的~/.ssh/authorized_keys中;至于项目参与者,管理员曾经肯定和它们收集过公钥加入了gitolite-admin/keydir/下,并push到服务器,因此项目参与者的公钥必定也在在服务器上的~/.ssh/authorized_keys中
			4. 原理: 客户端登录服务器时,使用~/.ssh/config下面identityfile指定的公钥文件中的内容去和服务器上~/.ssh/authorized_keys中的内容匹配,如果找到了匹配,则认证成功
			5. 结论: gitolite的认证是秘钥认证,和用户账号及密码无关, 无论是管理员还是项目参与者,只要备份好公钥和私钥,将其拷贝到其他电脑账户下的~/.ssh/下面,然后在~/.ssh/config中添加一条配置,该电脑即可登录服务器
		 3. 操作: 
			1. 将公司自己办公用的笔记本,家目录下面的公钥和私钥的内容做个备份,复制到自己的U盘里面
			2. 回到家后,将U盘里面的公钥和私钥拷贝到家里电脑家目录下的~/.ssh/中
			3. 配置家里那台电脑的~/.ssh/config(尤其注意identityfile的值一定是公钥名),服务器ip之类的,配置完毕之后就可以愉快的在家里登录上服务器了
| user   | access | clone | fetch | push  | create repo | create a ref | rewinds a ref | delete a ref |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| no-set | N      | N     | N     | N     | N           | N            | N             | N            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| -      | Y      | Y     | Y     | N     | N           | N            | N             | N            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| R      | @Y     | @Y    | @Y    | N     | N           | N            | N             | N            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW     | Y      | Y     | Y     | {@W}Y | N           | N            | N             | N            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW+    | Y      | Y     | Y     | Y     | N           | N            | {@+}Y         | N            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| C      | N      | N     | N     | N     | @Y          | N            | N             | N            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RWC    | Y      | Y     | Y     | Y     | N           | {@C}Y        | N             | N            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW+C   | Y      | Y     | Y     | Y     | N           | Y            | Y             | N            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RWD    | Y      | Y     | Y     | Y     | N           | N            | N             | {@D}Y        |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW+D   | Y      | Y     | Y     | Y     | N           | N            | Y             | Y            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RWCD   | Y      | Y     | Y     | Y     | N           | Y            | N             | Y            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW+CD  | Y      | Y     | Y     | Y     | N           | Y            | Y             | Y            |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| M      |        |       |       |       |             |              |               |              |
|--------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
备注: {@权限字符}	表示在这一列是yes或no由该权限字符说了算; - 表示去除用户的写权限,即让用户拥有只读权限(如何让用户连读的权限都木有呢?? 答案是:删除用户)
Blog creation time:[2017-10-09 一 15:13]
* DONE [#D] theme:创建版本库
1. git init: 其结果是在工作区中生成版本库：.git/
2. git rev-parse --git-dir: 该操作可以在工作区的任何子目录下执行，其结果是显示该工作区的版本库的路径
3. git rev-parse --show-toplevel: 该操作可以在工作区的任何子目录下执行，其结果是显示该版本控制系统的根路径
4. git rev_parse --show-prefix: 该操作可以在工作区的任何子目录下执行，其结果是显示相对于该版本控制系统的根路径的相对目录
5. git rev_parse --show-cdup: 该操作可以在工作区的任何子目录下执行，其结果是显示当前目录回退到版本控制系统根的深度
* DONE [#D] theme:查看状态
	- State "DONE"       from "WAITTING"   [2017-10-05 四 21:45]
1. 常规：git status
2. 精简(推荐)：git status -sb
   1. 红色： 表示该文件需要执行add操作
   2. 绿色： 表示该文件已经执行过add操作，现在可以执行commit操作
   3. 空： 表示工作区干净
   4. ??：表示该文件是一个未被追踪的文件(只可能是红色)
   5. A： 表示该文件还从未进行过commit(只可能是绿色)
   6. M: 表该文件发生了修改(红色和绿色均可能)
   7. D: 表示该文件被删除(红色和绿色均可能)
3. 原则: 使用该操作,只要有输出, 那就表明工作区,暂存区,最新提交三者之间文件内容不一致
Blog creation time:[2017-10-05 四 21:41]
* DONE [#D] theme:里程碑
1. 显示里程碑: git tag -n<num> 
2. 创建里程碑: git tag -m "注释" tag-name commit-ID
3. 删除本地里程碑: git tag -d tag-name  
   1. 一旦删除,不易恢复,慎用!
   2. 在删除的时候会在输出中显示该里程碑对应的提交ID,一旦发现删除错误,赶紧补救还来得及: git tag tag-name 5b7901d
4. 删除远程里程碑: git push origin :mytag2
5. 重命名里程碑: (不要随意更改)
   1. 里程碑是对历史提交的一个标记,不应该随意进行变动,尤其是之前的里程碑一旦被别人同步,如果修改了里程碑,那么别人的版本库是不会自动更新的
   2. git没有提供里程碑重命名的机制,如果对里程碑的名字不满意的话,可以删除里程碑,再重新用新的名字创建里程碑
6. 查看tag的ID: git rev-parse tag-name
7. 显示版本号: git descrbie
   1. 前提: 执行过创建里程碑的操作
   2. 作用: 将最新的提交显示为一个容易记忆的版本号,而不是ID
   3. 版本号格式: (tag-name)-(num)-(ID)
   4. 该命令会去选取离最新提交最近的里程碑的tag-name作为基础版本号,后面加一个数字(标识该提交是里程碑后面的第几个提交),最后就是最新提交的哈希值ID
   5. 该操作的输出可以作为软件版本号,这个功能非常有用,因为这样可以将发布的软件包版本和版本库中的代码对应到一起,当发现软件包中有bug时,查看该软件包的版本,直接在代码中就能找到对应代码并进行修复,然后提交
   6. tag-name的命令: linux-kernel_1.0
8. linux里程碑的命名规则:
   1. 里程碑都以v开头: v2.6.36
   2. 以-rc<num>为后缀的是先于正式版发布的预发布版: v2.6.36-rc1
   3. 去掉-rc<num>后就是正式版: v2.6.36
   4. 正式版之后的升级以及修正版本通过最后一位数字来体现: v2.6.36.1
9. 说明: 里程碑是个非常好的功能,建议经常使用它
Blog creation time:[2017-10-07 六 21:13]
* DONE [#D] theme:浏览
1. 浏览文件内容
   1. 浏览工作区中的文件内容：　less a.txt
   2. 浏览暂存区中的文件内容：　git diff
   3. 浏览对象库中的文件内容：　git cat-file blob commit-ID:a.txt
2. 浏览目录树
   1. 浏览工作区中的目录树： ls -al
   2. 浏览暂存区中的目录树： git ls-files -s
	  第三列是暂存区编号不是文件大小
   3. 浏览指定提交的目录树： git ls-tree -lrt commit-ID
	  1. 第一列100644是文件的属性：rw-r--r--
	  2. 第二列标识文件还是目录：blob，文件，tree,目录
	  3. 第三列标识该文件在当前分支中的40为SHA1哈希值ID
	  4. 第四列是文件大小(Byte)
	  5. 第五列是文件名
   4. 浏览远程所有ref对应的哈希值: git ls-remote origin
3. 浏览对象库
   1. ID的类型: commit-ID,tree-ID,blob-ID
   2. ID的本质: 指针
   3. 对象库本质: 一个双向链表,其节点是提交, git lg 可以查看到这些节点的ID
   4. 版本库的构成: HEAD指针,分支指针头,对象库
   5. "提交节点"的成分: 前驱指针域(id),数据域(tree,author),后继指针域(parent)
   6. 数据域中的tree: tree是一个tree-ID,因此,是一个指针,这个tree指向一个目录树索引,该目录树索引和暂存区中的目录树索引经常发生交互,它们均指向add进对象库中真正的文件 
   7. 获取指定ID的类型：git cat-file -t ID, 其返回值是: commit,tree,blob
   8. 解引用commit-ID: git cat-file -p commit-ID
	  1. 使用 git lg 可以查看到对象库的所有commit-ID
	  2. 其效果与 git cat-file commit commit-ID一致
	  3. 解引用的结果: 得到"提交节点"的成分,包括tree-ID
   9. 解引用tree-ID: git cat-file -p tree-ID
	  1. 其效果与 git ls-tree -lrt commit-ID 一样
	  2. 解引用的结果: 可以查看对象库中commit-ID下数据域tree-ID指向的目录树下面的所有blob-ID
   10. 解引用blob-ID: git cat-file -p blob-ID
	   1. 其效果与 git cat-file blob commit-ID:<tab补全>一致
	   2. 解引用的结果: 可以查看tree-ID下面所有blob-ID指向的文件的真正内容
Blog creation time:[2017-10-05 四 21:46]
* DONE [#D] theme:添加至暂存区
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:28]
1. 添加单个文件： git add a.txt
2. 添加所有文件： git add -A
3. 所有文件中，添加已经被跟踪过的文件： git add -u
4. 选择性添加: git add -i (当文件特别多,且需要仔细考虑添加哪些文件时,该操作以交互的方式,给出一个更直观的操作)
Blog creation time:[2017-10-06 五 10:26]
* DONE [#D] theme:撤销出暂存区
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:30]
1. 撤销单个文件的add： git reset -- a.txt
2. 撤销所有文件的add: git reset -- .
3. 该操作是add的逆,所以，对暂存区和对象库无任何影响
Blog creation time:[2017-10-06 五 10:28]
* DONE [#D] theme: commit
1. 命令： git commit -m "Initialized"
2. 重用提交说明: git commit -C commit-ID: 将commit-ID的提交说明作为本地次提交的提交说明
3. 底层: 事实上执行add操作的时候,工作区中的文件就已经加入到了对象库中,暂存区的目录树索引和对象库tree-ID下的目录树索引同时指向对象库中真实的文件
4. 提交的本质: commit操作执行之后立即产生一个commit-ID节点,使用暂存区下面的目录树索引为该commit-ID节点下面的数据域tree-ID指向的目录树索引赋值
5. 提交到哪里: 提交永远都是HEAD的“跟屁虫”，只会盯着HEAD,HEAD在哪个分支，该提交就挂接在这个分支最新提交的后面成为最新提交
6. 结果:该命令执行之后，暂存区和最新提交就有了相同的目录树索引，均指向版本库的.git/object/下的文件,因此,使用git diff HEAD比价暂存区和最新提交时返回无差异
Blog creation time:[2017-10-06 五 10:32]
* DONE [#D] theme:撤销提交
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:49]
1. 命令： git reset --soft HEAD^
2. 说明: 该操作是commit的逆，对暂存区和工作区文件的内容没有任何影响，主要用于想要重新书写提交说明时使用
Blog creation time:[2017-10-06 五 10:46]
* DONE [#D] theme:修补提交
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:51]
1. 修补最新提交的说明： git commit --amend -m "重新注释"
2. 该命令本质上相当这两条命令的组合：
   1. git reset --soft HEAD^
   2. git commit -e -F .git/COMMIT_EDITMSG(保存了上次的提交日志)  
3. 修补任意提交的说明: 
Blog creation time:[2017-10-06 五 10:50]
* DONE [#D] theme:diff详解(生成补丁文件)
   - State "DONE"       from "WAITTING"   [2017-10-01 日 18:14]
1. 基础框架
   1. 范式：diff OPTIONS... TAG1  TAG2
   2. 情况一，TAG1与TAG2均是文件
	  1. 这种情况是最为简单的，diff命令比较的是这两个文件的内容
	  2. 特殊标识‘-’代表标准输入，diff -u - b.txt <a.txt >c.txt 等价于 diff -u a.txt b.txt >c.txt
	  3. 这种情况按照下面的三种方式：正常模式，上下文模式，合并模式进行操作
   3. 情况二，TAG1与TAG2之间有其一是文件，比如TAG1是文件，其一是目录，比如TAG2是目录
	  1. 命令： diff -u a.txt dir/
	  2. 该命令会且仅会将a.txt同dir/a.txt相比较
	  3. diff -u - dir/ <a.txt在该情况下是不合法的，即，不支持标准输入
   4. 情况三，TAG1与TAG2均是目录
      1. 比较的基本原则是：同一目录深度处， 有名字相同的文件，进行比较，有名字相同的目录，则进入该目录，同时双方的目录深度各自加一，然后进行文件遍历
	  2. 目录的比较一般都需要加上-r参数
2. 研究对象
   1. 原始文件： a.txt
	  应该杜绝文章中的错别子。
	  
	  但是无论使用
	  *全拼，双拼
	  *还是五笔
	  
	  是人就有可能犯错,软件更是如此。
	  
	  犯了错，就要扣工资！
	  
	  改正的成本可能会很高。
   2. 目标文件: b.txt
      应该杜绝文章中的错别字。
	  
	  但是无论使用
	  *全拼，双拼
	  *还是五笔
	  
	  是人就有可能犯错,软件更是如此。
	  
	  改正的成本可能会很高。
	  
	  但是“只要眼球足够多，所有的bug都好捉“，
	  这就是开源的哲学之一
   3. 备注： 在 diff [选项] [FILE1] [FILE2] 中，定义FILE1为原始文件，FILE2为目标文件
3. 正常模式(normal diff)
   1. 命令：diff a.txt b.txt >c.txt
   2. 差异输出：
	  1c1
	  < 应该杜绝文章中的错别子。
	  ---
	  > 应该杜绝文章中的错别字。
	  9,10d8
	  < 犯了错，就要扣工资！
	  < 
	  11a10,12
	  > 
	  > 但是“只要眼球足够多，所有的bug都好捉“，
	  > 这就是开源的哲学之一
   3. 要点
	  1. 正常模式的基本原则：需要对原始文件做出怎样的操作之后，才能用与目标文件匹配
	  2. 正常模式是diff命令的默认模式
	  3. 默认模式的输出结果比较符合计算机的思维方式，但是，不太直观，所以，提供了contex-mode和unified-mode，使得人们能更好的理解
	  4. git diff使用的是unified-mode,即，合并模式
   4. 语法分析：(正常模式语法分析的重要原则是：需要对原始文件做出怎样的操作“a d c”之后，才能用与目标文件匹配)
	  1. [数字1，数字2] + 字母 + [数字3,数字4]格式分析： 如上结果中的 9,10d8
		 1. 字母: a=add ; c=change ; d=delete
		 2. [数字1，数字2]：  9,10 表示原始文件中的第[9,10]行，注意是闭区间，包含第9行和第10行
		 3. [数字3，数字4]：  8 表示目标文件中的第8行
		 4. 9,10d8的含义：对原始文件的第9行到第10行，做出删除的操作后，可以同目标文件的第8行匹配
	  2. 以<开始的行： 标识这是属于原始文件专有的行
	  3. 以>开始的行： 标识这是属于目标文件专有的行
	  4. ---： 原始文件和目标文件的分隔符
4. 上下文模式(context diff)
   1. 命令： diff -c a.txt b.txt >c.txt
   2. 差异输出：
	  *** a.txt	2017-09-30 16:11:33.961502252 +0800
      --- b.txt	2017-09-30 16:12:27.869501287 +0800
      ***************
      *** 1,4 ****
      ! 应该杜绝文章中的错别子。
	  
      但是无论使用
      *全拼，双拼
      --- 1,4 ----
      ! 应该杜绝文章中的错别字。
	  
      但是无论使用
	  *全拼，双拼
	  ***************
	  *** 6,11 ****
	  
      是人就有可能犯错,软件更是如此。
	  
      - 犯了错，就要扣工资！
      - 
      改正的成本可能会很高。
      --- 6,12 ----
	  
      是人就有可能犯错,软件更是如此。
	  
      改正的成本可能会很高。
      + 
      + 但是“只要眼球足够多，所有的bug都好捉“，
      + 这就是开源的哲学之一
   3. 要点
	  1. 在输出的差异文件中，无论+ - !出现在原始文件块还是目标文件块中，其含义均是表示需要对原始文件做出操作才能与目标文件相匹配
	  2. 命令中的 -c 正是标识上下文模式的关键选项 
   4. 语法分析(上下文模式语法分析的重要原则是：需要对原始文件做出怎样的操作“+ - ！”之后，才能与目标文件匹配)
	  1. 原始文件标识： 第一行以3个***开头，标识的是原始文件，该行记录了原始文件的文件名和时间戳
	  2. 目标文件标识： 第二行以3个---开头，标识的是目标文件，该行记录了目标文件的文件名和时间戳
	  3. 分隔符： 第三行15个***************是分隔符
	  4. 原始文件，差异定位语句： *** 1,4 ****
		 1. ***： 原始文件，差异定位语句开始标志
		 2. 1,4： 本差异小节的内容，位于原始文件的第[1,4]行
		 3. ****： 差异定位语句结束标志
	  5. 目标文件，差异定位语句： --- 1,4 ----
		 1. ---： 目标文件，差异定位语句开始标志
		 2. 1,4： 本差异小节的内容，位于目标文件的第[1,4]行
		 3. ----： 差异定位语句结束标志
	  6. 两个差异定位语句之间的内容称为一个差异小节
      7. 差异小节操作符：
	     1. + 表示，原始文件需要增加这一行，才能同目标文件匹配
	     2. - 表示，原始文件需要删除这一行，才能同目标文件匹配
	     3. ! 表示，原始文件需要经过修改，才能同目标文件匹配
5. 合并模式(unified diff)
   1. 命令： diff -u a.txt b.txt >c.txt
   2. 差异输出：
	  --- a.txt	2017-09-29 14:55:40.091131063 +0800
 	  +++ b.txt	2017-09-29 15:00:00.075126407 +0800
 	  @@ -1,4 +1,4 @@
 	  -应该杜绝文章中的错别子。
 	  +应该杜绝文章中的错别字。
	  
 	  但是无论使用
 	  *全拼，双拼
 	  @@ -6,6 +6,7 @@
	  
 	  是人就有可能犯错,软件更是如此。
	  
 	  -犯了错，就要扣工资！
	  - 
   	  改正的成本可能会很高。
	  + 
   	  +但是“只要眼球足够多，所有的bug都好捉“，
   	  +这就是开源的哲学之一
   3. 要点
	  1. 合并模式是比较重要的模式，因为git集成的diff使用的就是该模式，因此务必掌握
      2. 命令中的 -u 正是标识合并模式的关键选项
   4. 语法分析
	  1. 原始文件标识： 第一行以3个---开头，标识的是原始文件，该行记录了原始文件的文件名和时间戳 
      2. 目标文件标识： 第二行以3个+++开始，标识的是目标文件，该行记录了目标文件的文件名和时间戳
      3. 原始文件专有行：以-号开始的行，表示只出现在原始文件中的行，从打补丁命令patch的角度看，表示该行需要删除
      4. 目标文件专有行：以+号开始的行，表示只出现在目标文件中的行，从打补丁命令patch的角度看，表示该行需要增加
      5. 公共行：以空格开始的行，表示在原始问价和目标文件中都出现的行
      6. 差异定位语句： @@ -6,6 +6,7 @@
	     1. @@： 差异定位语句开始标志
	     2. -6，6： 本差异小节的内容，位于原始文件中的位置是：从第6行开始,之后的6行
	     3. +6,7： 本差异小节的内容，位于目标文件中的位置是：从第6行开始，之后的7行
	     4. @@： 差异定位语句的结束标志
      7. 差异小节：两个差异定位语句之间的内容构成一个差异小节
6. 文件同目录之间的比较
   1. 命令： diff a.txt dir/
   2. a.txt会且仅会同dir/a.txt进行比较，即，即使dir/sub-dir/a.txt存在，且使用-r,比较也无法进行
7. 目录同目录之间的比较(最重要，项目管理常用！！！)
   1. 目录与目录比较的要领： 
      1. 当原始目录和目标目录在各自递归的(指定-r选项)过程中,在相同深度的地方,出现名字相同的文件时，才会对这个名字相同的文件做比较
	  2. 当原始目录和目标目录在各自递归的(指定-r选项)过程中,在相同深度的地方，出现名字相同的目录时，才会各自进入这个名字相同的目录，并goto 1
	  3. 一旦在相同深度的地方，找到名字相同的文件时，比较的原则就演变为文件同文件之间的比较,将上面所述的3中模式！
   2. 目录比较时，4个重要的选项
      1. -u: unified,采用合并模式生成补丁文件
	  2. -q: 只列举出两个文件有无差异，而不进行比较
	  3. -r: 递归比较目录中的子目录，其本质要点是：原始目录和目标目录，在相同深度的位置，是否有相同名字(文件，目录)
	  4. -N: 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录，文件A 若使用-N参数，则diff会将文件A 与一个空白的文件比较；该选项能确保补丁文件能正确地处理已经创建或删除文件的情况
   3. 生成补丁文件的最终命令： diff -u -Nr old-package/ new-package/ 
Blog creation time:[2017-10-01 日 08:48]
* DONE [#D] theme:比较差异
1. 暂存区与工作区
   1. 比较暂存区与工作区的差异：git diff (原始对象是暂存区)
   2. 比较暂存区与工作区指定文件的差异：git diff -- a.txt
2. 提交与暂存区
   1. 比较最新提交与暂存区：git diff HEAD --cached
   2. 比较最新提交与暂存区中指定文件：git diff HEAD --cached -- a.txt
   3. 比较指定提交与暂存区: git diff commit-ID --cached 
   4. 比较指定提交与暂存区中指定文件: git diff commit-ID --cached -- a.txt
   5. 比较里程碑A与暂存区: git diff A --cached
   6. 比较里程碑A与暂存区中指定文件: git diff A --cached -- a.txt
3. 提交与工作区
   1. 比较最新提交与工作区: git diff HEAD
   2. 比较最新提交与工作区中指定文件: git diff HEAD -- a.txt
   3. 比较指定提交与工作区：git diff commit-ID
   4. 比较指定提交与工作区中指定文件：git diff commit-ID -- a.txt
   5. 比较里程碑A与工作区的差异: git diff A
   6. 比较里程碑A与工作区中,指定文件的差异: git diff A -- a.txt
4. 提交与提交
   1. 比较指定提交与指定提交: git diff commit1-ID commit2-ID 
   2. 比较指定提交与指定提交中指定文件:git diff commit1-ID commit2-ID -- a.txt
   3. 比较里程碑A与里程碑B: git diff A B
   4. 比较里程碑A与里程碑B中指定文件: git diff A B -- a.txt
Blog creation time:[2017-10-06 五 10:52]
* DONE [#D] theme:patch详解(打补丁)
   - State "DONE"       from "WAITTING"   [2017-10-01 日 18:13]
1. 当patch的对象是一个文件
   1. 打补丁命令，版本升级：patch old-version.txt <diff.patch  
   2. 去除补丁命令，版本回退：patch -R  new-version.txt <diff.patch  
   3. 原则：
      1. 明确自己是想进行版本升级，还是版本回退，如果是进行版本升级，则使用打补丁命令，如果是进行版本回退，则进行去除补丁命令
	  2. 明确哪个是老版本，哪个是新版本，其方法是less diff.patch，补丁头处，以---开始的是原始文件，即老版本；以+++开始的是目标文件，即新版本
	  3. 在明确想要版本升级还是版本回退，以及分清楚哪个是老版本，哪个是新版本之后，严格根据上面的1,2条所示的命令，即可达到目的
2. 当patch的对象是一个目录(工程中常用，非常重要)
   1. 背景：
	  1. 发起了一个工程项目，并完成了它的初始版本，工程的源代码放置在linux/这个目录树下面
	  2. 该版本只包含了最基础的配置但可满足用户的基本需求，初始版本的大小为3GB，版本号为linux1.0
	  3. 将这个3GB大小的软件上传到ftp服务器，供广大用户免费下载使用
	  4. 随后，该工程项目逐步添加一些功能,对linux1.0进行了一些优化，删减了一些源代码，修复了一些bug，编译之后形成linux2.0,该版本的大小为4.8GB
	  5. 使用命令diff -uNr linux1.0/ linux2.0/,制作出补丁文件linux2.0.patch,该补丁的大小为36MB
	  6. 将这个36MB大小的linux2.0.patch上传到ftp服务器，供广大用户免费下载进行升级
	  7. 广大用户下载了一个36MB大小的补丁文件，然后按照下面介绍的打补丁的方法，对第一次下载的3GB大小的linux1.0执行打补丁操作
	  8. 使用命令patch -p0 <linux2.0.patch，这样就将linux1.0的源代码升级成linux2.0的源代码
	  9. 广大用户完成升级之后，发现linux2.0不稳定，很不爽，因此对刚升级的linux2.0的源代码进行去除补丁操作，会退回linux1.0的源代码
	  10. 使用命令patch -p0 -R <linux2.0.patch,这样，又穿梭回linux1.0了，棒棒哒
	  11. 广大用户中有一部分人很喜欢linux2.0中新增的一些功能，因此，找到了导致linux2.0不稳定的那个bug，并报告给该项目的发起者让它进行紧急修复该bug
	  12. 该项目的发起者收到该bug后，发现是linux/arch/alpha/boot/目录下出了问题，项目发起者立即火速修补了代码的bug，重新编译之后形成linux2.0.1,该版本大小为4.9GB
	  13. 使用命令diff -uNr linux2.0/arch/alpha/boot/ linux2.0.1/arch/alpha/boot/ >linux2.0.1.patch,该补丁的大小为7MB
	  14. 广大用户又下载了这个7MB大小的补丁文件，然后按照下面介绍的打补丁的方法，对本地的linux2.0执行打补丁操作
	  15. 使用命令patch -p1 <linux2.0.1
	  16. 现在广大可以愉快的使用linux2.0.1而不会出现不稳定的问题了
	  17. 该方案的优点
		  1. 用户只需下载一次3GB的linux1.0,之后就只用下载36M的linux2.0.patch而不用下载4.8GB的linux2.0就能获得linux2.0的源代码
		  2. 工程项目的发起者只用上传36M的linux2.0.1.patch，而不用每fix一个bug就上传几个G的工程源代码
		  3. 用户拿着补丁文件能随意的在linux1.0和linux2.0之间穿梭
   2. 打补丁命令，版本升级： patch -p(num) <diff.patch    
   3. 去除补丁命令，版本回退：patch -R -p(num) <diff.patch
   4. 操作步骤：
	  1. 明确自己是想进行版本升级，还是版本回退，如果是进行版本升级，则使用打补丁命令，如果是进行版本回退，则进行去除补丁命令
	  2. 明确哪个是老版本，哪个是新版本，其方法是less diff.patch，补丁头处，以---开始的是原始文件，即老版本；以+++开始的是目标文件，即新版本 
      3. 确定-p(num)中的num,一般为0，或者1，或者2，其意义需要参照补丁文件的补丁头，假设diff.patch的补丁头如下所示：
         --- linux-2.6.25_android/arch/alpha/boot/misc.c 2010-05-06 01:56:42.565397700 -0700
         +++ linux-2.6.29_android/arch/alpha/boot/misc.c 2010-05-06 00:51:06.000000000 -0700

         -p0：代表忽略0层目录，即从光标所在的当前目录中查找linux-2.6.25_android/arch/alpha/boot/misc.c，然后进行patch操作
		 -p1：代表忽略1层目录，即从光标所在的当前目录中查找arch/alpha/boot/misc.c，然后进行patch操作
		 -p2：代表忽略2层目录，即从光标所在的当前目录中查找alpha/boot/misc.c，然后进行patch操作
      4. 明确光标应该定位到哪个目录   
         --- linux-2.6.25_android/arch/alpha/boot/misc.c 2010-05-06 01:56:42.565397700 -0700
         +++ linux-2.6.29_android/arch/alpha/boot/misc.c 2010-05-06 00:51:06.000000000 -0700

         patch -p0 <diff.patch 由于忽略0层目录，所以应当进入到linux-2.6.25_android/目录下时，才能执行该操作
         patch -p1 <diff.patch 由于忽略1层目录，所以应当进入到linux-2.6.25_android/arch/目录下时，才能执行该操作
         patch -p2 <diff.patch 由于忽略2层目录，所以应当进入到linux-2.6.29_android/arch/alpha/目录下时，才能执行该操作
   5. 思考：为什么要有-p(num)参数
	  1. 一个工程可以看作一个目录树，很有可能我们只对该目录树下面第n层深度目录处的某个目录进行了修改，因此只用对该子目录打补丁就行，此时就可忽略掉前面的n层目录，直接对该子目录打补丁，即-p(num)使得我们可以对目录树下的任意子目录打补丁而不是对整个工程进行打补丁
	  2. 一个工程可能是合作的产物，所以会有很多人对它进行打补丁操作，由于不同的人对文件或目录的命名方式会不同，所以导致自己本地的该目录名可能与服务器上的该目录名不同步，此时如果你还是使用对整个工程进行打补丁的方法，那么由于目录名不同步，必然无法递归进入到这个原本已经经过修改的存在差异的目录中去，出现漏打补丁的现象，所以，在多人合作的项目中，务必使用-p(num)参数，过滤掉不是你负责的那些目录，直接定位到你负责的目录下去打补丁，这样既能能做到互不干扰，又能避免漏打补丁
   6. 工程合作项目打补丁的思考
	  1. 一个工程项目一般由多个成员共同开发，由于任务分工必然会存在交叉工作，因此如果在交叉代码处出现了bug，而双方都去制作了补丁来修补这个bug的话,很可能因为文件或目录的命名不一致的问题导致第二个打补丁的人在这些命名不一致的目录处出现漏打补丁的现象
	  2. 建议，最好尽量做到分工明确，交叉的地方，由双方协作共同生成补丁，然后打一次补丁即可
   7. patch操作的4个重要参数
	  1. -p(num): num是一个数字，表示，使用patch命令给 package-dir/ 打补丁时，忽略掉前num个目录层“/”，一般用-p0,-p1
	  2. -R: 给新对象打补丁，将其还原为旧对象
	  3. -E: 如果发现空文件，就删除它
Blog creation time:[2017-10-01 日 09:46]
* WAITTING [#D] theme:补丁交互
1. 通常push和pull是常见的交互模式,但是,在一些大型项目中,通常会使用补丁交互,如,自己不具有linux内核的push权限,但是可以补丁代码通过邮件发送给linus让他来修补bug
2. 使用补丁交互可以提高参与度,任何人都可以参与项目的开发,因为只要将提交转换为补丁,会发送邮件即可
3. 批量创建补丁: git formate-patch -s HEAD~3 HEAD
Blog creation time:[2017-10-24 二 15:30]
* DONE [#D] theme:检出
1. 从暂存区检出至工作区
   1. 回滚单个文件： git checkout -- a.txt
   2. 回滚所有文件： git checkout .
   3. 说明：该操作会用暂存区的指定文件或者全部文件替换工作区的文件
   4. 结果： 工作区中的文件内容，同暂存区中目录树索引下的文件内容保持一致
   5. 后果： 这意味着会丢失工作区中未添加到暂存区中的修改 
2. 从对象库检出至暂存区
   1. 回滚单个文件： 
	  1. 命令： git reset commit-ID a.txt
	  2. 说明： 回滚单个文件不会丢失对象库中的最新提交到commit-ID这一段之间的commit，因为只回滚个别文件，说明用户有意要和对象库中的commit-ID存在差异，所以，回滚后的a.txt和暂存区的其他文件构成另一个commit
	  3. 结果： 该操作用对象库commit-ID下的a.txt替换掉暂存区中的a.txt
	  4. 后果： 会丢失在执行该操作之前，使用命令git add a.txt到暂存区的修改
	  5. 备注： 该操作同3-1中回滚单个文件最大的区别在于，该操作不会更改工作区文件的内容 
   2. 回滚所有文件： 
	  1. 命令： git reset --mixed commit-ID
	  2. 说明： 该操作让对象库中的commit-ID提交同暂存区保持一致,但是,对象库比commit-ID还新的提交有可能存在，鉴于保持一致的理念，对象库只能将最新版本重置到commit-ID
	  3. 结果： 该操作用对象库commit-ID，替换整个暂存区，即，暂存区中的索引与commit-ID中tree指针下的索引，完全一致
	  4. 后果： 丢失最近一次add到暂存区的修改以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
3. 从对象库检出至(暂存区+工作区): 操纵HEAD指针指向哪个提交
   1. 回滚单个文件： git checkout commit-ID -- a.txt
   2. 回滚所有文件： git checkout commit-ID -- .
   3. 回滚所有文件(常用): git checkout tag-name -- .
   4. 说明：
	  1. 如果commit-ID不是最新提交(HEAD->master)而是之前的提交，那么，在回滚后，暂存区会与对象库的最新提交不一致而不干净，要求再次提交
	  2. 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换暂存区下（当前存在的文件）的索引，用索引下的全部文件替换工作区下（对应）的文件
	  3. 注意：2中用小括号括起来的两个关键字非常重要：在进行替换时，如果暂存区或者工作区中新增加了对象库提交中没有的文件，此时的替换只会替换对象库，工作区，暂存区中公共的文件，差异的文件内容以及文件状态不变
      4. 回滚操作与重置(git reset --hard commit-ID)的区别在于,回滚操作只用commit-ID中文件覆盖暂存区以及工作区中的同名文件,暂存区和工作区特有的,commit-ID中没有的这些文件保持原样,而重置则是使得工作区暂存区中有且仅有commit-ID中的文件(版本库干净)
   5. 结果：
      1. 工作区中的文件内容，暂存区目录树索引下的文件的内容，同commit-ID节点中tree元素指向的目录树索引下的blob文件内容一致
      2. 那些只在工作区下或者暂存区下才有的而commit-ID这个提交中没有的文件，依旧保持其该有的状态以及内容
   6. 后果：工作区中未add的改动以及暂存区中未commit的改动，如果发生改动的文件在commit-ID这个提交下存在，那么，这些改动会被commit-ID下的文件内容覆盖
Blog creation time:[2017-10-06 五 10:58]
* DONE [#D] theme:重置
1. 软重置
   1. 基础命令: git reset --soft commit-ID
   2. 常用命令: git reset --soft tag-name (里程碑真的很好用,建议多用!)
   3. “软”的意义：只改变对象库中HEAD->master对commit-ID的指向，不改变暂存区和工作区文件的内容
   4. 功能昵称: 多步悔棋,穿梭过去
   5. 使用场合： 开发过程中,对某一个特性功能进行一系列测试,修补,再测试之后终于得到了正确的版本,但是,却在版本库中遗留了多个提交,这些提交都是中间过程提交,遗留在版本库中意义不大,此时,可以使用该重置命令,将版本库中的最新提交重置到特性功能测试之前的那个提交上,然后再将这个最终得到的正确版本提交到版本库,这样就更改剔除了那些个不必要的版本,还可以重设提交说明,这样做使得版本库更加简洁
2. 混合重置
   1. 命令： git reset --mixed commit-ID(默认缺省--mixed)
   2. “混合”的意义： 不改变工作区文件的内容，但是会改变暂存区的内容
   3. 说明： 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换整个暂存区，即，暂存区中的索引与commit-ID中tree指针下的索引，完全一致
   4. 结果： 暂存区与commit-ID的文件内容一致，工作区的文件的内容还是重置前的内容，但是状态变为待add的状态
   5. 后果：丢失最近一次add到暂存区的修改以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
3. 强制重置: 调整分支指针头(如master,develop)指向哪个提交
   1. 命令： git reset --hard commit-ID
   2. “强制”的意义： 工作区和暂存区的文件内容都会被commit-ID下的文件内容覆盖
   3. 结果：工作区，暂存区，与commit-ID的文件内容一致,同时,当前分支的指针头会指向commit-ID
   4. 后果： 会丢失工作区中尚未add的改动以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
   5. 备注： 可以使用git reset --hard HEAD来彻底恢复到上一次提交的那个干净的版本
4. 挽救错误的重置
   1. 重置最显著的特点就是，最新的commit-ID到待重置的commit-ID这一段之间的commit会丢失，因此，重置行为是版本库中最危险的行为，因为会丢失提交
   2. 使用reflog来挽救错误的重置
	  1. 从日志中获取最新ID：git reflog show | head -5
	  2. 找到eb3bcab master@{0}: reset: moving to HEAD^所在行
	  3. 由于该日志是将最新的改变放在前面，因此，这一行的下面一行就是重置前的commit，假设为master@{2}所在行
	  4. 再次重置：git reset --hard master@{2}
Blog creation time:[2017-10-06 五 11:12]
* DONE [#D] theme:删除
	- State "DONE"       from "WAITTING"   [2017-10-06 五 15:41]
1. 删除工作区尚未追踪的文件 
   1. 删除尚未追踪的指定文件: git clean -fd a.txt
   2. 删除尚未追踪的所有文件: git clean -fd
   3. 说明: 尚未追踪的文件,其删除操作与暂存区和对象库没有任何联系
2. 删除暂存区中的文件
   1. 删除指定文件： git rm -rf --cached a.txt
   2. 删除所有文件:  git rm -rf --cached *
   3. 说明： 该操作只删除暂存区中的文件,工作区中的文件依旧是删除操作之前的最新内容
3. 删除 工作区+暂存区 中的文件
   1. 删除指定文件: git rm -rf a.txt
   2. 删除所有文件: git rm -rf *
   3. 结果: 该操作使得在工作区和暂存区的指定文件都会被删除,因此,暂存区与对象库的最新提交不一致,会要求提交新版本
4. 删除对象库提交
   1. 命令: git reset --soft commit-ID
   2. 说明: 对象库中的提交是版本库这个大链表上的一些个节点,删除某个节点破坏了版本控制系统连续记录的原则,因此,该操作会将最新提交到该commit-ID之间的提交都删除掉
Blog creation time:[2017-10-06 五 14:17]
* DONE [#D] theme:恢复删除
	- State "DONE"       from "WAITTING"   [2017-10-06 五 15:41]
1. 命令: git checkout HEAD~1 -- a.txt
2. 说明: 如果a.txt使用git rm -rf a.txt删除了工作区和暂存区中的a.txt并进行了提交,如果想要找回a.txt,可以在HEAD^这个提交下面找回 
Blog creation time:[2017-10-06 五 15:27]
* DONE [#D] theme:更改文件名字
	- State "DONE"       from "WAITTING"   [2017-10-06 五 22:25]
1. 命令: git mv a.txt aa.txt
2. 说明: 该操作可以同时更改工作区和暂存区中的中的a.txt的名字为aa.txt
Blog creation time:[2017-10-06 五 15:42]
* DONE [#D] theme:保存工作进度
   - State "DONE"       from "WAITTING"   [2017-10-06 五 22:25]
1. 保存进度的原理:
   1. 调用进度保存指令git stash save "注释",触发下面的步骤
   2. 从当前分支的最新提交节点处,开创建一个特殊(stash分支)的新分支,这个最新的提交节点就是特殊新分支的起点,让进度指针头refs/stash指向这个起点,如此便创建了一个进度分支
   3. 将暂存区提交到进度分支上,保存好暂存区的进度
   4. 将该进度分支的起点节点与进度分支的暂存区进度进行合并,生成工作区进度
2. 保存进度: git stash save "gMrM--a.txt gM--b.txt gM--subdir/dir/c.txt"
   1. 该命令使用了git reset --hard HEAD,工作区,暂存区,最新提交,三者内容一致,版本库干净
   2. 当存在未追踪的文件时,进度保存操作无法进行,需要先追踪才可以
   3. 该命令执行之后,会产生一条进度保存记录,使用git stash list查看
   4. 我的注释格式: g:green ; r:red 用于描述大写字母的颜色
   5. 进度保存的实质: 将进度保存在引用refs/stash所指向的提交中
   6. 进度保存操作会将,暂存区提交后产生的stash-commit-ID,与进度保存前,对象库的最新进行合并,产生一个stash-commit-ID,refs/stash指向会指向它
   7. 可以使用-k参数,在保存进度后不会将暂存区重置
3. 查看进度保存记录: git stash list
   1. 该命令显示之前保存过的众多进度
   2. 恢复进度时,可以查看该记录来选择恢复那个进度
4. 恢复进度: git stash pop --index stash@{n}
   1. --index: 指明恢复进度时,除了恢复工作区之外,还会尝试恢复暂存区.如果不指定该参数则只恢复工作区的文件内容
   2. 恢复后删除进度保存列表中的记录
5. 运用进度: git stash apply --index stash@{n}
   1. --index: 指明恢复进度时,除了恢复工作区之外,还会尝试恢复暂存区.如果不指定该参数则只恢复工作区的文件内容
   2. 只是运用该进度而不会将其从进度保存列表中删除
   3. 该操作和恢复进度的功能是一样的,区别就是恢复后不删除,该命令的优点在于可以多次运用该进度
6. 删除进度: git stash drop stash@{n}
7. 删除所有进度: git stash clear
8. 查看进度保存日志: git log --graph --pretty=raw refs/stash -2
Blog creation time:[2017-10-06 五 14:17]
* DONE [#D] theme:文件追溯
	- State "DONE"       from "WAITTING"   [2017-10-09 一 10:08]
1. 追溯a.txt中的所有行: git blame a.txt
2. 追溯a.txt中第2行开始的3行内容: git blame -L 2,+3 a.txt
3. 要求: blame的对象必须一个文件,且该文件必须commit到对象库中
4. 作用: 以行为单位,显示该行最早在哪个commit中引入,以及由谁在什么时候引入
5. 使用场合: 在开发过程中发现bug时,定位到具体的源文件之后,可以使用该命令追溯该bug是由谁在什么时候的哪个commit中引入
6. 使用前提: 该操作是建立在bug已经定位到源代码的基础之上,然后才能定位到bug行的提交者,进行打板子教育
Blog creation time:[2017-10-09 一 09:29]
* DONE [#D] theme:忽略文件
	- State "DONE"       from "WAITTING"   [2017-10-07 六 22:23]
1. 共享式忽略
   1. 一个文件的文件名如果被添加进workspace/.gitignore,则该文件不会被版本库管理
   2. 注意: 如果一个文件在被添加进.gitignore之前就已经add进了版本控制系统,则忽略无效
   3. 共享的含义: 当其他人clone,pull该版本库时,这个忽略文件仍然有效
2. 独享式忽略
   1. 局部独享: .git/info/exclude,只针对某一个版本库
   2. 全局独享: ~/.gitconfig,下面的core.excludesfile指定的文件,针对该用户相关的所有版本库
   3. 设置全局独享忽略: git config --global core.excludesfile /home/ljj/.gitconfig
   4. 独享的含义: 当其他人clone,pull该版本库时,该忽略文件不会被传递给该用户
Blog creation time:[2017-10-07 六 22:01]
* DONE [#D] theme:文件归档
	- State "DONE"       from "WAITTING"   [2017-10-07 六 22:45]
1. 基于提交创建归档: git archive -o lastest.zip commit-ID
2. 基于提交中的指定目录创建归档: git archive -o lastest.tar commit-ID -- subdir1 subdir2
3. 基于里程碑linux_1.0创建归档,并将归档中的所有文件都添加kernal/n前缀: git archive --format=tar --prefix=kernel/ linux_1.0 | gzip > linux_1.0-3-g5ea60ef.tar.gz
Blog creation time:[2017-10-07 六 22:27]
* DONE [#D] theme:gitg
	- State "DONE"       from "WAITTING"   [2017-10-08 日 08:53]
1. gitg 是使用GTK+图形库实现的一个git版本库浏览器软件
2. gitg不仅可以实现gitk的全部功能(浏览历史和文件),还能帮助执行提交
3. 安装gitg: sudo aptitude install gitg
Blog creation time:[2017-10-07 六 22:52]
* WAITTING [#D] theme:底层命令
1. git 的命令中,一部分是使用ID作为参数,一部分则使用范围作为参数,下面的两个底层命令中rev-parse就是负责ID相关,rev-list负责范围相关
2. git rev-parse
   1. 该底层命令功能非常丰富和杂乱,很多的git脚本或者工具都会用到这条命令
   2. 显示分支: git rev-parse --symbolic --branches
   3. 显示所有里程碑: git rev-parse --symbolic --tags
   4. 显示定义的所有引用: git rev-parse --symbolic --glob=refs/*
   5. 显示HEAD对应的的commit-ID: git rev-parse HEAD
   6. 显示tag对应的tag-commit-ID: git rev-parse linux_1.0
   7. 显示tag对应的tag-commit-ID指向的提交的父提交的commit-ID: git rev-parse linux_1.0~2
   8. 显示tag对应的tag-commit-ID指向的提交下的tree-ID: git rev-parse linux_1.0:
   9. 显示tag对应的tag-commit-ID指向的提交下的tree-ID下子目录的tree-ID或者文件的blob-ID
   10. 同时显示多个对应的SHA1哈希值: git rev-parse master refs/heads/master
   11. 给定一个简写的SHA1哈希值,给出完整的SHA1哈希值: git rev-parse 5ea60ef
3. git rev-list
   1. 显示,所有与版本A关联的历史提交: git rev-list --oneline A
   2. 显示,所有与版本A关联的历史提交(A自身除外): git rev-list --oneline A^@
   3. 显示,A自身: git rev-list --oneline A^!
   4. 显示,所有与版本A关联 and 与版本B关联的历史提交: git rev-list --oneline A B
   5. 显示,所有与版本A关联的历史提交中排除掉与D,F关联的历史提交之后剩下的提交: git rev-list --oneline B ^D ^F
   6. 显示,所有B,C的历史提交 中,排除B,C的交集之后,剩余的所有历史提交: git rev-list --oneline B...C
Blog creation time:[2017-10-08 日 08:54]
* WAITTING [#D] theme:开发模型
** 金字塔式协同模型
1. linux社区就是使用的金字塔协同模型
2. 特点:
   1. 只有核心开发者develop才具备向master推送的权限,任何开发者都具备读master的权限(这意味着需要搭建一个只读的Git服务器)
** Android式多版本协同模型(重点)	
1. 单人工作模型
2. 团队工作模型
2-1 金字塔版本控制模型：发布Linux
--最终版本库；  ---> Fedora 25发行版
--有一个权威贡献者的版本库（linus）
--有几个核心贡献者的版本库（Kernel、Samba、KDE、Gnome）
--有若干开发者（37人）的版本库（10个人负责开发Kernel、6个人负责开发Samba、
12个人负责开发KDE、9个人负责开发Gnome）

特点：
--每个贡献者的版本库都是平等的；
--用于版本控制的模型；

2-2金字塔版开发模型：开发Samba
2-2-1服务器端，主分支master;   ---> Samba 3.4.1
1.不允许在master分支上干活，所以该分支不属于某一个成员，应当找一个牛来管理
（合并分支）master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有slaver分支对它有写权限，即，只有slaver分支才能向它合并代码；
3.所有分支对它都有读权限；
4.这个分支是非常稳定的，可以作为产品的。

2-2-2服务器端，开发分支（slaver）
1.这个开发分支用于干活，但是该分支也不属于某一个成员，应当找一个牛来管理（合并分支）
master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有核心开发分支（A、B、C、D）才对它有写权限，即，只有核心开发者才能向
slaver分支合并代码；
3.只有核心开发分支（A、B、C、D）才对它有读权限
4.这个分支是不稳定的，找来管理它的牛在充分测试后时不时把它作为版本合并
到master分支上即可。

2-2-3服务器端，核心开发者的开发分支（A、B、C、D）
1.这四个分支的所有者可以在属于自己的分支上干活，并且时不时向slaver分支合并代码
并且，接受
2.向slaver合并代码，

--有若干开发者（37人）的开发分支（其中10个人只能）

特点：
-每个开发者的版本库都是平等的；
--用于版本开发的模型；

个人也必须有一个master分支和slaver分支，其中，slaver分支用于自己干活，master
分支主要用于三个方面：向上级分支推送代码，接受别人代码的合并，接受自己在slaver分支
上的代码的合并
Blog creation time:[2017-09-05 二 08:07]
* DONE [#D] theme:反转提交
1. 命令: git revert HEAD
2. 作用: 将 HEAD^ 重新提交一次,成为最新的提交
3. 用途: 在不具备reset权限的前提下,该命令可以将一个错误提交的前面那个提交回滚至工作区,暂存区,以及最新提交处
Blog creation time:[2017-10-20 五 10:34]
* DONE [#D] theme:丢弃历史提交
	- State "DONE"       from "WAITTING"   [2017-10-25 三 15:54]
1. 当一件事变得完美时，历史可能成为一种负担，或许我们需要一个精简的版本，或许我们需要丢弃一些很久很久以前的历史，此时，就需要本节介绍的命令
2. 操作步骤：
   1. 选择根: 从历史提交中选择一个提交作为根,以这个提交创建根之后,根不再有父提交
   2. 创建根: echo "root-commit from tree of tag A" | git commit-tree A^{tree}, 会生成一个根提交,比如ID为 59fd58e
   3. 将 A 之后的所有提交变基到根上: git rebase --onto 59fd58e A master
Blog creation time:[2017-10-25 三 15:02]
* WAITTING [#D] theme: clone
1. 必要性: 再健壮的版本库设计,也抵挡不了存储介质的崩溃,因此,不要将鸡蛋装在同一个篮子里
2. 
Blog creation time:[2017-10-09 一 14:50]
* WAITTING [#D] theme: blog
3. 日志
   1. 在执行commit命令之后，就会在log中产生一条提交信息
   2. git log --stat
      commit ccbbaeae9b9444ad21caa6d8216f7b8a4d22f59a (HEAD -> master, origin/master)
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Mon Oct 2 10:34:04 2017 +0800
	  
	  -----
	  
	  blogs-git-active.org       | 227 +++------------------------------------
	  blogs-linux-active.org     | 262 ++++++++++++++++++++++++++++++++++++++++++---
	  blogs-linux-arch-part2.org |   2 +-
	  3 files changed, 264 insertions(+), 227 deletions(-)
	  
	  commit e3f5fc176a40c3d889aecb4e051bfaec4101c4d5
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Sat Sep 30 20:55:18 2017 +0800
	  
	  -----
	  
      blogs-emacs-active.org | 144 +++++++++---------
      blogs-git-active.org   | 395 ++++++++++++++++++++++++++++++++++++++++++++++---
	  2 files changed, 449 insertions(+), 90 deletions(-) 
   3. git log --pretty=fuller
	  commit ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD)
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 20:17:49 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 20:17:49 2017 +0800
	  
	  -----
	  
	  commit 8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 19:35:59 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 19:35:59 2017 +0800
   4. git log --pretty=online
      ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD) -----
	  8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345 -----
	  228e998f2b5b1936fbd90f2441bf610d689caee1 -----
	  58c9b9ed50b28b4e47302dbc4248686d9e835f27 evil-mode
	  f9f1d307bb08c94f78e0714998759c1515e0f027 -----
	  34b45e97083e705d98900aaa8ec9692bc27e89eb -----
	  21c290a0cdebe3bebaff7148a5f69e4399a5ecc3 -----
	  915cd2a2564a5b8a942301de31b993d0f6ec2636 -----
   5. git log -l --pretty=raw
Blog creation time:[2017-10-06 五 14:21]
* WAITTING [#D] theme: cherry-pick
1. 作用: 将指定的一个提交挑拣出来,与HEAD指向的提交合并,生成一个新的提交,并让HEAD指向它
2. 运用:
   1. 剔除分支develop中某次糟糕的提交(tag为v1.4):
	  1. 切换到该分支: git co develop
	  2. 检出v1.4的父提交v1.3: git co v1.3 (备注: 该操作会开辟一只游离分支并切换到该游离分支去)
	  3. 挑拣出v1.5合并到HEAD处: git cherry-pick v1.5 (此处可能会有冲突,手动解决一下再提交即可)
	  4. 挑拣出v1.6或合到HEAD处: git cherry-pick v1.6
	  5. "分支叛变",将develop指针头,指向挑拣合并后的v1.6的那个提交(即抛弃含有v1.4的那段坏的提交)
	     1. 切换到develop分支: git co develop
		 2. 让git reset --hard 423af2f
   2. 将分支develop中连续的两个提交v1.3和v1.4合并为一个提交v1.34
	  1. 切换到该分支: git co develop
	  2. 检出v1.4对应的提交: git co v1.4  (备注: 该操作会开辟一只游离分支并切换到该游离分支去)
	  3. 回滚到v1.3的父提交为合并做准备: git reset --soft v1.3~1  (备注:必须是--soft不能是--hard,因为--soft不会覆盖暂存区里面v1.4的版本, 由于v1.4是在v1.3的基础之上而来的,下一步提交暂存区v1.4的版本就相当于合并了v1.3和v1.4)
	  4. 提交暂存区里面的v1.4版本到v1.2的后面并重用v1.3的提交说明: git ci -C v1.3
	  5. 挑拣v1.5,合并在HEAD处: git cherry-pick v1.5
	  6. "分支叛变",将develop指针头,指向挑拣合并后的v1.5的那个提交
	     1. 切换到develop分支: git co develop
		 2. 让git reset --hard 423af2f
3. 备注: 本质上挑拣操作只挑拣一个commit-ID嫁接在HEAD处,那想要挑拣一段范围内的提交嫁接在任意提交处,该怎么办呢? 那就得使用强大的变基操作
Blog creation time:[2017-10-09 一 10:30]
* WAITTING [#D] theme:rebase
1. 命令: git rebase --onto taget-commit <start> <end>
   1. 范围: (start end],即该集合左开右闭
   2. 缺省命令: git rebase --onto target-commit <start> ,表示对(start HEAD]之间的提交执行变基操作
   3. 继续变基: git rebase --continue, 变基过程中会遇到冲突,解决冲突后可以执行该命令继续执行变基操作
   4. 略过变基: git rebase --skip
   5. 终止变基: git rebase --abort, 终止变基操作,切换到变基前的分支
2. 作用: 将指定范围内的一组提交<start>...<end>挑拣出,"嫁接"--onto指定的提交 target-commit 后面
3. 原理:
   1. 切换到<end>: 有两种情况
	  1. <end>是一个分支指针头(develop): 变基结束后就完成任务
	  2. <end>是一个提交: 工作在"游离状态",等变基结束之后,还需要将分支指针头(如:develop)"叛变"到该"游离分支"上来
   2. 将指定范围内的一组提交挑拣出来,存放在一个临时文件中
   3. 将当前分之强制重置到target-commit: git reset --hard target-commit
   4. 将临时文件中的提交,按照顺序,重新逐一的向target-commit后面提交
   5. 如果遇到临时文件中的某提交已经在target-commit所在的分支中,则跳过该提交: git rebase --skip
   6. 如果在提交过程中遇到冲突,则变基操作会暂停,用户解决冲突之后,执行git rebase --continue继续变基
   7. 执行git rebase --abort可以终止变基操作,切换到变基前的分支上
4. 运用:
   1. 剔除分支develop中某次糟糕的提交(tag为v1.4):
	  1. 切换到该分支: git co develop
	  2. 变基: git rebase --onto v1.3 v1.5~1 v1.7
	  3. 检查当前分支是develop还是"游离分支": git br -v,如果是develop,检查HEAD是否指向master,如果是,则完成任务
	  4. 如果是"游离分支",则执行"分支叛变"操作,将develop指向游离分支: git co develop; git reset --hard 23ef46,完成任务
   2. 将分支develop中连续的两个提交v1.3和v1.4合并为一个提交v1.34
	  1. 切换到该分支: git co develop
	  2. 检出v1.4对应的提交: git co v1.4  (备注: 该操作会开辟一只游离分支并切换到该游离分支去)
	  3. 回滚到v1.3的父提交为合并做准备: git reset --soft v1.3~1  (备注:必须是--soft不能是--hard,因为--soft不会覆盖暂存区里面v1.4的版本, 由于v1.4是在v1.3的基础之上而来的,下一步提交暂存区v1.4的版本就相当于合并了v1.3和v1.4)
	  4. 提交暂存区里面的v1.4版本到v1.2的后面并重用v1.3的提交说明: git ci -C v1.3
	  5. 为刚提交的版本打上里程碑: git tag -m "version 1.34" v1.34
	  6. 变基: git rebase --onto v1.34 v1.5~1 master
	  7. 检查当前分支是develop还是"游离分支": git br -v,如果是develop,检查HEAD是否指向master,如果是,则完成任务
	  8. 如果是"游离分支",则执行"分支叛变"操作,将develop指向游离分支: git co develop; git reset --hard 23ef46,完成任务
Blog creation time:[2017-10-25 三 13:12]
* WAITTING [#D] theme: remote
1. 注册前的推送git push git@server:shared-repo/CREATOR/test.git master
2. 注册远程信息: git remote add origin git@server:shared-repo/CREATOR/test.git
3. 修改注册路径: git remote set-url origin git@server:personal-repo/CREATOR/hello.git
4. 修改注册名:   git remote rename origin new-name
5. 删除注册: git remote rm origin
6. 查看远程注册信息: git remote -v
7. 注册后的推送: git push origin master
8. 查看远程注册文件: git config -e
9. 查看远程版本库的分支信息: git ls-remote origin
10. 
Blog creation time:[2017-10-20 五 10:48]
* WAITTING [#D] theme: clone
1. 克隆裸版本库(无工作区): git clone --mirror git-ljj:repo/ljj/test.git
2. 克隆对等版本库(有工作区): git clone  git-ljj:repo/ljj/test.git
Blog creation time:[2017-10-24 二 13:29]
* WAITTING [#D] theme: push
1. 命令: git push origin develop
2. 命令: git push origin master
3. 背景:
   1. 在2人共享同一个版本库时,如果这两个人都有RW的权限,则两个人都能push自己的修改到该版本库
   2. 假设在起初时,用户1和用户2同时从服务器clone到该版本库
   3. 后来,成员1做了一些修改,并生成了一个提交,push到了服务器上,push成功!
   4. 后来,成员2也做了一些修改,也生成了一个提交,也想push到服务器上,显然,push失败!
   5. 原因: 成员1在push时的环境满足快进式push的要求,成员2在push时的环境不满足快进式push
   6. 成员2如何能成功push?
	  1. 方法一: 强制push,该方法极其粗鲁,极有可能会覆盖到成员1之前的提交中的内容,导致逻辑错乱,排版错乱等,不推荐
	  2. 方法二: 先fetch到本地,与自己的版本进行merge,然后再push上去
4. 快进式推送: (fast-forward push)
   1. 命令: git push origin master
   2. 命令简化: 在使用git push --set-upstream origin master进行设置origin和master的对应之后,可以简化为git push即可
   3. 概念: 远程版本库相应分支的最新提交是本地版本库最新提交的祖先提交(即,本地的最新提交总是建立在远程最新提交的基础之上)
   4. 备注: 建议推送一律使用快进式推送,因为这是比较友好的
5. 非快进式推送:
   1. 概念: 远程版本库的最新提交在本地版本库的提交历史中从未出现过,则此时向远程进行推送就称为非快进式推送
   2. 强制推送命令: git push -f origin master
   3. 强制推送的后果:
      1. 用户1本地版本库: [1---2---3---4]--->a--->b--->c--->d
	  2. 用户2本地版本库: [1---2---3---4]--->5
	  3. 远程共享版本库:  [1---2---3---4]--->a--->b--->c--->d
	  4. 用户2在本地执行: git push -f origin master
	  5. 远程版本库结果:  [1---2---3---4]--->5
	  6. 结论: 用户2强制push时,由于版本库的基本要求(工作区--暂存区--对象库--远程共享版本库 保持一致性)决定了用户1先前push的提交a-->b--->c--->d会被强制丢失,这绝对是灾难
   4. 将本地的最新提交推送至远程使之成为远程上的最新提交,同时,为了保证与该用户本地版本库的一致性,会剔除掉
   5. 备注: 强制极其粗鲁,极有可能会覆盖到成员1之前的提交中的内容,导致逻辑错乱,排版错乱等,通常都应当在远程禁止掉强制推送的权限
6. 正确的推送: 快进式推送
7. "快进式推送"这个基本原则引发的问题:
   1. push完毕后才发现刚刚push的有错别字,已经push到远程了,覆水难收!!!
	  1. 首先想到的自然是,修补命令git commit --amend ,然后再重新push到服务器
	  2. 但是,修补命令会抹除本地的最新提交,重新push时,你会发现服务器上的那个有错别字的最新版本在本地没有,即构成了非快进式推送的条件
	  3. 此时,就要进行风险评估了,如果你能肯定此时整个公司就只有你一个人在加班,不会有其他人fetch或者clone你的错误提交,那么一个不在友好的方法就是使用-f进行强制推送
	  4. 但是,
	  5. 显然,此时使用修补命令就显得不合适了,
   2. 初始状时,用户1和用户2本地的最新提交一致,用户1发生了一次push,此时用户2再进行push时,对于用户2而言,构成了非快进式推送的条件,用户2将无法push
	  1. 该问题是团队合作过程中的家常便饭,处理的方法基本就是使用pull或者fetch
Blog creation time:[2017-10-20 五 13:18]
* WAITTING [#D] theme: fetch
1. 拉取所有分支: git fetch origin: 将远程refs/head/目录下的所有分支拉取到本地的refs/remotes/origin/下面
2. 拉取指定分支: git fetch origin feature-led: 将远程refs/head/feature-led分支拉取到本地的refs/remotes/origin下面
3. 访问之前fetch的分支: 从远程fetch到本地的分支,要用"远程主机/分支名"的形式读取,如: git merge --no-ff -m "---" origin/feature-led
4. 备注: fetch 远程分支到本地和fetch 远程提交到本地是有差别的,拉取分支时,是将整个分支全部拉取下来
Blog creation time:[2017-10-23 一 09:54]
* DONE [#D] theme: merge
   - State "DONE"       from "WAITTING"   [2017-10-24 二 13:26]
1. 命令: git merge --no-ff commit-ID
2. 常用命令: git merge --no-ff -m branch
3. 合并操作将commit-ID(引用:分支,里程碑)对应的提交同当前分支的最新提交进行合并,产生一个位于当前分支上的新的提交
4. 默认情况下,合并的结果会自动提交到当前分支,但是,如果使用--no-commit选项,则合并后的结果会放入暂存区,用户检查,修改之后手动提交
5. 合并操作的结果: 成功自动合并, 逻辑冲突, 真正的冲突, 树冲突
6. 合并引发冲突:
   1. 根本原因: 不同的提交同时修改了同一个文件的相同区域的内容(修改不同的文件,修改同一文件的不同区域均不会引发合并冲突)
   2. 冲突的结果: 造成合并中断,冲突的文件被标识
   3. 解决方案: 用户需要对标识冲突的文件进行解决冲突的操作,然后更新到暂存区,再提交,最终完成合并操作
   4. 成功自动合并: (不一定意味着正确)
	  1. 用户1和用户2负责不同的文件,各不涉及对方的文件,此时,一定能合并成功,且结果一定正确
	  2. 用户1和用户2存在交集文件 hello.c, 用户1修改和用户2同时修改了hello.c内容的不同区域,此时,一定能合并成功,且结果一定正确
	  3. 用户1和用户2存在交集文件 hello.h, 用户1重命名了hello.h为hi.h,用户2在hello.c中依旧include "hello.h",此时,一定能合并成功,但是结果一定错误
   5. 逻辑冲突: 能合并成功但是是错误的
	  1. 团队工作中,如果你之前已经合并了你的代码到其他分支,那么,请不要随意重命名你的文件,因为别人可能会用到你的文件,会引发逻辑错误而且合并还能成功
	  2. 已经合并且提交后的代码,如果发生修改,应当随时写修改文档,以便那些使用到你的模块的人知道你做了那些改动,从而能进行修改
	  3. 逻辑冲突是最难发现的冲突,因为它能合并成功,一个好的项目应该引入单元测试以及自动化集成,以便在编译时进行自动化测试,捕捉这些潜在的bug
   6. 真正的冲突: (一定不能合并成功)
	  1. 两个用户修改了同一个文件的同一区域,在合并时会遇到冲突导致合并中断,此时git会标识出冲突的区域,然后把决定权交给用户
	  2. <<<<<<< 和 ======= 之间的内容是当前分支所更改的内容
	  3. ======= 和 >>>>>>> 之间的内容是待合并的分支所更改的内容
	  4. 手动解决冲突: 将冲突标识符之间的内容(从<<<<<<<开始,到>>>>>>>之间的部分)替换为合适的内容,然后去掉冲突标识符,在进行add以及commit即可
   7. 树冲突:
	  1. 用户1将文件doc/hello.h改名为hi.h,用户2也将doc/hello.h改名为api.h,当两个用户的提交进行合并时,git无法做出裁决,会产生冲突
	  2. 手动解决冲突:
		 1. user使用merge命令进行合并,发生了树冲突,此时,hi.h已经存在于user的工作区和暂存区中
		 2. user1和user2应该协商一下到底用什么名字
		 3. 如果决定使用user2的名字,则使用命令: git rm hi.h
		 4. 删除掉原始的doc/hello.h: git rm doc/hello.h
		 5. 添加文件: git add api.h
		 6. 提交冲突解决的版本: git ci -m "fix-rename conflict" 
Blog creation time:[2017-10-23 一 09:55]
* WAITTING [#D] theme: pull (fetch+merge)
1. 介绍: 相当于 fetch 和 merge 的结合体
2. 作用: 该命令之后,本地的最新提交就会远程的最新提交合并,在本地生成合并后的提交,如此,本地的这个合并后的提交便有了两个父提交,其中一个是远程的最新提交,这样便解除了非快进式推送的条件,在次推送时,就是非快进式推送了
3. 使用场合:
   1. 团队协作过程中,对于成员来说,几乎每次push都会被非快进式推送受限(不然就不叫团队协作了!), 因此pull命令在团队协作过程中几乎是最常用的命令之一了
   2. 本地用户想要向远程服务器push之前,直接先使用pull命令将远程的最新提交给fetch到本地并进行merge,这应当将其作为一种习惯
4. 剖析 git pull
   1. 从 git remote -v所示的远程版本库中,获取master分支上的最新提交,到本地版本库: refs/remotes/REMOTE-NAME/master的引用下
   2. 将本地分支master指向的最新提交同远程fetch下来的最新提交:refs/remotes/REMOTE-NAME/master,进行合并,然后在本地生成新的提交
5. 冲突:
   1. pull命令不可能总会那么一帆风顺,其根本原因在于,pull命令会将远程的最新提交和本地的最新提交进行合并,只要有合并的地方,就无可避免的会发生冲突
Blog creation time:[2017-10-23 一 08:58]
* WAITTING [#D] theme: refs
1. 查看所有引用:  git show-ref
2. 查看指定引用: git show-ref master
3. 以refs/heads/开头的是分支指针头
4. 以refs/remotes/开头的是远程版本库分支在本地的映射
5. 以refs/tags/开头的是里程碑
6. HEAD: 
7. master: .git/refs/heads/master
8. stash
9. tag-name: .git/refs/tags/tag-name 
Blog creation time:[2017-10-07 六 21:16]
* WAITTING [#D] theme: branches
1. 分支的基础知识
   1. 分支的祖先起点：主分支上的第一次提交，是任意分支的祖先起点
   2. 分支的起点： 每个分支，都有一个分支起点。任意分支上的任意提交，都可以是某指定分支的起点
   3. 分支指针头： 每个新建的分支，都有一个分支指针,分支指针头总是指向该分支的最新提交
   4. 空分支：只有分支起点和分支指针构成的分支称为一个空分支
   5. 分支指针头的生命周期：分支指针在该分支被创建的时候产生，在该分支合并到其起点所在的分支时，分支指针死亡
   6. 分支的构成：任意一个新创建的分支，由：分支起点 + 分支提交结点 + 指向分支最新提交的分支指针头 构成
   7. HEAD，总是指向当前分支的分支指针头
   8. 提交： 提交永远都是HEAD的“跟屁虫”，只会盯着HEAD,HEAD在哪个分支，该提交就挂接在这个分支最新提交的后面成为最新提交
   9. 切换到新分支的本质是让HEAD指向新分支的分支指针头
2. 本地分支:
   1. 路径: refs/head/*
   2. 查看本地分支: git branch -v
   3. 查看本地分支以及fetch回本地的远程分支: git branch -a
   4. 切换至develop分支: git checkout develop
   5. 切换至"分离头指针状态": git checkout commit-ID
	  1. 通常，HEAD总是指向分支指针头，表示该分支指针头指向的分支是当前分支，而让HEAD指向提交，表示版本库处于“分离头指针状态” 即，'detached HEAD'
	  2. ”分离头指针状态“的特点：
	     1. 可以检查，测试，提交而不影响任何分支
	     2. 切换回分支之后，在分离头指针状态下的提交在log中不再显示，提交也消失了，但是，依然存在版本库中，但是，当reflog中的该提交日志过期之后，这个提交随时会彻底删除
	     3. 合并“分离头指针状态”的提交至主分支master
		    1. 命令：git merge new-commit-ID
		    2. 由于在“分离头指针状态”所做出的提交除了能被new-commit-ID所访问到之外，就无法通过分支访问。另外，该提交随时会在版本库中彻底消失，如果这个提交对master很重要的话，可以通过该操作将这个提交合并到master上即可
	  3. 分离头指针状态的运用: 挑拣操作
		 1. A ----> B -----> C ----> D ----> E ----> F ----> G
		 2. 其中D是有问题提交,需要将其去掉
		 3. git checkout C  (以C为分支头指针重新开辟游离分支,并将HEAD指向该游离分支的指针头)
		 4. git cherry-pick E (挑拣E,重放值HEAD所指的提交的后面)
   6. 切换分支的本质是将HEAD指针指向当前切换分支的分支起点或者最新提交
   7. 以develop分支最新提交的第n个父提交为新分支起点,创建新分支并切换到新分支: git checkout -b new-br develop~n
   8. 重命名本地分支: git branch -m new_br new_branch
   9. 推送本地分支到远程服务器: git push origin develop
   10. 删除本地分支: git branch -d test-branch
   11. 将fetch回本地的远程分支与本地分支合并: git merge --no-ff -m "---" origin/feature
3. fetch回本地的远程分支:
   1. 路径: 服务器 refs/head/*  --->  本地 refs/remote/origin/
   2. 查看fetch回本地的远程分支: git branch -r
   3. fetch 位于服务器上所有的远程分支: git fetch origin
   4. fetch 位于服务器上指定的远程分支: git fetch origin develop
   5. 删除fetch回本地的远程分支:
   6. 备注: 在本地想要访问fetch回本地的远程分支,需要使用"远程主机/分支名"的形式读取,如: git merge --no-ff origin/feature-led
4. 位于服务器上的远程分支:
   1. 路径: refs/head/*
   2. 查看位于服务器上的远程分支: 
   3. 删除位于服务器上的远程分支: git push origin --delete feature-key   或者 git push origin :feature-key  
5. 分支在开发过程中的运用:
   1. 主分支: master
	  1. 意义: 新发布的一个正式版本
	  2. 特点: 稳定,tag标签,新版本
	  3. 分支起点: 项目发起者的第一个提交
	  4. 分支指针头: master
	  5. 分支变更来源: develop
	  6. 分支去向: 无
	  7. 生命周期: 永久
	  8. 权限分配:
   2. 开发分支: develop
	  1. 意义: 开发分支,当该分支达到某一稳定点,可以进行新版本的发布时,向master合并,并打上tag标签
	  2. 特点: 趋向稳定
	  3. 分支的起点: master分支的第一次提交
	  4. 分支指针头: develop
	  5. 分支变更来源: 辅助分支
	  6. 分支去向: master
	  7. 生命周期: 永久
	  8. 权限分配:
   3. 辅助分支: 辅助分支的生命周期是有限的,因此不应当push到远端服务器 
	  1. 特性分支: feature branch
		 1. 意义: 在特性分支上开发新的功能需求,这些功能是否需要整合到软件中还是未知的,所以,新功能在特性分支中进行研发,以方便新功能的加入和剔除
		 2. 特点: 一个功能对应一个特性分支,特性分支上的功能总是作为预备功能,时机成熟后合并到develop上
		 3. 分支起点: develop分支上的任意提交
		 4. 分支指针头: feature-xxx
		 5. 分支变更来源: 开发者的提交
		 6. 分支去向: develop
		 7. 合并时机: 该功能开发完毕,并测试成功; 老板决定在这一期发布的产品中加入该功能时
		 8. 生命周期: 功能开发完毕,合并到develop分支以后,或者产品经理决定放弃该功能的开发时,该分支声明周期结束,否则,只要该功能尚未开发完成,该特性分支就会一直存在
		 9. 权限分配:
		 10. 重要说明:
			 1. 特性分支可以理解为用户分支,这是因为一个功能对应一个特性分支,而在团队工作中,原则上一个功能应当交付给一个用户负责,这样可以避免合并冲突的问题,所以相当于一个用户对应一个特性分支
			 2. 特性分支属于辅助分支,一个特性分支对应一个用户,因此,特性分支仅仅只存在于用户的本地仓库中,并不上传到远端服务器
		 11. 从develop的任意提交,创建并切换至特性分支: git checkout -b feature-led develop~n
			 1. 从develop的任意提交创建特性分支: git br feature-led develop~n
			 2. 切换至该特性分支: git checkout feature-led
			 3. 备注: 切换分支的本质是将HEAD指针指向当前切换分支的分支起点或者最新提交
		 12. 将特性分支上的新功能合并到develop分支,等待发布:
			 1. 切换到develop分支: git checkout develop
			 2. 合并: git merge --no-ff -m "-----" feature-led
			 3. 备注: --no-ff表示禁止fast-forward,这是通常的选择
				1. fast-forward式的合并:
				   1. 开发一直在master分支进行，但忽然有一个新的想法，于是新建了一个develop的分支，并在其上进行一系列提交，完成时，回到 master分支
				   2. 此时，master分支在创建develop分支之后并未产生任何新的commit,此时的合并就叫fast forward
				2. fast-forward式的合并将不会产生新节点,而是直接移动指针,因此,这种合并方式在执行特性分支的删除操作之后,该特性分支的合并信息将会丢失
				3. --no-ff起到禁止fast-farward式的合并,删除特性分支后可以将该特性分支的合并信息保留下来,方便以后查看
			 4. 由于本次合并后会在develop分支上创建新的提交,所以 -m 选项是提交说明 
		 13. 删除特性分支: git branch -d feature-led
			 1. 特性分支的功能开发完毕并向develop合并成功之后,该用户完成任务, 此时应当删除该特性分支,以免造成混乱
			 2. 删除之后,该用户可以去领取下一个任务
			 3. 备注: 删除特性分支的本质是释放分支指针头feature-xxx
	  2. 发布分支: release branch
		 1. 意义: 修补bug;修改版本号; 通常,测试小组在develop上发现了bug,如果该bug还没有引入master分支,则适合用发布分支而不是紧急修复分支
		 2. 特点: 当从develop分支中创建发布分支以后，develop分支便可以进行新版本之后需求的研发工作，从而既不会影响到最新的研发进度，也不会影响到新版本的发布
		 3. 分支起点: develop分支上的任意提交
		 4. 分支指针头: release-xxx (如: release-fix-1.2 或者 release-tag-1.2)
		 5. 分支变更来源: 被指定修补该bug或者版本号的那个开发者在该分支上的提交
		 6. 分支去向: develop分支以及master分支
		 7. 合并时机: bug或者tag修复完毕后在该发布分支上生成提交,测试成功后,立即将该提交同时向develop分支以及master分支进行合并
		 8. 生命周期: 向develop分支以及master分支合并完毕之后
		 9. 权限分配:
		 10. 从develop的任意提交,创建并切换至发布分支: git checkout -b release-fix-1.2 develop~n
			 1. 用户user1在特性分支:feature-led上正专心致志的写led的驱动
			 2. 产品经理告知user1在2个小时之内需要修补一个代号为fix-1.2的bug
			 3. 用户user1感觉很为难,因为在当前特性分支feature-led上的任务还要3小时才能结束,而切换分支时,git又强制要求用户先提交当前分支的更改后才能切换到其他分支
			 4. 用户user1想到了一个好办法: git stash, 该命令将当前分支的工作现场储存起来
			 5. 此时当前分支的工作区已经干净了,用户就可以顺利的创建切换到发布分支了release-fix-1.2
			 6. 从develop的任意提交创建发布分支: git br release-fix-1.2 develop~n
			 7. 切换至该发布分支: git checkout release-fix-1.2
			 8. 在release-fix-1.2分支上修补bug,产生若干提交后终于修补了bug,最新的那个提交就是bug修复后的版本
			 9. 备注: 切换分支的本质是将HEAD指针指向当前切换分支的分支起点或者最新提交
		 11. 将发布分支上修补好的提交合并到develop分支上:
			 1. 切换至develop: git checkout develop
			 2. 合并: git merge --no-ff -m "-----" release-fix-1.2
			 3. 备注: --no-ff表示禁止fast-forward,这是通常的选择
				1. fast-forward式的合并:
				   1. 开发一直在master分支进行，但忽然有一个新的想法，于是新建了一个develop的分支，并在其上进行一系列提交，完成时，回到 master分支
				   2. 此时，master分支在创建develop分支之后并未产生任何新的commit,此时的合并就叫fast forward
				2. fast-forward式的合并将不会产生新节点,而是直接移动指针,因此,这种合并方式在执行特性分支的删除操作之后,该特性分支的合并信息将会丢失
				3. --no-ff起到禁止fast-farward式的合并,删除特性分支后可以将该特性分支的合并信息保留下来,方便以后查看
			 4. 由于本次合并后会在develop分支上创建新的提交,所以 -m 选项是提交说明 
		 12. 将发布分支上修补好的提交合并到master分支上并进行tag操作(可选):
			 1. 切换至master: git checkout master
			 2. 合并: git merge --no-ff -m "-----" release-fix-1.2
			 3. 创建里程碑: git tag -m "fix-1.2" v1.2-fix
			 4. 备注: --no-ff表示禁止fast-forward,这是通常的选择
				1. fast-forward式的合并:
				   1. 开发一直在master分支进行，但忽然有一个新的想法，于是新建了一个develop的分支，并在其上进行一系列提交，完成时，回到 master分支
				   2. 此时，master分支在创建develop分支之后并未产生任何新的commit,此时的合并就叫fast forward
				2. fast-forward式的合并将不会产生新节点,而是直接移动指针,因此,这种合并方式在执行特性分支的删除操作之后,该特性分支的合并信息将会丢失
				3. --no-ff起到禁止fast-farward式的合并,删除特性分支后可以将该特性分支的合并信息保留下来,方便以后查看
			 5. 由于本次合并后会在master分支上创建新的提交,所以 -m 选项是提交说明
			 6. 特别说明: 有可能出于战略上的考虑或者新版本发布的时间以及时机尚未成熟,暂时不合并到master上, 即这一步骤暂时不用进行,但是如果想要及时修补掉已发布版本中的bug,可以考虑使用hotfix分支
		 13. 完成合并之后,删除该发布分支: git branch -d release-fix-1.2
	  3. 紧急修复分支: hotfix branch
		 1. 意义: 用于正式版本的紧急修复,即如果在master分支发布的版本中发现了bug,则需要进行紧急修复,此时适合用紧急修复分支
		 2. 特点: bug已经引入master分支中
		 3. 分支起点: master
		 4. 分支指针头: hotfix-xxx
		 5. 分支变更来源: 被指定修补该紧急bug的那个开发者在该分支上的提交
		 6. 分支去向: master和develop
		 7. 生命周期: 合并到master以及develop分支之后
		 8. 权限分配:
		 9. 从master的任意版本,创建并切换至紧急修复分支: git checkout -b hotfix-1.2 master~n
			1. 用户user1在特性分支:feature-led上正专心致志的写led的驱动
			2. 产品经理告知user1在2个小时之内需要修补一个已经发布了的产品中有一个代号为hotfix-1.2的bug
			3. 用户user1感觉很为难,因为在当前特性分支feature-led上的任务还要3小时才能结束,而切换分支时,git又强制要求用户先提交当前分支的更改后才能切换到其他分支
			4. 用户user1想到了一个好办法: git stash, 该命令将当前分支的工作现场储存起来
			5. 此时当前分支的工作区已经干净了,用户就可以顺利的创建切换到发布分支了hotfix-1.2
			6. 从master的任意提交创建发布分支: git br hotfix-fix-1.2 develop~n
			7. 切换至该发布分支: git checkout hotfix-1.2
			8. 在hotfix-1.2分支上修补bug,产生若干提交后终于修补了bug,最新的那个提交就是bug修复后的版本
			9. 备注: 切换分支的本质是将HEAD指针指向当前切换分支的分支起点或者最新提交
		 10. 将紧急修复分支上修补好的提交合并到master分支上并进行tag操作:
			 1. 切换至master: git checkout master
			 2. 合并: git merge --no-ff -m "-----" hotfix-1.2
			 3. 创建里程碑: git tag -m "hotfix-1.2" v1.2-hotfix
			 4. 备注: --no-ff表示禁止fast-forward,这是通常的选择
				1. fast-forward式的合并:
				   1. 开发一直在master分支进行，但忽然有一个新的想法，于是新建了一个develop的分支，并在其上进行一系列提交，完成时，回到 master分支
				   2. 此时，master分支在创建develop分支之后并未产生任何新的commit,此时的合并就叫fast forward
				2. fast-forward式的合并将不会产生新节点,而是直接移动指针,因此,这种合并方式在执行特性分支的删除操作之后,该特性分支的合并信息将会丢失
				3. --no-ff起到禁止fast-farward式的合并,删除特性分支后可以将该特性分支的合并信息保留下来,方便以后查看
			 5. 由于本次合并后会在master分支上创建新的提交,所以 -m 选项是提交说明
		 11. 将紧急修复分支上修补好的提交合并到develop分支上(必须)
			 1. 切换至develop: git checkout develop
			 2. 合并: git merge --no-ff -m "-----" hotfix-1.2
			 3. 备注: --no-ff表示禁止fast-forward,这是通常的选择
				1. fast-forward式的合并:
				   1. 开发一直在master分支进行，但忽然有一个新的想法，于是新建了一个develop的分支，并在其上进行一系列提交，完成时，回到 master分支
				   2. 此时，master分支在创建develop分支之后并未产生任何新的commit,此时的合并就叫fast forward
				2. fast-forward式的合并将不会产生新节点,而是直接移动指针,因此,这种合并方式在执行特性分支的删除操作之后,该特性分支的合并信息将会丢失
				3. --no-ff起到禁止fast-farward式的合并,删除特性分支后可以将该特性分支的合并信息保留下来,方便以后查看
			 4. 由于本次合并后会在develop分支上创建新的提交,所以 -m 选项是提交说明
			 5. 备注: 当release-xx分支也存在时,紧急修复分支上的提交通常应当合并到release-xx分支上而不是develop分支
		 12. 完成合并之后,删除该紧急修复分支: git branch -d hotfix-1.2
		 13. 备注: 紧急修复分支同发布分支最大的区别在于,紧急修复分支主要针对master分支修复,而发布分支主要针对develop分支修复,其次,紧急修复分支必须同时向master分支以及develop分支合并,而发布分支向master的合并是可选的
Blog creation time:[2017-10-06 五 14:21]
