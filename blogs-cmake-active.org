* blogs-cmake-active
  版本: 3.10.0
  文档: https://cmake.org/documentation/

** WAITTING [#C] Theme:cmake-buildsystem                            :@Cmake:
*** Introduction
*** Binary Targets
*** Binary Executables
*** Binary Library Types
*** Normal Libraries
*** Apple Frameworks
*** Object Libraries
*** Build Specification and Usage Requirements
*** Target Properties
*** Transitive Usage Requirements
*** Compatible Interface Properties
*** Property Origin Debugging
*** Build Specification with Generator Expressions
*** Include Directories and Usage Requirements
*** Link Libraries and Generator Expressions
*** Output Artifacts
*** Runtime Output Artifacts
*** Library Output Artifacts
*** Archive Output Artifacts
*** Directory-Scoped Commands
*** Pseudo Targets
*** Imported Targets
*** Alias Targets
*** Interface Libraries
** WAITTING [#C] Theme:cmake-compile-features                       :@Cmake:
*** Introduction
*** Compile Feature Requirements
*** Requiring Language Standards
*** Availability of Compiler Extensions
*** Optional Compile Features
*** Conditional Compilation Options
*** Supported Compilers
** WAITTING [#C] Theme:cmake-command                                :@Cmake:
*** Scripting Commands
**** <<add_library>>
***** Normal Libraries
1. 命令: add_library(<name> [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 [source2 ...])
2. 作用: 将上述命令中列出的源文件编译到到一个名为<name>的库里面
3. <name> 是全局唯一的,假定name为tmp,则最终生成libtmp.a或者libtmp.so,具体生成静态库还是动态库依赖于选项, 请参阅 [[OUTPUT_NAME]] 目标属性的文档以更改最终文件名<name>
4. STATIC: 静态库,在链接阶段,同其他目标一起被全部链接成可执行文件
5. SHARED: 动态库,在链接阶段,其库名,函数名同其他目标一起链接成可执行文件,在运行期间动态加载
6. MODULE: 插件,不会同其他目标一起被链接成可执行文件,但是,可以在运行期间使用类似dlopen的功能动态加载
7. 如果被有显式指出 [STATIC | SHARED | MODULE] 中的任何一个,默认值是 STATIC 还是 SHARED 取决于变量 [[BUILD_SHARED_LIBS]] 是否为ON (为ON则默认为动态库)
8. 如果库的类型是 SHARED 和 MODULE，则 [[POSITION_INDEPENDENT_CODE]] 目标属性自动设置为ON
9. SHARED或STATIC库可以用 FRAMEWORK 目标属性标记来创建OS X框架
10. 如果库不导出任何符号，则不能将其声明为SHARED库,例如，在Windows上,一个不导出非托管符号的 resource DLL or a managed C++/CLI DLL 可能需要声明成一个MODULE库而不是SHARED库,这是因为CMake希望SHARED库在Windows上始终有一个关联的导入库
11. 默认情况下,库文件将会在构建树目录的位置被创建,当然了,请参阅 [[ARCHIVE_OUTPUT_DIRECTORY]], [[LIBRARY_OUTPUT_DIRECTORY]], [[RUNTIME_OUTPUT_DIRECTORY]] 来改变这个位置
12. EXCLUDE_FROM_ALL: 如果指定了该选项,在创建库时,相应的属性就会被设置,详情参阅 [[EXCLUDE_FROM_ALL]] 的文档
13. source1 [source2 ...]: 加入库的源文件列表,该参数可以使用 $<...> 这样的  “generator expressions” ,详情参考 [[ cmake-generator-expressions(7)]]
14. 有关定义生成系统属性的更多信息，请参阅 [[cmake-buildsystem（7）]]手册
15. 另请参阅 [[HEADER_FILE_ONLY]]，了解在某些源被预处理的情况下如何处理，以及想要在IDE中使用原始源又该如何处理
***** Imported Libraries
1. 命令: add_library(<name> <SHARED|STATIC|MODULE|OBJECT|UNKNOWN> IMPORTED [GLOBAL])
2. 一个 [[IMPORTED library target]] 引用一个位于项目外部的库文件,不会生成规则来构建它, 并且 [[IMPORTED]] 目标属性是 true 
3. <name>的范围只在创建它的目录中，但GLOBAL选项扩展了它的可见性, 以至于它可以像在项目中构建的任何目标一样被引用
4. 导入库对于像 [[target_link_libraries]]（）这样的命令的方便引用很有用
5. 有关导入的库的详细信息通过设置名称以IMPORTED_和INTERFACE_开头的属性指定
6. 最重要的属性是 [[IMPORTED_LOCATION]]（及其预配置变体[[IMPORTED_LOCATION_ <CONFIG>]]），它指定主库文件在磁盘上的位置。有关更多信息，请参阅 IMPORTED_ * 和 INTERFACE_ * 属性的文档
***** Object Libraries
1. 命令: add_library(<name> OBJECT <src>...)
2. 对象库的特点是,对象库编译源文件，但不会将其对象文件存档或链接到库中,即,对象库不能被链接
3. 相反，由add_library（）或add_executable（）创建的其他目标可以使用形式为$ <TARGET_OBJECTS：objlib>的表达式引用对象作为源,其中,objlib是一个对象库的名
4. 例如:
#+BEGIN_SRC 
	add_library(... $<TARGET_OBJECTS:objlib> ...)
	add_executable(... $<TARGET_OBJECTS:objlib> ...)
#+END_SRC
该例子给出的代码,将objlib的对象文件包含在一个库和一个可执行文件中
1. 对象库可能只包含编译，头文件和其他不会影响正常库链接的源文件（例如.txt）
2. 它们可能包含生成此类源的自定义命令，但不包含PRE_BUILD，PRE_LINK或POST_BUILD命令
3. 一些本地构建系统可能不喜欢只有对象文件的目标，所以考虑将至少一个真实的源文件添加到任何引用$ <TARGET_OBJECTS：objlib>的目标
***** Alias Libraries
1. 命令: add_library(<name> ALIAS <target>)
2. 创建一个 [[Alias Target]] 使得<name>可以用于在后续命令中引用<target>
3. <name>不会作为一个 make target 出现在 generated buildsystem 中
4. <target>可能不是一个[[Imported Target]] 或 ALIAS
5. ALIAS目标可以用作可链接的目标，也可以用作从中读取属性的目标
6. 可以使用 if(TARGET) 子命令测试 Alias_Target的存在性
7. <name>不能用来修改<target>的属性，也就是说，它不能用作 [[set_property]]（），[[set_target_properties]]（），[[target_link_libraries]]（）等的操作数
8. 一个ALIAS目标可能不能被安装或导出
***** Interface Libraries
1. 命令: add_library(<name> INTERFACE [IMPORTED [GLOBAL]])
2. 作用: 创建一个 [[Interface Library]]
3. 一个 INTERFACE 库目标不会直接创建构建输出，尽管它可能具有设置的属性，并且可以安装，导出和导入
4. 通常使用以下命令将INTERFACE_ *属性填充到接口目标上：
   1. [[set_property]]()
   2. [[target_link_libraries]](INTERFACE)
   3. [[target_include_directories]](INTERFACE)
   4. [[target_compile_options]](INTERFACE)
   5. [[target_compile_definitions]](INTERFACE)
   6. [[target_sources]](INTERFACE)
5. 像其他的目标一样,它被用作 [[target_link_libraries]]()的参数
6. 一个 INTERFACE 导入的目标也可以用这个签名来创建, 一个IMPORTED库目标引用在项目外定义的库
7. 目标名称的范围在创建它的目录中，但GLOBAL选项扩展了可见性, 它可以像在项目中构建的任何目标一样被引用,IMPORTED库对于像target_link_libraries（）这样的命令的方便引用很有用
**** <<find_library>>
***** 命令:
#+BEGIN_SRC 
     find_library (
     1. <VAR>
     2. name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
     3. [HINTS path1 [path2 ... ENV var]]
     4. [PATHS path1 [path2 ... ENV var]]
     5. [PATH_SUFFIXES suffix1 [suffix2 ...]]
     6. [DOC "cache documentation string"]
     7. [NO_DEFAULT_PATH]
     8. [NO_CMAKE_PATH]
     9. [NO_CMAKE_ENVIRONMENT_PATH]
     10. [NO_SYSTEM_ENVIRONMENT_PATH]
     11. [NO_CMAKE_SYSTEM_PATH]
     12. [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH]
     15. )
#+END_SRC
***** 参数解析:
1. <VAR>: 存储查找结果,如果找到了库文件,则将该文件(带绝对路径)存储在该变量内,如果没找到,该变量的值为<VAR>-NOTFOUND
2. name | NAMES name1 [name2 ...] [NAMES_PER_DIR] 
   1. name: 指定查找一个库
   2. NAMES: 指定查找一个或者更多个待搜索库的名字,当给NAMES选项赋予多个值时，默认情况下这个命令会一次考虑一个名字并搜索每个目录
   3. NAMES_PER_DIR选项告诉该命令一次考虑一个目录，并搜索其中的所有名称
   4. 给予NAMES选项的每个库名首先被认为是库文件名，然后考虑平台特定的前缀（例如lib）和后缀（例如.so）,因此可以直接指定libfoo.a等库文件名
3. [HINTS path1 [path2 ... ENV var]]
   1. 指明除了默认位置之外,还要搜索的目录
   2. ENV var 子选项从系统环境变量中读取路径
4. [PATHS path1 [path2 ... ENV var]]
   1. 指明除了默认位置之外,还要搜索的目录
   2. ENV var 子选项从系统环境变量中读取路径
5. [PATH_SUFFIXES suffix1 [suffix2 ...]]
   1. 指定补充子目录,如此便会检查每个搜索路径下面含有补充子目录的目录,比如: /home/ljj/t1 是PATHS中的指定搜索的目录,那么默认会到该路径下面搜索,但是不会搜索/home/ljj/t1/tmp
   2. 如果给出该选项为 tmp, 除了到 /home/ljj/t1下面搜索,还会到/home/ljj/t1/tmp下面搜索
6. [DOC "cache documentation string"]
   1. 之后的参数用来作为cache中的注释字符串
7. NO_DEFAULT_PATH: 如果指定了该选项，那么搜索的过程中不会有其他的附加路径,如果没有指定该选项，搜索过程如下：
   1. 搜索在cmake-specific cache 变量中指定的路径, 从命令行以-DVAR=value的形式传入,这些值被解释为 [[lists]] 如果传递了 NO_CMAKE_PATH，可以跳过这个路径的搜索
   2. 
8. NO_CMAKE_PATH: 默认会搜索cmake特有的cache变量中被指定的路径(这些变量是在用cmake命令行时，通过-DVAR=value指定的变量),如果指定了该选项,则跳过该搜索路径,但是还包括如下的路径
   1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 [[CMAKE_PREFIX_PATH]] 中的每一个前缀
   2. [[CMAKE_LIBRARY_PATH]]
   3. [[CMAKE_FRAMEWORK_PATH]]
9. NO_CMAKE_ENVIRONMENT_PATH: 默认会搜索cmake特有的环境变量中被指定的路径,这是用户在shell配置中设置的变量,如过指定了该选项, 则跳过该搜索路径,但是还包括如下的路径
   1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 CMAKE_PREFIX_PATH 中的每一个前缀
   2. CMAKE_LIBRARY_PATH
   3. CMAKE_FRAMEWORK_PATH
10. NO_SYSTEM_ENVIRONMENT_PAT: 默认会搜索标准的系统环境变量,如果指定了该选项，这些环境变量中的路径会被跳过,但是搜索的路径还包括：PATH LIB
11. NO_CMAKE_SYSTEM_PATH: 默认会搜索当前系统平台文件中定义的cmake变量,如果指定了该选项,这些变量中的路径将会被跳过,但是还包括如下的路径
    1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 [[CMAKE_SYSTEM_PREFIX_PATH]] 中的每一个前缀
    2. [[CMAKE_SYSTEM_LIBRARY_PATH]]
    3. [[CMAKE_SYSTEM_FRAMEWORK_PATH]]
12. [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH]



   6. 搜索由PATHS或者精简版命令中指定的路径 
如果找到了库文件,搜索过程将不再重复，除非该变量被清空,如果没有找到库文件,下次使用相同变量调用find_library()命令时，搜索过程会再次尝试

       * 如果找到的库是一个框架，那么<VAR>将被设置为框架<fullPath> /A.framework的完整路径。当框架的完整路径被用作库时，CMake将使用-framework A和-F <fullPath>将框架链接到目标
       * 


       * CMake变量[[CMAKE_FIND_ROOT_PATH]]指定一个或多个目录作为所有其他搜索目录的前缀
       * [[CMAKE_SYSROOT]]变量也可以用来指定一个目录作为前缀
       * 默认情况下，首先搜索CMAKE_FIND_ROOT_PATH中列出的目录,然后搜索CMAKE_SYSROOT目录，然后搜索非根目录的目录。默认行为可以通过设置[[CMAKE_FIND_ROOT_PATH_MODE_LIBRARY]]进行调整
       * 在13中所示的行为可以通过下面的参数覆盖
         1. CMAKE_FIND_ROOT_PATH_BOTH: 按照13所述的顺序搜索
         2. ONLY_CMAKE_FIND_ROOT_PATH: 不使用CMAKE_FIND_ROOT_PATH变量
         3. NO_CMAKE_FIND_ROOT_PATH: 只搜索re-rooted目录以及[[CMAKE_STAGING_PREFIX]]下的目录
       * 默认的搜索顺序的设计逻辑是按照使用时从最具体到最不具体。通过多次调用find_library命令以及NO_*选项，可以覆盖工程的这个默认顺序
       * 如果设置了[[CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX]]变量，所有的搜索路径将被正常测试，附带后缀，并且所有匹配的lib /替换为lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/
         1. 如果[[FIND_LIBRARY_USE_LIB32_PATHS]]全局属性被设置，所有的搜索路径将被正常测试，32 /附加，lib /所有匹配替换为lib32 /。如果至少启用了project（）命令支持的一种语言，则会自动为已知需要的平台设置此属性
         2. 如果[[FIND_LIBRARY_USE_LIB64_PATHS]]全局属性被设置，所有的搜索路径将被正常地测试，64 /追加，并且所有匹配的lib /替换为lib64 /。如果至少启用了project（）命令支持的一种语言，则会自动为已知需要的平台设置此属性
       * 变量CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX将覆盖FIND_LIBRARY_USE_LIB32_PATHS，FIND_LIBRARY_USE_LIBX32_PATHS和FIND_LIBRARY_USE_LIB64_PATHS全局属性
*** Project Commands
**** <<target_include_directories>>
#+BEGIN_SRC 
target_include_directories(<target> [SYSTEM] [BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> [items1...]
  [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
#+END_SRC
1. 作用： 当编译一个给定目标时，指定编译过程中使用到的 include directory
2. 要求： <target> 必须是一个已经被 [[add_executable]]() 或者 [[add_library]]()创建的目标，同时，不能是一个 [[IMPORTED]] 目标
3. [SYSTEM]: 如果指定了该选项，就等于告诉编译器，这个目录是作为 system include directory
4. [BEFORE]： 如果指定该选项，则内容将被预置到属性而不是被追加
5. <INTERFACE|PUBLIC|PRIVATE> [items1...]：指定参数的scope
   1. PUBLIC和PRIVATE items 将会构成<target>的[[INCLUDE_DIRECTORIES]]属性
   2. PUBLIC和INTERFACE items 将会构成<target>的[[INTERFACE_INCLUDE_DIRECTORIES]]属性
6. 如果[SYSTEM] 同 PUBLIC 或者 INTERFACE 一起被指定，将会构成<target>的[[INTERFACE_SYSTEM_INCLUDE_DIRECTORIES]]属性
6. 被指定的 include directory 可能是绝对路径或者是相对路径
7. 该命令的参数可能会使用语法为$<...>的“generator expressions”，详情查阅[[cmake-generator-expressions(7)]]
**** <<target_link_libraries>>
作用： 当链接一个给定的目标时，指定使用到的library或者flags
***** Overview
#+BEGIN_SRC 
target_link_libraries(<target> ... <item>... ...)
#+END_SRC
1. <target>： 必须已经在当前目录中使用 [[add_executable]]()或者[[add_library]]()完成创建
2. <item>： 每个item可能是下面的情况
   1. A library target name
   2. A full path to a library file
   3. A plain library name:
   4. A link flag
   5. A debug, optimized, or general keyword immediately followed by another <item>
***** Libraries for a Target and/or its Dependents
#+BEGIN_SRC 
target_link_libraries(<target>
                      <PRIVATE|PUBLIC|INTERFACE> <item>...
                     [<PRIVATE|PUBLIC|INTERFACE> <item>...]...)
#+END_SRC
1. PUBLIC, PRIVATE and INTERFACE 关键字用于指明在一个命令中的 link dependencies 和 link interface
2. 标识 PUBLIC 的Libraries and targets 会被链接到 link interface,并且成为link interface的一部分
3. 标识 PRIVATE 的Libraries and targets 会被链接到 link interface,但是不会成为link interface的一部分
4. 标识 INTERFACE 的 Libraries and targets 会被添附到 link interface,但是不用于链接<target>
***** Libraries for both a Target and its Dependents
#+BEGIN_SRC
target_link_libraries(<target> <item>...)
#+END_SRC
说明： 从文档的说明中，该用法同 target_link_libraries(<target> LINK_PUBLIC <lib>...)貌似一致
***** Libraries for a Target and/or its Dependents (Legacy)
#+BEGIN_SRC 
target_link_libraries(<target>
                      <LINK_PRIVATE|LINK_PUBLIC> <lib>...
                     [<LINK_PRIVATE|LINK_PUBLIC> <lib>...]...)
#+END_SRC
1. LINK_PUBLIC and LINK_PRIVATE modes 可以用于在一个命令中指明 the link dependencies and the link interface
2. 标识LINK_PUBLIC的Libraries and targets会被链接到 [[INTERFACE_LINK_LIBRARIES]] 并成为其中的一部分
3. 标识LINK_PRIVATE的Libraries and targets会被链接到 [[INTERFACE_LINK_LIBRARIES]] 但是不会成为其中的一部分
4. 如果 policy CMP0022 的值不是NEW,他们也会成为 [[LINK_INTERFACE_LIBRARIES]] 的一部份
***** Libraries for Dependents Only (Legacy)
#+BEGIN_SRC 
target_link_libraries(<target> LINK_INTERFACE_LIBRARIES <item>...)
#+END_SRC
1. LINK_INTERFACE_LIBRARIES模式添加这个库到[[INTERFACE_LINK_LIBRARY]]属性，而不是使用这个库来进行链接
2. 此用法仅用于兼容性，优先选择INTERFACE模式
***** Cyclic Dependencies of Static Libraries
***** Creating Relocatable Packages
*** CTest Commands
*** Deprecated Commands
** WAITTING [#C] Theme:cmake-developer                              :@Cmake:
*** Introduction
*** Adding Compile Features
*** Help
**** T Markup Constructs
**** TCMake Domain
**** TCross-References
**** TStyle
***** TStyle: Section Headers
***** TStyle: Whitespace
***** TStyle: Line Length
***** TStyle: Prose
***** TStyle: Starting Literal Blocks
***** TStyle: CMake Command Signatures
***** TStyle: Boolean Constants
***** TStyle: Inline Literals
***** TStyle: Cross-References
***** TStyle: Referencing CMake Concepts
***** TStyle: Referencing CMake Domain Objects
*** TModules
**** Module Documentation
**** TFind Modules
***** TStandard Variable Names
***** TA Sample Find Module
** WAITTING [#C] Theme:cmake-generator-expressions(7)               :@Cmake:
*** Introduction
*** T Logical Expressions
*** T Informational Expressions
*** TOutput Expressions
** WAITTING [#C] Theme:cmake-generators(7)                          :@Cmake:
*** Introduction
*** CMake Generators
**** Command-Line Build Tool Generators
***** Makefile Generators
***** Ninja Generator
**** IDE Build Tool Generators
***** Visual Studio Generators
***** Other Generators
*** TExtra Generators
** WAITTING [#C] Theme:cmake-language                               :@Cmake:
*** Variables
    1. 在 cmake 的语法中,变量是基本的存储单元
    2. 变量的值总是字符串类型
    3. set 和 unset 命令用于设置以及清除变量的值(当然了,也有其他的一些命令含有修改变量值的语义)
    4. 变量名是大小写敏感的,建议使用_和-来组合变量
    5. 变量有动态的范围,每个使用set或者unset赋值的变量实际上是在当前范围内创建了一个绑定 
 Blog creation time:[2017-11-08 三 09:38]
** WAITTING [#C] Theme:cmake-server(7)                              :@Cmake:
** WAITTING [#C] Theme:cmake-modules(7)                             :@Cmake:
** WAITTING [#C] Theme:cmake-packages(7)                            :@Cmake:
** WAITTING [#C] Theme:cmake-policies                               :@Cmake:
1. introduction
   1. 开发中会遇到这样的事,使用cmake开发了一个项目,突然一不小心在系统升级时将cmake的版本也升级了
   2. 新版本的cmake相比于老版本的cmake,某些命令或者变量带来了行为上的改变,当前的项目在编译时会出现一些警告,甚至是行为不符的现象
   3. 在cmake中,为了解决这样的情况,提供了一种称为policy的机制,cmake的设计者每次发布新版本时,如果发现新版本相对老版本带来了某些行为上的改变,就会顺带发布一个CMP_<NNNN>的policy
   4. 每个CMP_<NNNN>中都会"旧行为"和"新行为",以及引入该policy的原因
   5. 在工程中可以设置各种policy来选择期望的行为
Blog creation time:[2017-11-08 三 13:28]
** WAITTING [#C] Theme:cmake-properties                             :@Cmake:
*** Properties of Global Scope
    1. <<ENABLED_LANGUAGES>>
        1. 存储当前使能的语言列表
        2. 由命令[[enable_language]]配置
        3. 只读
*** Properties on Directories
*** Properties on Targets
**** <<POSITION_INDEPENDENT_CODE>>
1. 该变量的属性决定了将要创建的可执行文件或者共享库是否位置独立
2. 如果一个库是 SHARD 和 MODULE,那么这个属性自动设置为true
3. 该属性值被变量 [[CMAKE_POSITION_INDEPENDENT_CODE]] 的值初始化
4. 参考 [[add_library]]()
*** Properties on Tests
*** Properties on Source Files
*** Properties on Cache Entries
*** Properties on Installed Files
*** Deprecated Properties on Directories
    1. COMPILE_DEFINITIONS_<CONFIG>
    2. TEST_INCLUDE_FILE
*** Deprecated Properties on Targets
    1. COMPILE_DEFINITIONS_<CONFIG>
    2. POST_INSTALL_SCRIPT
    3. PRE_INSTALL_SCRIPT
*** Deprecated Properties on Source Files
     1. COMPILE_DEFINITIONS_<CONFIG>
 Blog creation time:[2017-11-09 四 15:16]
** WAITTING [#C] Theme:cmake-qt(7)                                  :@Cmake:
** WAITTING [#C] Theme:cmake-toolchains                             :@Cmake:
*** <<Introduction>>
    1. CMake使用工具链来进行编译,链接库,创建归档，以及使用一些任务去进行构建
    2. 命令[[project]]()以及 [[enable_language]]()中给出的语言决定了采用何种工具链工具
    3. 在常规构建中，CMake基于系统自检和缺省自动为宿主构建决定工具链
    4. 在交叉编译的情况下，可以通过相关的编译器和工具路径来指定工具链文件
*** <<Languages>>
    1. 在使用[[project]]()命令时,如果设置了LANGUAGE参数,或者使用[[enable_language]](),则内置变量[[CMAKE_C_COMPILER]]就会被设置为指定的语言,如果没有做出任何设置,则会默认隐式使用缺省的C以及CXX
    2. 采用的语言决定了一些信息，如编译器的供应商和版本，目标架构和位宽，相应工具的位置等
    3. 当语言被确定好以后，相应的就确定了使用 何种编译器,链接器
    4. 全局属性[[ENABLED_LANGUAGES]]包含当前启用的语言
    5. 通过目标中源文件的语言来计算采用的链接器,在静态库的情况下，也通过依赖库的语言来计算,CMake做出的选择可能被目标属性 [[LINKER_LANGUAGE]] 重写
*** <<Variables and Properties>>
    1. 几个关于工具链的语言组件变量会被使用
    2. [[CMAKE_TOOLCHIAIN_FILE]] 提供一个交叉编译的脚本
    3. [[CMAKE_SYSTEM_NAME]] 目标机上运行的操作系统的名称
    4. [[CMAKE_SYSTEM_PROCESSOR]] 目标机的硬件架构，例如ARM，X86
    5. [[CMAKE_C_COMPILER]] 指明了<LANG>语言的编译器所在的路径
    6. [[CMAKE_C_COMPILER_ID]] 作为编译器的标识
    7. [[CMAKE_C_COMPILER_VERSION]] 标识编译器的版本
    8. [[CMAKE_C_FLAGS]] 当编译一个特定语言的文件时,该变量中给出的选项将会被作为编译时的选项
    9. [[CMAKE_FIND_ROOT_PATH]] 搜索路径
    10. [[CMAKE_SYSROOT]]  搜索路径
*** Toolchain Features
*** Cross Compiling
    1. <<CMAKE_TOOLCHIAIN_FILE>> 这应当是CMake交叉编译中最重要的概念了,CMake不知道你的目标平台是什么、用什么编译器、如何编译等等，所以你需要提供预设一些变量到CMake
    2. 其中最为方便的一个方法就是将相关的变量设置都放进一个文件(cmake脚本)中去，然后将该文件通过CMAKE_TOOLCHIAIN_FILE传递给CMake 
    3. 传递交叉编译脚本的方法: cmake -D CMAKE_TOOLCHIAIN_FILE="/path/to/my-cmake-toolchain-file" ..   (当然,也可以在CMakeList.txt中直接给出)
    4. <<目标机>>: 运行代码的实体机,比如stm32f407zgt6 
    5. <<宿主即>>: 也叫开发平台,比如linux,windows
    6. 交叉编译: 在宿主机上开发程序,烧录到目标机上运行
    7. cmake是无法自动判断出目标机的上运行的系统的,因此必须需要我们通过变量 [[CMAKE_SYSTEM_NAME]] 指定
    8. 在宿主机上交叉编译出来的可执行文件通常不能直接运行在宿主机上
    9. 交叉编译过程中不能使用宿主机上的原生头文件和库，而是需要用到一套专门针对目标机的头文件和库,如embi-arm-linux-xx
    10. 在交叉编译时(即指定了[[CMAKE_SYSTEM_NAME]]), [[CMAKE_CROSSCOMPILING]]变量将被设置为真值
    11. 稍微大一点的项目都会用到一些外部依赖库或者tool,CMake提供了 [[find_library]]() [[find_package]]() [[find_file]]() [[find_program]]() [[find_path]]()来进行外部依赖的搜索查找
    12. 变量[[CMAKE_FIND_ROOT_PATH]] 和 [[CMAKE_SYSROOT]] 指明了外部依赖的搜索路径,即所有find_*将在这两个变量指定的路径路径,以及宿主机相关的路径下搜索,当然了,可以限制只在某一路径下搜索,详情参考CMAKE_FIND_ROOT_PATH
 Blog creation time:[2017-11-08 三 09:40]
** WAITTING [#C] Theme:cmake-env-variables                          :@Cmake:
1. 设置环境变量set(ENV{CMAKE_C_FLAGS} "-O3 -Wall")
2. 查看环境变量message(STATUS "CMAKE_C_FLAGS: " $ENV{CMAKE_C_FLAGS})
3. Environment Variables that Control the Build
   1. CMAKE_CONFIG_TYPE
   2. CMAKE_MSVCIDE_RUN_PATH
   3. CMAKE_OSX_ARCHITECTURES
   4. LDFLAGS
   5. MACOSX_DEPLOYMENT_TARGET
4. Environment Variables for Languages
   1. ASM<DIALECT>
   2. ASM<DIALECT>FLAGS
   3. CC
   4. <<CFLAGS>>
      1. 如果CMAKE_C_FLAGS没有定义,则在编译c源文件时,该变量存储默认的编译flags
      2. 如果CMAKE_C_FLAGS没有定义,仅仅在首次配置CC的默认编译状态时,该变量才被cmake使用,之后,这个值存储在CMAKE_C_FLAGS中
      3. 如果定义了[[CMAKE_C_FLAGS]],不论是首次配置还是任意次配置CC的编译flags,该变量CFLAGS都会被忽略
   5. CSFLAGS
   6. CUDACXX
   7. CUDAFLAGS
   8. CUDAHOSTCXX
   9. CXX
   10. CXXFLAGS
   11. FC
   12. FFLAGS
   13. RC
   14. RCFLAGS
5. Environment Variables for CTest
   1. CMAKE_CONFIG_TYPE
   2. CTEST_INTERACTIVE_DEBUG_MODE
   3. CTEST_OUTPUT_ON_FAILURE
   4. CTEST_PARALLEL_LEVEL
   5. CTEST_USE_LAUNCHERS_DEFAULT
   6. DASHBOARD_TEST_FROM_CTEST
Blog creation time:[2017-11-08 三 09:39]
** WAITTING [#C] Theme:cmake-variables                              :@Cmake:
*** Variables that Provide Information
    1. <<CMAKE_CURRENT_LIST_DIR>>
       1. 含义: 当前正在处理的列表文件(CMakelists.txt)所在的目录路径
       2. 动态变量
       3. 如: /home/ljj/workspace/test5/dir/
    2. <<CMAKE_CURRENT_LIST_FILE>>
       1. 含义: 当前正在处理的列表文件(CMakeLists.txt)
       2. 动态变量
       3. 如:  /home/ljj/workspace/test5/dir/CMakeLists.txt
    3. <<PROJECT-NAME_BINARY_DIR>>
       1. 作用: 该变量的值是命令project(<PROJECT-NAME> ......)中指定的项目名的顶层 binary directory 目录的路径
       2. 使用场合: 当使用add_subdirectory()命令来连接几个工程时,该变量就十分有用
       3. 个人建议: PROJECT_BINARY_DIR指代的对象没有该变量指代的清楚明了,建议使用该变量
    4. <<PROJECT-NAME_SOURCE_DIR>>
       1. 作用: 该变量的值是命令project(<PROJECT-NAME> ......)中指定的项目名的顶层 source directory 目录的路径
       2. 使用场合: 当使用add_subdirectory()命令来连接几个工程时,该变量就十分有用
       3. 个人建议: PROJECT_SOURCE_DIR指代的对象没有该变量指代的清楚明了,建议使用该变量
    5. <<PROJECT-NAME_VERSION>>
       1. 作用:  该变量用于存储命令project(<PROJECT-NAME>  [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]......)中指定的VERSION
       2. 备注: cmake_policy
    6. <<PROJECT-NAME>_VERSION_MAJOR>>
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第1个号码<major>
    7. <<PROJECT-NAME_VERSION_MINOR>>
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第2个号码<minor>
    8. <<PROJECT-NAME>_VERSION_PATCH>>
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第3个号码<patch> 
    9. <<PROJECT-NAME>_VERSION_TWEAK>>
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第4个号码<tweak>
    10. <<PROJECT_DESCRIPTION>>
        1. 作用: 存储project命令中<DESCRIPTION>参数,项目描述信息
    11. <<PROJECT_NAME>>
        1. 作用: 该变量的值是命令project(<PROJECT-NAME> ......)中指定的项目名<PROJECT-NAME>
        2. 使用场合: 可以通过查询该变量得知项目的名字
*** Variables that Change Behavior
****  <<BUILD_SHARED_LIBS>>
1. 该变量如果设置为ON,则在全局范围内,[[ add_library]]() 默认创建的所有库均是 SHARD 库,除非明确的指出要创建一个STATIC库
2. 该变量经常在项目中最为一个 [[option]]() 以便项目的每一个用户能够决定它们是否想要使用静态库或者动态库构建系统


     2. <<CMAKE_BUILD_TYPE>>
        1. 作用: 指定 build tree 的 build type 
        2. 可能的值是: empty, Debug, Release, RelWithDebInfo and MinSizeRel
        3. 这个变量仅仅在 single-configuration generators 时才有意义
        4. 有很多预配置属性和变量,诸如 [[CMAKE_C_FLAGS_<CONFIG>]] , CMAKE_C_FLAGS_[DEBUG|RELEASE|RELWITHDEBINFO|MINSIZEREL]
        5. 例如,如果配置了某 build tree 的 build type 为Debug, CMake 会将 CMAKE_C_FLAGS_DEBUG 添加到 [[CMAKE_C_FLAGS]] 中去
     3. <<CMAKE_FIND_ROOT_PATH>>
        1. 在交叉编译时,该变量是十分有用的,比如,在给一个ARM处理器的移动设备做交叉编译，其中需要寻找libjpeg.so
        2. 假如使用find_package(JPEG) 在没有设置该变量的前提下,返回的是/usr/lib/libjpeg.so
        3. 这是有问题的，因为找到的这个so库只是给你的宿主机系统(例如一个x86的Ubuntu主机)服务的，不能用于arm系统
        4. 所以你需要告诉CMake去其它地方去查找,该变量就是干这个事的,它在文件系统层次给出了一个用于搜索的根
        5. 比如 [[set]](CMAKE_FIND_ROOT_PATH /home/ljj/stm32/embi-arm-linux-xx)
        6. 默认情况下,CMake首先会到/home/ljj/stm32/embi-arm-linux-xxx/usr/lib或者/home/ljj/stm32/embi-arm-linux-xx/lib等子目录下面搜索所有find_*命令给出的条目
        7. 如果没有找到(且设置了 [[find_package(BOTH)]] 的情况下),可以接着到 [[CMAKE_SYSROOT]] 列出的路径下搜索, 如果还是没有找到的话就到宿主机的相关目录下搜索
        8. 默认这个变量是空,交叉编译中应当对该变量进行设置
        9. 配置该变量的同时还应配置[[CMAKE_FIND_ROOT_PATH_MODE_PROGRAM]] , [[CMAKE_FIND_ROOT_PATH_MODE_LIBRARY]] , [[CMAKE_FIND_ROOT_PATH_MODE_INCLUDE]] , [[CMAKE_FIND_ROOT_PATH_MODE_PACKAGE]]
        10. 参考 [[Cross Compiling]]  [[CMAKE_SYSROOT]] 
     4. <<CMAKE_FIND_ROOT_PATH_MODE_LIBRARY>>
        1. 该变量用于控制 [[find_library]]()命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]]给出的路径下面搜索
        2. 如果设置为ONLY,那么,find_library() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
        3. 如果设置为NEVER,那么, find_library() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
        4. 如果设置为BOTH,那么,find_library() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
     5. <<CMAKE_FIND_ROOT_PATH_MODE_INCLUDE>>
        1. 该变量用于控制 [[find_file]](), [[find_path]]() 命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]] 给出的路径下面搜索
        2. 如果设置为ONLY,那么,find_file(),find_path() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
        3. 如果设置为NEVER,那么, find_file(),find_path() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
        4. 如果设置为BOTH,那么,find_file(),find_path() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
     6. <<CMAKE_FIND_ROOT_PATH_MODE_PACKAGE>>
        1. 该变量用于控制 [[find_package]]()命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]]给出的路径下面搜索
        2. 如果设置为ONLY,那么,find_package() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
        3. 如果设置为NEVER,那么, find_package() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
        4. 如果设置为BOTH,那么,find_package() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
     7. <<CMAKE_FIND_ROOT_PATH_MODE_PROGRAM>>
        1. 该变量用于控制 [[find_program]]()命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]]给出的路径下面搜索
        2. 如果设置为ONLY,那么,find_program() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
        3. 如果设置为NEVER,那么, find_program() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
        4. 如果设置为BOTH,那么,find_program() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
     8. <<CMAKE_INCLUDE_PATH>>
     9. <<CMAKE_INSTALL_PREFIX>>
        1. 该变量被命令[[install]]()使用到
        2. 当 make install 被调用 或者 使用命令install()时,这个变量的目录所示的路径将会被安装路径的后面
        3. 在UNIX下,这个变量默认是/usr/local,在window下,默认是c:/Program Files/${PROJECT_NAME}
        4. 该变量的使用方法: cmake -DCMAKE_INSTALL_PREFIX=usr/ .. 此时 make DESTDIR=/home/john install 后,软件的安装路径就是usr/home/john
        5. 备注: 当然了,该变量也可以在CMakeLists.txt中使用set进行配置,原则是如果用户在命令行使用-D定义了默认路径的话,就使用命令行的路径,否则就使用set设置的路径
        6. 通过判断 [[CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT]] 的值实现该变量的配置:
        7. if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
        8. [[set]](CMAKE_INSTALL_PREFIX "/my/default" CACHE PATH "..." FORCE)
     10. <<CMAKE_POLICY_DEFAULT_CMP_NNNN>>
         1. 作用: 存储某个policy的默认配置(OLD or NEW)
         2. 更改: cmake_policy(SET CMP0048 NEW)
         3. 说明: <NNNN>代表某个policy的编号,如0048,该编号具体是什么含义,参见cmake-policies
*** Variables that Describe the System
    1. <<CMAKE_SYSTEM_NAME>>
       1. [[目标机]]上运行的操作系统的名称,比如Linux,Android,如果你的嵌入式平台没有相关OS你即需要写成”Generic”
       2. 这是在toolchain脚本中必须要设置的变量,只有当CMAKE_SYSTEM_NAME这个变量被设置了，CMake才认为此时正在交叉编译
       3. 它会额外设置一个变量[[CMAKE_CROSSCOMPILING]]为TRUE
       4. 参考 [[CMAKE_TOOLCHIAIN_FILE]] 
    2. <<CMAKE_SYSTEM_PROCESSOR>>
       1. 代表[[目标机]]的硬件架构，例如ARM，X86
       2. 这个是可选项，但是在移动开发中很重要
*** Variables that Control the Build
    1. <<CMAKE_EXE_LINKER_FLAGS>>
       1. 作用: 存储创建可执行文件时用到的链接flags
       2. 这个变量中的flags将会在创建一个可执行文件时被使用
    2. <<CMAKE_POSITION_INDEPENDENT_CODE>>
	     1.该变量被用于初始化所有目标的  [[POSITION_INDEPENDENT_CODE]] 属性
       1. 该变量的值也被用于 [[try_compile]]()
    3. <<EXECUTABLE_OUTPUT_PATH>>
       1. 作用: 重新指定最终二进制目标的路径
       2. 设置: set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
       3. 备注: 一个重要的问题是,配置这个变量的这条指令应当写在哪个CMakeLists.txt中呢,其基本原则是在哪里 [[ADD_EXECUTABLE]] 或 [[ADD_LIBRARY]],如果需要改变目标存放路径,就在哪里加入上述的定义
       4. 相关: [[add_subdirectory]]()
    4. <<LIBRARY_OUTPUT_PATH>>
       1. 作用: 重新指定最终生成的共享库的路径
       2. 设置: set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
*** Variables for Languages
    1. <<CMAKE_<LANG>_COMPILER>>
       1. <<CMAKE_C_COMPILER>>
       2. 参考 [[Languages]]
    2. <<CMAKE_<LANG>_COMPILER_ID>>
       1. <<CMAKE_C_COMPILER_ID>>
       2. A short string unique to the compiler vendor
       3. 比如: set(CMAKE_C_COMPILER "ARMCC = ARM Compiler (arm.com)")
       4. 参考 [[Variables and Properties]]
    3. <<CMAKE_<LANG>_FLAGS>>
       1. <<CMAKE_C_FLAGS>>: 存储c编编译过程中的所有flags
          1. 可以通过[[add_compile_options]]命令以及[[add_definitions]]设置flags,但是不推荐,因为这两个命令设置的值对所有的编译器都有效.推荐使用set,它只对指定的编译器有效
       2. 该变量一旦定义,则[[CFLAGS]]将会被忽略,因此该变量的值在没有赋值之前为空
       3. 建议使用set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O3 -Wall")这种方式将CMAKE_C_FLAGS 设置为 -O3 -Wall (注意不是追加)
       4. 参考 [[Variables and Properties]]
*** Variables for CTest
*** Variables for CPack
 Blog creation time:[2017-11-08 三 09:24]
