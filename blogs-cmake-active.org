* blogs-cmake-active
  版本: 3.10.0
  官网: https://cmake.org
  文档: https://www.linuxjournal.com/article/6700?page=0,0
** WAITTING [#C] Theme:cmake-buildsystem                            :@Cmake:
*** Introduction
*** Binary Targets
*** Binary Executables
*** Binary Library Types
*** Normal Libraries
*** Apple Frameworks
*** Object Libraries
*** Build Specification and Usage Requirements
*** Target Properties
*** Transitive Usage Requirements
*** Compatible Interface Properties
*** Property Origin Debugging
*** Build Specification with Generator Expressions
*** Include Directories and Usage Requirements
*** Link Libraries and Generator Expressions
*** Output Artifacts
*** Runtime Output Artifacts
*** Library Output Artifacts
*** Archive Output Artifacts
*** Directory-Scoped Commands
*** Pseudo Targets
*** Imported Targets
*** Alias Targets
*** Interface Libraries
** WAITTING [#C] Theme:cmake-compile-features                       :@Cmake:
*** Introduction
*** Compile Feature Requirements
*** Requiring Language Standards
*** Availability of Compiler Extensions
*** Optional Compile Features
*** Conditional Compilation Options
*** Supported Compilers
** WAITTING [#C] Theme:cmake-command                                :@Cmake:
*** Scripting Commands
**** <<add_library>>
***** Normal Libraries
1. 命令: add_library(<name> [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 [source2 ...])
2. 作用: 将上述命令中列出的源文件编译到到一个名为<name>的库里面
3. <name> 是全局唯一的,假定name为tmp,则最终生成libtmp.a或者libtmp.so,具体生成静态库还是动态库依赖于选项, 请参阅 [[OUTPUT_NAME]] 目标属性的文档以更改最终文件名<name>
4. STATIC: 静态库,在链接阶段,同其他目标一起被全部链接成可执行文件
5. SHARED: 动态库,在链接阶段,其库名,函数名同其他目标一起链接成可执行文件,在运行期间动态加载
6. MODULE: 插件,不会同其他目标一起被链接成可执行文件,但是,可以在运行期间使用类似dlopen的功能动态加载
7. 如果被有显式指出 [STATIC | SHARED | MODULE] 中的任何一个,默认值是 STATIC 还是 SHARED 取决于变量 [[BUILD_SHARED_LIBS]] 是否为ON (为ON则默认为动态库)
8. 如果库的类型是 SHARED 和 MODULE，则 [[POSITION_INDEPENDENT_CODE]] 目标属性自动设置为ON
9. SHARED或STATIC库可以用 FRAMEWORK 目标属性标记来创建OS X框架
10. 如果库不导出任何符号，则不能将其声明为SHARED库,例如，在Windows上,一个不导出非托管符号的 resource DLL or a managed C++/CLI DLL 可能需要声明成一个MODULE库而不是SHARED库,这是因为CMake希望SHARED库在Windows上始终有一个关联的导入库
11. 默认情况下,库文件将会在构建树目录的位置被创建,当然了,请参阅 [[ARCHIVE_OUTPUT_DIRECTORY]], [[LIBRARY_OUTPUT_DIRECTORY]], [[RUNTIME_OUTPUT_DIRECTORY]] 来改变这个位置
12. EXCLUDE_FROM_ALL: 如果指定了该选项,在创建库时,相应的属性就会被设置,详情参阅 [[EXCLUDE_FROM_ALL]] 的文档
13. source1 [source2 ...]: 加入库的源文件列表,该参数可以使用 $<...> 这样的  “generator expressions” ,详情参考 [[ cmake-generator-expressions(7)]]
14. 有关定义生成系统属性的更多信息，请参阅 [[cmake-buildsystem（7）]]手册
15. 另请参阅 [[HEADER_FILE_ONLY]]，了解在某些源被预处理的情况下如何处理，以及想要在IDE中使用原始源又该如何处理
***** Imported Libraries
1. 命令: add_library(<name> <SHARED|STATIC|MODULE|OBJECT|UNKNOWN> IMPORTED [GLOBAL])
2. 一个 [[IMPORTED library target]] 引用一个位于项目外部的库文件,不会生成规则来构建它, 并且 [[IMPORTED]] 目标属性是 true 
3. <name>的范围只在创建它的目录中，但GLOBAL选项扩展了它的可见性, 以至于它可以像在项目中构建的任何目标一样被引用
4. 导入库对于像 [[target_link_libraries]]（）这样的命令的方便引用很有用
5. 有关导入的库的详细信息通过设置名称以IMPORTED_和INTERFACE_开头的属性指定
6. 最重要的属性是 [[IMPORTED_LOCATION]]（及其预配置变体[[IMPORTED_LOCATION_ <CONFIG>]]），它指定主库文件在磁盘上的位置。有关更多信息，请参阅 IMPORTED_ * 和 INTERFACE_ * 属性的文档
***** Object Libraries
1. 命令: add_library(<name> OBJECT <src>...)
2. 对象库的特点是,对象库编译源文件，但不会将其对象文件存档或链接到库中,即,对象库不能被链接
3. 相反，由add_library（）或add_executable（）创建的其他目标可以使用形式为$ <TARGET_OBJECTS：objlib>的表达式引用对象作为源,其中,objlib是一个对象库的名
4. 例如:
#+BEGIN_SRC 
	add_library(... $<TARGET_OBJECTS:objlib> ...)
	add_executable(... $<TARGET_OBJECTS:objlib> ...)
#+END_SRC
该例子给出的代码,将objlib的对象文件包含在一个库和一个可执行文件中
1. 对象库可能只包含编译，头文件和其他不会影响正常库链接的源文件（例如.txt）
2. 它们可能包含生成此类源的自定义命令，但不包含PRE_BUILD，PRE_LINK或POST_BUILD命令
3. 一些本地构建系统可能不喜欢只有对象文件的目标，所以考虑将至少一个真实的源文件添加到任何引用$ <TARGET_OBJECTS：objlib>的目标
***** Alias Libraries
1. 命令: add_library(<name> ALIAS <target>)
2. 创建一个 [[Alias Target]] 使得<name>可以用于在后续命令中引用<target>
3. <name>不会作为一个 make target 出现在 generated buildsystem 中
4. <target>可能不是一个[[Imported Target]] 或 ALIAS
5. ALIAS目标可以用作可链接的目标，也可以用作从中读取属性的目标
6. 可以使用 if(TARGET) 子命令测试 Alias_Target的存在性
7. <name>不能用来修改<target>的属性，也就是说，它不能用作 [[set_property]]（），[[set_target_properties]]（），[[target_link_libraries]]（）等的操作数
8. 一个ALIAS目标可能不能被安装或导出
***** Interface Libraries
1. 命令: add_library(<name> INTERFACE [IMPORTED [GLOBAL]])
2. 作用: 创建一个 [[Interface Library]]
3. 一个 INTERFACE 库目标不会直接创建构建输出，尽管它可能具有设置的属性，并且可以安装，导出和导入
4. 通常使用以下命令将INTERFACE_ *属性填充到接口目标上：
   1. [[set_property]]()
   2. [[target_link_libraries]](INTERFACE)
   3. [[target_include_directories]](INTERFACE)
   4. [[target_compile_options]](INTERFACE)
   5. [[target_compile_definitions]](INTERFACE)
   6. [[target_sources]](INTERFACE)
5. 像其他的目标一样,它被用作 [[target_link_libraries]]()的参数
6. 一个 INTERFACE 导入的目标也可以用这个签名来创建, 一个IMPORTED库目标引用在项目外定义的库
7. 目标名称的范围在创建它的目录中，但GLOBAL选项扩展了可见性, 它可以像在项目中构建的任何目标一样被引用,IMPORTED库对于像target_link_libraries（）这样的命令的方便引用很有用
**** <<add_executable>>
#+BEGIN_SRC 
泛型1: add_executable(<name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...])
#+END_SRC
- 作用: 使用源文件列表中指定的源文件来构建可执行目标<name>
- <name>对应于逻辑目标名字，并且在工程范围内必须是全局唯一的
- 默认情况下，可执行文件将会在构建树的路径下被创建，对应于该命令被调用的源文件树的路径。如果要改变这个位置，查看[[RUNTIME_OUTPUT_DIRECTORY]]目标属性的相关文档
- 果要改变最终文件名的<name>部分，查看[[OUTPUT_NAME]]目标属性的相关文档
- 如果指定了WIN32选项,那么, WIN32_EXECUTABLE 这个属性将会在目标被创建的时候被设置
- 如果指定了MACOSX_BUNDLE选项，对应的属性会附加在创建的目标上,查看MACOSX_BUNDLE目标属性的文档可以找到更多的细节
- 如果指定了EXCLUDE_FROM_ALL选项，对应的属性将会设置在被创建的目标上。查看EXCLUDE_FROM_ALL目标属性的文档可以找到更多的细节
- 源文件列表source1 [source2 ...] 到 add_executable 可以使用语法为$<...> 的 “生成器表达式”,更多信息查看 [[cmake-generator-expressions]]
#+BEGIN_SRC 
泛型2: add_executable(<name> IMPORTED [GLOBAL])
#+END_SRC

#+BEGIN_SRC 
泛型3: add_executable(<name> ALIAS <target>)
#+END_SRC
**** <<find_library>>
***** 命令:
 #+BEGIN_SRC 
      find_library (
      1. <VAR>
      2. name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
      3. [HINTS path1 [path2 ... ENV var]]
      4. [PATHS path1 [path2 ... ENV var]]
      5. [PATH_SUFFIXES suffix1 [suffix2 ...]]
      6. [DOC "cache documentation string"]
      7. [NO_DEFAULT_PATH]
      8. [NO_CMAKE_PATH]
      9. [NO_CMAKE_ENVIRONMENT_PATH]
      10. [NO_SYSTEM_ENVIRONMENT_PATH]
      11. [NO_CMAKE_SYSTEM_PATH]
      12. [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH]
      15. )
 #+END_SRC
***** 参数解析:
1. <VAR>: 存储查找结果,如果找到了库文件,则将该文件(带绝对路径)存储在该变量内,如果没找到,该变量的值为<VAR>-NOTFOUND
2. name | NAMES name1 [name2 ...] [NAMES_PER_DIR] 
   1. name: 指定查找一个库
   2. NAMES: 指定查找一个或者更多个待搜索库的名字,当给NAMES选项赋予多个值时，默认情况下这个命令会一次考虑一个名字并搜索每个目录
   3. NAMES_PER_DIR选项告诉该命令一次考虑一个目录，并搜索其中的所有名称
   4. 给予NAMES选项的每个库名首先被认为是库文件名，然后考虑平台特定的前缀（例如lib）和后缀（例如.so）,因此可以直接指定libfoo.a等库文件名
3. [HINTS path1 [path2 ... ENV var]]
   1. 指明除了默认位置之外,还要搜索的目录
   2. ENV var 子选项从系统环境变量中读取路径
4. [PATHS path1 [path2 ... ENV var]]
   1. 指明除了默认位置之外,还要搜索的目录
   2. ENV var 子选项从系统环境变量中读取路径
5. [PATH_SUFFIXES suffix1 [suffix2 ...]]
   1. 指定补充子目录,如此便会检查每个搜索路径下面含有补充子目录的目录,比如: /home/ljj/t1 是PATHS中的指定搜索的目录,那么默认会到该路径下面搜索,但是不会搜索/home/ljj/t1/tmp
   2. 如果给出该选项为 tmp, 除了到 /home/ljj/t1下面搜索,还会到/home/ljj/t1/tmp下面搜索
6. [DOC "cache documentation string"]
   1. 之后的参数用来作为cache中的注释字符串
7. NO_DEFAULT_PATH: 如果指定了该选项，那么搜索的过程中不会有其他的附加路径,如果没有指定该选项，搜索过程如下：
   1. 搜索在cmake-specific cache 变量中指定的路径, 从命令行以-DVAR=value的形式传入,这些值被解释为 [[lists]] 如果传递了 NO_CMAKE_PATH，可以跳过这个路径的搜索
   2. 
8. NO_CMAKE_PATH: 默认会搜索cmake特有的cache变量中被指定的路径(这些变量是在用cmake命令行时，通过-DVAR=value指定的变量),如果指定了该选项,则跳过该搜索路径,但是还包括如下的路径
   1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 [[CMAKE_PREFIX_PATH]] 中的每一个前缀
   2. [[CMAKE_LIBRARY_PATH]]
   3. [[CMAKE_FRAMEWORK_PATH]]
9. NO_CMAKE_ENVIRONMENT_PATH: 默认会搜索cmake特有的环境变量中被指定的路径,这是用户在shell配置中设置的变量,如过指定了该选项, 则跳过该搜索路径,但是还包括如下的路径
   1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 CMAKE_PREFIX_PATH 中的每一个前缀
   2. CMAKE_LIBRARY_PATH
   3. CMAKE_FRAMEWORK_PATH
10. NO_SYSTEM_ENVIRONMENT_PAT: 默认会搜索标准的系统环境变量,如果指定了该选项，这些环境变量中的路径会被跳过,但是搜索的路径还包括：PATH LIB
11. NO_CMAKE_SYSTEM_PATH: 默认会搜索当前系统平台文件中定义的cmake变量,如果指定了该选项,这些变量中的路径将会被跳过,但是还包括如下的路径
    1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 [[CMAKE_SYSTEM_PREFIX_PATH]] 中的每一个前缀
    2. [[CMAKE_SYSTEM_LIBRARY_PATH]]
    3. [[CMAKE_SYSTEM_FRAMEWORK_PATH]]
12. [CMAKE_FIND_ROOT_PATH_BOTH | ONLY_CMAKE_FIND_ROOT_PATH | NO_CMAKE_FIND_ROOT_PATH]



   6. 搜索由PATHS或者精简版命令中指定的路径 
如果找到了库文件,搜索过程将不再重复，除非该变量被清空,如果没有找到库文件,下次使用相同变量调用find_library()命令时，搜索过程会再次尝试

       * 如果找到的库是一个框架，那么<VAR>将被设置为框架<fullPath> /A.framework的完整路径。当框架的完整路径被用作库时，CMake将使用-framework A和-F <fullPath>将框架链接到目标
       * 


       * CMake变量[[CMAKE_FIND_ROOT_PATH]]指定一个或多个目录作为所有其他搜索目录的前缀
       * [[CMAKE_SYSROOT]]变量也可以用来指定一个目录作为前缀
       * 默认情况下，首先搜索CMAKE_FIND_ROOT_PATH中列出的目录,然后搜索CMAKE_SYSROOT目录，然后搜索非根目录的目录。默认行为可以通过设置[[CMAKE_FIND_ROOT_PATH_MODE_LIBRARY]]进行调整
       * 在13中所示的行为可以通过下面的参数覆盖
         1. CMAKE_FIND_ROOT_PATH_BOTH: 按照13所述的顺序搜索
         2. ONLY_CMAKE_FIND_ROOT_PATH: 不使用CMAKE_FIND_ROOT_PATH变量
         3. NO_CMAKE_FIND_ROOT_PATH: 只搜索re-rooted目录以及[[CMAKE_STAGING_PREFIX]]下的目录
       * 默认的搜索顺序的设计逻辑是按照使用时从最具体到最不具体。通过多次调用find_library命令以及NO_*选项，可以覆盖工程的这个默认顺序
       * 如果设置了[[CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX]]变量，所有的搜索路径将被正常测试，附带后缀，并且所有匹配的lib /替换为lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/
         1. 如果[[FIND_LIBRARY_USE_LIB32_PATHS]]全局属性被设置，所有的搜索路径将被正常测试，32 /附加，lib /所有匹配替换为lib32 /。如果至少启用了project（）命令支持的一种语言，则会自动为已知需要的平台设置此属性
         2. 如果[[FIND_LIBRARY_USE_LIB64_PATHS]]全局属性被设置，所有的搜索路径将被正常地测试，64 /追加，并且所有匹配的lib /替换为lib64 /。如果至少启用了project（）命令支持的一种语言，则会自动为已知需要的平台设置此属性
       * 变量CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX将覆盖FIND_LIBRARY_USE_LIB32_PATHS，FIND_LIBRARY_USE_LIBX32_PATHS和FIND_LIBRARY_USE_LIB64_PATHS全局属性
**** <<macro>> 
#+BEGIN_SRC 
    1. macro(<name>  [arg1 [arg2 [arg3 ...]]])
    2. COMMAND1(... arg1 ...)
    3. COMMAND1(... arg2 ...)
    4. COMMAND1(... arg3 ...)
    5. COMMAND1(... ARGC ...)
    6. COMMAND2(... ARGV1 ...)
    7. COMMAND3(... ARGV2 ...)
    8. ......
    9. COMMAND4(... ARGVN ...)
   10. endmacro(<name>)
#+END_SRC         
1. 作用: 定义一个名为<name>的宏

2. 调用宏示例:
#+BEGIN_SRC 
   1. 在cmake/xxx.make中给出如下宏定义
   2. macro(macro_test arg1 arg2)
   3. message(STATUS "ARGC=${ARGC}")                                               
   4. message(STATUS "ARGV0=${ARGV0}")                                             
   5. message(STATUS "ARGV1=${ARGV1}")                                             
   6. message(STATUS "ARGV2=${ARGV2}")                                             
   7. message(STATUS "ARGN=${ARGN}")                                               
   8. endmacro(macro_test)     
   9. 
   10. 在CMakeLists.txt中给出如下代码
   11. include(cmake/xxx.make)
   12. macro_test("hello" "word" "hi")
#+END_SRC
结果: 
   1. ARGC = 3
   2. ARGV0 = hello
   3. ARGV1 = world
   4. ARGV2 = hi
   5. ARGV =  hello;world;hi
   6. ARGN = hi

参数说明: 假设存在宏定义 macro(T arg1 arg2), 调用 T("t1" "t2" "t3" "t4"),
   1. ARGC 记录传入参数的个数: 4
   2. ARGV0: 记录第1个传入参数的值: t1 
   3. ARGV1: 记录第2个传入参数的值: t2
   4. ARGV2: 记录第3个传入参数的值: t3
   5. ARGV3: 记录第4个传入参数的数值: t4
   6. ARGV: 记录传入的所有参数列表: t1;t2;t3;t4
   7. ARGN: 记录超出宏定义参数的那些参数: t3;t4

   宏参数(如ARGV,ARGC)不是变量,而if(<variabes>)要求一个变量,这意味着if(DEFINED ARGV1)的写法是错误的,
可以书写为if(DEFINED ${ARGV1}),通常的做法是先使用set(list_var "${ARGV1}")将宏参数赋值给一个变量,然后用这个变量去传递给if(DEFINED list_var)

   宏不等同于编程语言里面的函数,宏不允许递归调用  

6. macro() 与 [[function]]() 的区别在于: 在宏中设置的的变量在外部被访问到,而在函数中设置的变量是局部的
**** <<function>>
#+BEGIN_SRC 
          1. function(<name>  [arg1 [arg2 [arg3 ...]]])
      	  2. COMMAND1(... arg1 ...)
      	  3. COMMAND1(... arg2 ...)
      	  4. COMMAND1(... arg3 ...)
          5. COMMAND1(... ARGC ...)
          6. COMMAND2(... ARGV1 ...)
          7. COMMAND3(... ARGV2 ...)
	        8. ......
       	  9. COMMAND4(... ARGVN ...)
          10. endfunction(<name>)
#+END_SRC
作用: 定义一个名为<name>的函数

function()与[[macro]]()的区别: 在宏中设置的的变量在可以在外部被访问到,而在函数中设置的变量是局部的,外部无法访问

函数的语法以及参数的传递同macro()别无二致,参考它即可

	想要使得函数内部定义的变量可以被外部访问到也有可行的方法: function(T tmp)  set(${tmp} "hello" PARENT_SCOPE)  endfunction(T) 
外部就可以 T(V2)message(STATUS "V2=${V2}"),返回hello,注意set(${tmp} ... PARENT_SCOPE)的写法(必须这样写),tmp想象成C语言中的函数
传入指针和传入变量的问题就可以理解为什么是${tmp}而不是tmp了,使用 PARENT_SCOPE 是因为函数会构建一个局部作用域

说明: 除非函数 <name> 被调用,否则在function()以及endfunction()之间的命令不会被调用

注意: 函数内部的变量应当让他外部不可见,如果非要让外部可见,那么最好使用macro
**** <<set>>
作用: 为 普通变量,cache变量,环境变量 赋值,请参阅 [[cmake-language(7)]] 变量 文档以了解正常变量和缓存条目的范围和交互
说明: <value>...标识此命令需要零个或者多个参数,若给出多个参数(set(tmp 2 GREATER 1)),则这些参数被连接成一个list的形式(2;GREATER;1),零个参数将会导致正常的变量被隐式的 [[unset]] 掉
***** Set Normal Variable
 #+BEGIN_SRC 
 set(<variable> <value>... [PARENT_SCOPE])
 #+END_SRC
1. 不使用 PARENT_SCOPE 的情况下: 当前目录中定义的变量只能在: 当前目录, 子目录, 子目录的子目录...  中使用,无法传递到其父目录中使用
2. 使用 PARENT_SCOPE 的情况下:  当前目录中定义的变量有且只能在其直接父目录中使用(注意:在当前目录无法使用,在其子目录无法使用,在其子目录的子目录无法使用,在其父目录的父目录无法使用 

备注: 实现变量全局共享的另外一个方法是使用 [[set_property]] 命令
***** Set Environment Variable
#+BEGIN_SRC 
set(ENV{<variable>} <value>...)
#+END_SRC 
作用: 将当前进程环境变量设置为给定值
示例: set(ENV{[[CC]]} "gcc")
***** Set Cache Entry
#+BEGIN_SRC 
set(<variable> <value>... CACHE <type> <docstring> [FORCE])
#+END_SRC
- 持久缓存的有关知识可参考 [[Cache]]

- 作用: 设置给定的缓存<变量>（缓存条目）

- 由于缓存条目旨在提供用户可设置的值，因此默认情况下不会覆盖现有的缓存条目,使用 FORCE 选项覆盖现有条目

- <type> 必须是下面指定中的一个:
- BOOL: 布尔ON / OFF值, cmake-gui（1）提供了一个复选框
- FILEPATH: 磁盘上文件的路径。 cmake-gui（1）提供了一个文件对话框
- PATH: 磁盘上目录的路径。 cmake-gui（1）提供了一个文件对话框
- STRING: 一行文字。如果设置了STRINGS缓存条目属性，cmake-gui（1）将提供一个文本字段或一个下拉选择
- INTERNAL: 一行文字。 cmake-gui（1）不显示内部条目。它们可能被用来在变量间持久地存储变量。这种类型的使用意味着FORCE。

- 必须将<docstring>指定为一行文本，提供cmake-gui（1）用户呈现选项的快速摘要

- 如果缓存条目在调用之前不存在，或者给出FORCE选项，则缓存条目将被设置为给定值。而且，当前作用域中的任何正常变量绑定都将被删除，以将新缓存的值显示给任何紧随其后的计算

- 高速缓存条目可能在调用之前存在，但如果用户通过-D <var> = <value>选项在cmake（1）命令行上创建，而没有指定类型，则不会设置类型集。
在这种情况下，set命令将添加类型。此外，如果<type>是PATH或FILEPATH，并且命令行上提供的<value>是相对路径，则set命令将把路径视为相对于当前工作目录并将其转换为绝对路径。
**** <<set_property>>
**** <<set_directory_properties>>
**** <<get_property>>
**** <<get_cmake_property>>
**** <<get_directory_property>>
**** <<foreach>>
#+BEGIN_SRC 
foreach(loop_var arg1 arg2 ...)
  COMMAND1(ARGS ...)
  COMMAND2(ARGS ...)
  ...
endforeach(loop_var)
#+END_SRC
    在foreach和匹配endforeach之间的所有命令都被记录而不被调用,一旦计算到了endforeach，
在foreach命令中列出的每个参数都会调用记录的命令列表一次,在循环的每次迭代之前，${loop_var} 将被设置为一个具有列表中当前值的变量

示例:
#+BEGIN_SRC 
    1) set(mylist arg1 arg2 arg3)
    2) foreach(loop_var ${mylist})
    3) message(STATUS “${loop_var}”)
    4) endforeach(loop_var)	  
#+END_SRC
返回： arg1 arg2 arg3


#+BEGIN_SRC 
foreach(loop_var RANGE total)
foreach(loop_var RANGE start stop [step])
#+END_SRC
Foreach也可以迭代生成的数字范围。这个迭代有三种类型：
- 指定单个数字时，范围将包含0到“total”的元素
- 指定两个数字时，范围将包含从第一个数字到第二个数字的元素
- 第三个可选数字是用于从第一个数字迭代到第二个数字的增量

示例:
#+BEGIN_SRC 
     1) set(result 0)
     2) foreach(_var RANGE 0 100)
     3) math(EXPR result "${result}+${_var}")
     4) endforeach()
     5) message("from 0 plus to 100 is:${result}")
     6) 
#+END_SRC
返回： 5050
备注：如果是foreach(_var RANGE 30),则表示从0~30,如果是foreach(_var RANGE 4 10 2),则表示从4~10，步长为2

#+BEGIN_SRC 
foreach(loop_var IN [LISTS [list1 [...]]]
                    [ITEMS [item1 [...]]])
#+END_SRC
- 迭代 items 的精确列表
- LISTS 选项列出要被遍历的列表值变量,包括空元素（一个空字符串是一个零长度列表）。 （注意宏参数不是变量。）
- ITEMS 选项结束参数解析并在迭代中包含其后面的所有参数
*** Project Commands
**** <<target_include_directories>>
#+BEGIN_SRC 
target_include_directories(<target> [SYSTEM] [BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> [items1...]
  [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
#+END_SRC
1. 作用： 当编译一个给定目标时，指定编译过程中使用到的 include directory
2. 要求： <target> 必须是一个已经被 [[add_executable]]() 或者 [[add_library]]()创建的目标，同时，不能是一个 [[IMPORTED]] 目标
3. [SYSTEM]: 如果指定了该选项，就等于告诉编译器，这个目录是作为 system include directory
4. [BEFORE]： 如果指定该选项，则内容将被预置到属性而不是被追加
5. <INTERFACE|PUBLIC|PRIVATE> [items1...]：指定参数的scope
   1. PUBLIC和PRIVATE items 将会构成<target>的[[INCLUDE_DIRECTORIES]]属性
   2. PUBLIC和INTERFACE items 将会构成<target>的[[INTERFACE_INCLUDE_DIRECTORIES]]属性
6. 如果[SYSTEM] 同 PUBLIC 或者 INTERFACE 一起被指定，将会构成<target>的[[INTERFACE_SYSTEM_INCLUDE_DIRECTORIES]]属性
6. 被指定的 include directory 可能是绝对路径或者是相对路径
7. 该命令的参数可能会使用语法为$<...>的“generator expressions”，详情查阅[[cmake-generator-expressions(7)]]
**** <<target_link_libraries>>
作用： 当链接一个给定的目标时，指定使用到的library或者flags
***** Overview
#+BEGIN_SRC 
target_link_libraries(<target> ... <item>... ...)
#+END_SRC
1. <target>： 必须已经在当前目录中使用 [[add_executable]]()或者[[add_library]]()完成创建
2. <item>： 每个item可能是下面的情况
   1. A library target name
   2. A full path to a library file
   3. A plain library name:
   4. A link flag
   5. A debug, optimized, or general keyword immediately followed by another <item>
***** Libraries for a Target and/or its Dependents
#+BEGIN_SRC 
target_link_libraries(<target>
                      <PRIVATE|PUBLIC|INTERFACE> <item>...
                     [<PRIVATE|PUBLIC|INTERFACE> <item>...]...)
#+END_SRC
1. PUBLIC, PRIVATE and INTERFACE 关键字用于指明在一个命令中的 link dependencies 和 link interface
2. 标识 PUBLIC 的Libraries and targets 会被链接到 link interface,并且成为link interface的一部分
3. 标识 PRIVATE 的Libraries and targets 会被链接到 link interface,但是不会成为link interface的一部分
4. 标识 INTERFACE 的 Libraries and targets 会被添附到 link interface,但是不用于链接<target>
***** Libraries for both a Target and its Dependents
#+BEGIN_SRC
target_link_libraries(<target> <item>...)
#+END_SRC
说明： 从文档的说明中，该用法同 target_link_libraries(<target> LINK_PUBLIC <lib>...)貌似一致
***** Libraries for a Target and/or its Dependents (Legacy)
#+BEGIN_SRC 
target_link_libraries(<target>
                      <LINK_PRIVATE|LINK_PUBLIC> <lib>...
                     [<LINK_PRIVATE|LINK_PUBLIC> <lib>...]...)
#+END_SRC
1. LINK_PUBLIC and LINK_PRIVATE modes 可以用于在一个命令中指明 the link dependencies and the link interface
2. 标识LINK_PUBLIC的Libraries and targets会被链接到 [[INTERFACE_LINK_LIBRARIES]] 并成为其中的一部分
3. 标识LINK_PRIVATE的Libraries and targets会被链接到 [[INTERFACE_LINK_LIBRARIES]] 但是不会成为其中的一部分
4. 如果 policy CMP0022 的值不是NEW,他们也会成为 [[LINK_INTERFACE_LIBRARIES]] 的一部份
***** Libraries for Dependents Only (Legacy)
#+BEGIN_SRC 
target_link_libraries(<target> LINK_INTERFACE_LIBRARIES <item>...)
#+END_SRC
1. LINK_INTERFACE_LIBRARIES模式添加这个库到[[INTERFACE_LINK_LIBRARY]]属性，而不是使用这个库来进行链接
2. 此用法仅用于兼容性，优先选择INTERFACE模式
***** Cyclic Dependencies of Static Libraries
***** Creating Relocatable Packages
**** <<define_property>>
**** <<set_source_files_properties>>
#+BEGIN_SRC 
set_source_files_properties([file1 [file2 [...]]]
                            PROPERTIES prop1 value1
                            [prop2 value2 [...]])
#+END_SRC
- 源文件有一些影响它们如何构建的属性,这些属性可以在 [[Properties on Source Files]] 下面查阅

- 该命令使用键/值配对列表来设置这些源文件相应的属性

- 源文件属性仅对在同一目录（CMakeLists.txt）中添加的目标可见

- 示例:
#+BEGIN_SRC 
set_source_files_properties(hello.c world.c
                           PROPERTIES COMPILE_FLAGS -DDEBUG
)
#+END_SRC
**** <<set_target_properties>>
**** <<get_source_file_property>>
**** <<get_target_property>>

*** CTest Commands
*** Deprecated Commands
** WAITTING [#C] Theme:cmake-developer                              :@Cmake:
*** Introduction
*** Adding Compile Features
*** Help
**** T Markup Constructs
**** TCMake Domain
**** TCross-References
**** TStyle
***** TStyle: Section Headers
***** TStyle: Whitespace
***** TStyle: Line Length
***** TStyle: Prose
***** TStyle: Starting Literal Blocks
***** TStyle: CMake Command Signatures
***** TStyle: Boolean Constants
***** TStyle: Inline Literals
***** TStyle: Cross-References
***** TStyle: Referencing CMake Concepts
***** TStyle: Referencing CMake Domain Objects
*** TModules
**** Module Documentation
**** TFind Modules
***** TStandard Variable Names
***** TA Sample Find Module
** WAITTING [#C] Theme:cmake-generator-expressions(7)               :@Cmake:
*** Introduction
*** T Logical Expressions
*** T Informational Expressions
*** TOutput Expressions
** WAITTING [#C] Theme:cmake-generators(7)                          :@Cmake:
*** Introduction
*** CMake Generators
**** Command-Line Build Tool Generators
***** Makefile Generators
***** Ninja Generator
**** IDE Build Tool Generators
***** Visual Studio Generators
***** Other Generators
*** TExtra Generators
** WAITTING [#C] Theme:cmake-language(7)                            :@Cmake:
*** Organization
**** Directories
**** Scripts
**** Modules
*** Syntax
**** Encoding
**** Source Files
**** Command Invocations
**** Command Arguments
***** Bracket Argument
***** Quoted Argument
***** Unquoted Argument
**** Escape Sequences
**** <<Variable References>>
- 变量引用的格式为$ {variable_name}，并在引用的参数或非引用的参数中进行评估

- 变量引用被变量的值替换，或者如果变量未被设置，则由空字符串替换

- 变量引用可嵌套，并从内向外进行计算，例如， ${outer_${inner_variable}_variable}

- 环境变量引用的形式为$ENV {VAR}，并在与普通变量引用相同的上下文中进行计算
**** Comments
***** Bracket Comment
***** Line Comment
*** Control Structures
**** Conditional Blocks
**** Loops
**** Command Definitions
*** <<Variables>>
1. 在 cmake 的语法中,变量是基本的存储单元
2. 变量的值总是字符串类型
3. [[set]]() 和 [[unset]]() 命令用于设置以及清除变量的值(当然了,也有其他的一些命令含有修改变量值的语义)
4. 变量名是大小写敏感的,几乎可以由任何文本组成,但是建议只使用_和-来组合变量
5. 变量有动态的范围,每个使用set或者unset赋值的变量实际上是在当前范围内创建了一个绑定,当前范围指:
   1. Function Scope: 由 [[function]]() 命令定义的一个函数, 这个函数内部涉及的变量,只在函数内部以及函数的嵌套调用中可见
   2. Directory Scope: 源码树中的每个目录都有自己的变量绑定,在处理当前目录的CMakeLists.txt文件之前，CMake会复制其父目录中定义的所有变量绑定
   3. Persistent <<Cache>>(持久缓存):
      1. CMake存储一组单独的“缓存”变量或“缓存条目”，它们的值在项目构建树中的多个运行中保持不变。
      2. 高速缓存条目具有仅由显式请求修改的独立绑定范围，例如由[[set]]（）和unset（）命令的CACHE选项修改
6. 变量的引用过程:
   1. 当计算 [[Variable References]] 时，CMake首先搜索函数调用堆栈（如果有的话）进行绑定，然后回退到当前目录范围中的绑定（如果有的话）
   2. 如果找到“set”绑定，则使用它的值。如果找到“unset”绑定，或者没有找到绑定，CMake就会搜索一个缓存条目
   3. 如果找到缓存条目，则使用其值。否则，变量引用计算为空字符串。
*** <<Lists>>
** WAITTING [#C] Theme:cmake-server(7)                              :@Cmake:
** WAITTING [#C] Theme:cmake-modules(7)                             :@Cmake:
** WAITTING [#C] Theme:cmake-packages(7)                            :@Cmake:
** WAITTING [#C] Theme:cmake-policies                               :@Cmake:
1. introduction
   1. 开发中会遇到这样的事,使用cmake开发了一个项目,突然一不小心在系统升级时将cmake的版本也升级了
   2. 新版本的cmake相比于老版本的cmake,某些命令或者变量带来了行为上的改变,当前的项目在编译时会出现一些警告,甚至是行为不符的现象
   3. 在cmake中,为了解决这样的情况,提供了一种称为policy的机制,cmake的设计者每次发布新版本时,如果发现新版本相对老版本带来了某些行为上的改变,就会顺带发布一个CMP_<NNNN>的policy
   4. 每个CMP_<NNNN>中都会"旧行为"和"新行为",以及引入该policy的原因
   5. 在工程中可以设置各种policy来选择期望的行为
Blog creation time:[2017-11-08 三 13:28]
** WAITTING [#C] Theme:cmake-properties                             :@Cmake:
*** <<Properties of Global Scope>>
    1. <<ENABLED_LANGUAGES>>
        1. 存储当前使能的语言列表
        2. 由命令[[enable_language]]配置
        3. 只读
*** <<Properties on Targets>>
**** <<POSITION_INDEPENDENT_CODE>>
1. 该变量的属性决定了将要创建的可执行文件或者共享库是否位置独立
2. 如果一个库是 SHARD 和 MODULE,那么这个属性自动设置为true
3. 该属性值被变量 [[CMAKE_POSITION_INDEPENDENT_CODE]] 的值初始化
4. 参考 [[add_library]]()
*** <<Properties on Directories>>
*** <<Properties on Source Files>>
备注: 使用命令 [[set_source_files_properties]]() 以及 [[get_source_files_properties]]() 来操作这些源文件的属性
**** <<COMPILE_FLAGS>>
1. 当编译这个源文件时,该属性的 flags 会被添加到 compile flags 中
2. 使用 [[COMPILE_DEFINITIONS]] 属性来传递额外的预处理器定义
3. 该属性的内容可能使用语法为 $<...> 的“generator expressions”, 详情查阅 [[cmake-generator-expressions(7)]]
4. Xcode不支持per-config per-source设置，所以依赖于生成配置的表达式不被该 generator 所允许
**** <<GENERATED>>
1. 这个源文件是否是作为构建过程的一部分生成的?
2. 如果源文件是由构建过程生成的，CMake将在依赖性检查等方面进行不同的处理,否则，有一个不存在的源文件可能会产生问题
**** <<LABELS>>
- 指定与源文件关联的文本标签列表
- 只有当源文件列在其LABELS属性也被设置的目标中时，该属性才有意义,目前没有指定其他的语义
**** <<COMPILE_DEFINITIONS>>
- 用于编译源文件的预处理器定义
- COMPILE_DEFINITIONS属性可以使用语法VAR或VAR = value设置为以分号分隔的预处理器定义列表
- 函数式定义不受支持
- CMake会自动为本地构建系统正确地转义值（注意，CMake语言语法可能需要转义才能指定一些值）
- 可以使用名称COMPILE_DEFINITIONS_ <CONFIG>在每个配置的基础上设置此属性，其中<CONFIG>是大写名称（例如“COMPILE_DEFINITIONS_DEBUG”）
- CMake会自动删除一些原生构建工具不支持的定义
- Xcode不支持源文件的预配置定义

- 大多数本地构建工具对逃脱某些值的支持很差。 CMake在许多情况下都有解决方法，但有些值可能无法正确传递。
如果某个值似乎没有正确转义，则不要试图通过向该值添加转义序列来解决该问题。 
CMake的未来版本可能会打破您的解决方案，从而改善了逃生支持。应该考虑在（配置的）头文件中定义宏。然后报告限制。已知的限制包括：
#          - broken almost everywhere
;          - broken in VS IDE 7.0 and Borland Makefiles
,          - broken in VS IDE
%          - broken in some cases in NMake
& |        - broken in some cases on MinGW
^ < > \"   - broken in most Make tools on Windows
CMake不会完全拒绝这些值，因为它们在某些情况下有效。谨慎使用。
*** Properties on Tests
*** Properties on Cache Entries
*** Properties on Installed Files
*** Deprecated Properties on Directories
    1. COMPILE_DEFINITIONS_<CONFIG>
    2. TEST_INCLUDE_FILE
*** Deprecated Properties on Targets
    1. COMPILE_DEFINITIONS_<CONFIG>
    2. POST_INSTALL_SCRIPT
    3. PRE_INSTALL_SCRIPT
*** Deprecated Properties on Source Files
     1. COMPILE_DEFINITIONS_<CONFIG>
 Blog creation time:[2017-11-09 四 15:16]
** WAITTING [#C] Theme:cmake-qt(7)                                  :@Cmake:
** WAITTING [#C] Theme:cmake-toolchains                             :@Cmake:
*** <<Introduction>>
    1. CMake使用工具链来进行编译,链接库,创建归档，以及使用一些任务去进行构建
    2. 命令[[project]]()以及 [[enable_language]]()中给出的语言决定了采用何种工具链工具
    3. 在常规构建中，CMake基于系统自检和缺省自动为宿主构建决定工具链
    4. 在交叉编译的情况下，可以通过相关的编译器和工具路径来指定工具链文件
*** <<Languages>>
    1. 在使用[[project]]()命令时,如果设置了LANGUAGE参数,或者使用[[enable_language]](),则内置变量[[CMAKE_C_COMPILER]]就会被设置为指定的语言,如果没有做出任何设置,则会默认隐式使用缺省的C以及CXX
    2. 采用的语言决定了一些信息，如编译器的供应商和版本，目标架构和位宽，相应工具的位置等
    3. 当语言被确定好以后，相应的就确定了使用 何种编译器,链接器
    4. 全局属性[[ENABLED_LANGUAGES]]包含当前启用的语言
    5. 通过目标中源文件的语言来计算采用的链接器,在静态库的情况下，也通过依赖库的语言来计算,CMake做出的选择可能被目标属性 [[LINKER_LANGUAGE]] 重写
*** <<Variables and Properties>>
    1. 几个关于工具链的语言组件变量会被使用
    2. [[CMAKE_TOOLCHIAIN_FILE]] 提供一个交叉编译的脚本
    3. [[CMAKE_SYSTEM_NAME]] 目标机上运行的操作系统的名称
    4. [[CMAKE_SYSTEM_PROCESSOR]] 目标机的硬件架构，例如ARM，X86
    5. [[CMAKE_C_COMPILER]] 指明了<LANG>语言的编译器所在的路径
    6. [[CMAKE_C_COMPILER_ID]] 作为编译器的标识
    7. [[CMAKE_C_COMPILER_VERSION]] 标识编译器的版本
    8. [[CMAKE_C_FLAGS]] 当编译一个特定语言的文件时,该变量中给出的选项将会被作为编译时的选项
    9. [[CMAKE_FIND_ROOT_PATH]] 搜索路径
    10. [[CMAKE_SYSROOT]]  搜索路径
*** Toolchain Features
*** Cross Compiling
    1. <<CMAKE_TOOLCHIAIN_FILE>> 这应当是CMake交叉编译中最重要的概念了,CMake不知道你的目标平台是什么、用什么编译器、如何编译等等，所以你需要提供预设一些变量到CMake
    2. 其中最为方便的一个方法就是将相关的变量设置都放进一个文件(cmake脚本)中去，然后将该文件通过CMAKE_TOOLCHIAIN_FILE传递给CMake 
    3. 传递交叉编译脚本的方法: cmake -D CMAKE_TOOLCHIAIN_FILE="/path/to/my-cmake-toolchain-file" ..   (当然,也可以在CMakeList.txt中直接给出)
    4. <<目标机>>: 运行代码的实体机,比如stm32f407zgt6 
    5. <<宿主即>>: 也叫开发平台,比如linux,windows
    6. 交叉编译: 在宿主机上开发程序,烧录到目标机上运行
    7. cmake是无法自动判断出目标机的上运行的系统的,因此必须需要我们通过变量 [[CMAKE_SYSTEM_NAME]] 指定
    8. 在宿主机上交叉编译出来的可执行文件通常不能直接运行在宿主机上
    9. 交叉编译过程中不能使用宿主机上的原生头文件和库，而是需要用到一套专门针对目标机的头文件和库,如embi-arm-linux-xx
    10. 在交叉编译时(即指定了[[CMAKE_SYSTEM_NAME]]), [[CMAKE_CROSSCOMPILING]]变量将被设置为真值
    11. 稍微大一点的项目都会用到一些外部依赖库或者tool,CMake提供了 [[find_library]]() [[find_package]]() [[find_file]]() [[find_program]]() [[find_path]]()来进行外部依赖的搜索查找
    12. 变量[[CMAKE_FIND_ROOT_PATH]] 和 [[CMAKE_SYSROOT]] 指明了外部依赖的搜索路径,即所有find_*将在这两个变量指定的路径路径,以及宿主机相关的路径下搜索,当然了,可以限制只在某一路径下搜索,详情参考CMAKE_FIND_ROOT_PATH
 Blog creation time:[2017-11-08 三 09:40]
** WAITTING [#C] Theme:cmake-env-variables                          :@Cmake:
1. 设置环境变量set(ENV{CMAKE_C_FLAGS} "-O3 -Wall")
2. 查看环境变量message(STATUS "CMAKE_C_FLAGS: " $ENV{CMAKE_C_FLAGS})
3. Environment Variables that Control the Build
   1. CMAKE_CONFIG_TYPE
   2. CMAKE_MSVCIDE_RUN_PATH
   3. CMAKE_OSX_ARCHITECTURES
   4. LDFLAGS
   5. MACOSX_DEPLOYMENT_TARGET
4. Environment Variables for Languages
   1. ASM<DIALECT>
   2. ASM<DIALECT>FLAGS
   3. CC
   4. <<CFLAGS>>
      1. 如果CMAKE_C_FLAGS没有定义,则在编译c源文件时,该变量存储默认的编译flags
      2. 如果CMAKE_C_FLAGS没有定义,仅仅在首次配置CC的默认编译状态时,该变量才被cmake使用,之后,这个值存储在CMAKE_C_FLAGS中
      3. 如果定义了[[CMAKE_C_FLAGS]],不论是首次配置还是任意次配置CC的编译flags,该变量CFLAGS都会被忽略
   5. CSFLAGS
   6. CUDACXX
   7. CUDAFLAGS
   8. CUDAHOSTCXX
   9. CXX
   10. CXXFLAGS
   11. FC
   12. FFLAGS
   13. RC
   14. RCFLAGS
5. Environment Variables for CTest
   1. CMAKE_CONFIG_TYPE
   2. CTEST_INTERACTIVE_DEBUG_MODE
   3. CTEST_OUTPUT_ON_FAILURE
   4. CTEST_PARALLEL_LEVEL
   5. CTEST_USE_LAUNCHERS_DEFAULT
   6. DASHBOARD_TEST_FROM_CTEST
Blog creation time:[2017-11-08 三 09:39]
** WAITTING [#C] Theme:cmake-variables                              :@Cmake:
*** Variables that Provide Information
    1. <<CMAKE_CURRENT_LIST_DIR>>
       1. 含义: 当前正在处理的列表文件(CMakelists.txt)所在的目录路径
       2. 动态变量
       3. 如: /home/ljj/workspace/test5/dir/
    2. <<CMAKE_CURRENT_LIST_FILE>>
       1. 含义: 当前正在处理的列表文件(CMakeLists.txt)
       2. 动态变量
       3. 如:  /home/ljj/workspace/test5/dir/CMakeLists.txt
    3. <<PROJECT-NAME_BINARY_DIR>>
       1. 作用: 该变量的值是命令project(<PROJECT-NAME> ......)中指定的项目名的顶层 binary directory 目录的路径
       2. 使用场合: 当使用add_subdirectory()命令来连接几个工程时,该变量就十分有用
       3. 个人建议: PROJECT_BINARY_DIR指代的对象没有该变量指代的清楚明了,建议使用该变量
    4. <<PROJECT-NAME_SOURCE_DIR>>
       1. 作用: 该变量的值是命令project(<PROJECT-NAME> ......)中指定的项目名的顶层 source directory 目录的路径
       2. 使用场合: 当使用add_subdirectory()命令来连接几个工程时,该变量就十分有用
       3. 个人建议: PROJECT_SOURCE_DIR指代的对象没有该变量指代的清楚明了,建议使用该变量
    5. <<PROJECT-NAME_VERSION>>
       1. 作用:  该变量用于存储命令project(<PROJECT-NAME>  [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]......)中指定的VERSION
       2. 备注: cmake_policy
    6. <<PROJECT-NAME>_VERSION_MAJOR>>
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第1个号码<major>
    7. <<PROJECT-NAME_VERSION_MINOR>>
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第2个号码<minor>
    8. <<PROJECT-NAME>_VERSION_PATCH>>
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第3个号码<patch> 
    9. <<PROJECT-NAME>_VERSION_TWEAK>>
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第4个号码<tweak>
    10. <<PROJECT_DESCRIPTION>>
        1. 作用: 存储project命令中<DESCRIPTION>参数,项目描述信息
    11. <<PROJECT_NAME>>
        1. 作用: 该变量的值是命令project(<PROJECT-NAME> ......)中指定的项目名<PROJECT-NAME>
        2. 使用场合: 可以通过查询该变量得知项目的名字
*** Variables that Change Behavior
****  <<BUILD_SHARED_LIBS>>
1. 该变量如果设置为ON,则在全局范围内,[[ add_library]]() 默认创建的所有库均是 SHARD 库,除非明确的指出要创建一个STATIC库
2. 该变量经常在项目中最为一个 [[option]]() 以便项目的每一个用户能够决定它们是否想要使用静态库或者动态库构建系统


     2. <<CMAKE_BUILD_TYPE>>
        1. 作用: 指定 build tree 的 build type 
        2. 可能的值是: empty, Debug, Release, RelWithDebInfo and MinSizeRel
        3. 这个变量仅仅在 single-configuration generators 时才有意义
        4. 有很多预配置属性和变量,诸如 [[CMAKE_C_FLAGS_<CONFIG>]] , CMAKE_C_FLAGS_[DEBUG|RELEASE|RELWITHDEBINFO|MINSIZEREL]
        5. 例如,如果配置了某 build tree 的 build type 为Debug, CMake 会将 CMAKE_C_FLAGS_DEBUG 添加到 [[CMAKE_C_FLAGS]] 中去
     3. <<CMAKE_FIND_ROOT_PATH>>
        1. 在交叉编译时,该变量是十分有用的,比如,在给一个ARM处理器的移动设备做交叉编译，其中需要寻找libjpeg.so
        2. 假如使用find_package(JPEG) 在没有设置该变量的前提下,返回的是/usr/lib/libjpeg.so
        3. 这是有问题的，因为找到的这个so库只是给你的宿主机系统(例如一个x86的Ubuntu主机)服务的，不能用于arm系统
        4. 所以你需要告诉CMake去其它地方去查找,该变量就是干这个事的,它在文件系统层次给出了一个用于搜索的根
        5. 比如 [[set]](CMAKE_FIND_ROOT_PATH /home/ljj/stm32/embi-arm-linux-xx)
        6. 默认情况下,CMake首先会到/home/ljj/stm32/embi-arm-linux-xxx/usr/lib或者/home/ljj/stm32/embi-arm-linux-xx/lib等子目录下面搜索所有find_*命令给出的条目
        7. 如果没有找到(且设置了 [[find_package(BOTH)]] 的情况下),可以接着到 [[CMAKE_SYSROOT]] 列出的路径下搜索, 如果还是没有找到的话就到宿主机的相关目录下搜索
        8. 默认这个变量是空,交叉编译中应当对该变量进行设置
        9. 配置该变量的同时还应配置[[CMAKE_FIND_ROOT_PATH_MODE_PROGRAM]] , [[CMAKE_FIND_ROOT_PATH_MODE_LIBRARY]] , [[CMAKE_FIND_ROOT_PATH_MODE_INCLUDE]] , [[CMAKE_FIND_ROOT_PATH_MODE_PACKAGE]]
        10. 参考 [[Cross Compiling]]  [[CMAKE_SYSROOT]] 
     4. <<CMAKE_FIND_ROOT_PATH_MODE_LIBRARY>>
        1. 该变量用于控制 [[find_library]]()命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]]给出的路径下面搜索
        2. 如果设置为ONLY,那么,find_library() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
        3. 如果设置为NEVER,那么, find_library() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
        4. 如果设置为BOTH,那么,find_library() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
     5. <<CMAKE_FIND_ROOT_PATH_MODE_INCLUDE>>
        1. 该变量用于控制 [[find_file]](), [[find_path]]() 命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]] 给出的路径下面搜索
        2. 如果设置为ONLY,那么,find_file(),find_path() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
        3. 如果设置为NEVER,那么, find_file(),find_path() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
        4. 如果设置为BOTH,那么,find_file(),find_path() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
     6. <<CMAKE_FIND_ROOT_PATH_MODE_PACKAGE>>
        1. 该变量用于控制 [[find_package]]()命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]]给出的路径下面搜索
        2. 如果设置为ONLY,那么,find_package() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
        3. 如果设置为NEVER,那么, find_package() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
        4. 如果设置为BOTH,那么,find_package() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
     7. <<CMAKE_FIND_ROOT_PATH_MODE_PROGRAM>>
        1. 该变量用于控制 [[find_program]]()命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]]给出的路径下面搜索
        2. 如果设置为ONLY,那么,find_program() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
        3. 如果设置为NEVER,那么, find_program() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
        4. 如果设置为BOTH,那么,find_program() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
     8. <<CMAKE_INCLUDE_PATH>>
     9. <<CMAKE_INSTALL_PREFIX>>
        1. 该变量被命令[[install]]()使用到
        2. 当 make install 被调用 或者 使用命令install()时,这个变量的目录所示的路径将会被安装路径的后面
        3. 在UNIX下,这个变量默认是/usr/local,在window下,默认是c:/Program Files/${PROJECT_NAME}
        4. 该变量的使用方法: cmake -DCMAKE_INSTALL_PREFIX=usr/ .. 此时 make DESTDIR=/home/john install 后,软件的安装路径就是usr/home/john
        5. 备注: 当然了,该变量也可以在CMakeLists.txt中使用set进行配置,原则是如果用户在命令行使用-D定义了默认路径的话,就使用命令行的路径,否则就使用set设置的路径
        6. 通过判断 [[CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT]] 的值实现该变量的配置:
        7. if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
        8. [[set]](CMAKE_INSTALL_PREFIX "/my/default" CACHE PATH "..." FORCE)
     10. <<CMAKE_POLICY_DEFAULT_CMP_NNNN>>
         1. 作用: 存储某个policy的默认配置(OLD or NEW)
         2. 更改: cmake_policy(SET CMP0048 NEW)
         3. 说明: <NNNN>代表某个policy的编号,如0048,该编号具体是什么含义,参见cmake-policies
*** Variables that Describe the System
    1. <<CMAKE_SYSTEM_NAME>>
       1. [[目标机]]上运行的操作系统的名称,比如Linux,Android,如果你的嵌入式平台没有相关OS你即需要写成”Generic”
       2. 这是在toolchain脚本中必须要设置的变量,只有当CMAKE_SYSTEM_NAME这个变量被设置了，CMake才认为此时正在交叉编译
       3. 它会额外设置一个变量[[CMAKE_CROSSCOMPILING]]为TRUE
       4. 参考 [[CMAKE_TOOLCHIAIN_FILE]] 
    2. <<CMAKE_SYSTEM_PROCESSOR>>
       1. 代表[[目标机]]的硬件架构，例如ARM，X86
       2. 这个是可选项，但是在移动开发中很重要
*** Variables that Control the Build
    1. <<CMAKE_EXE_LINKER_FLAGS>>
       1. 作用: 存储创建可执行文件时用到的链接flags
       2. 这个变量中的flags将会在创建一个可执行文件时被使用
    2. <<CMAKE_POSITION_INDEPENDENT_CODE>>
	     1.该变量被用于初始化所有目标的  [[POSITION_INDEPENDENT_CODE]] 属性
       1. 该变量的值也被用于 [[try_compile]]()
    3. <<EXECUTABLE_OUTPUT_PATH>>
       1. 作用: 重新指定最终二进制目标的路径
       2. 设置: set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
       3. 备注: 一个重要的问题是,配置这个变量的这条指令应当写在哪个CMakeLists.txt中呢,其基本原则是在哪里 [[ADD_EXECUTABLE]] 或 [[ADD_LIBRARY]],如果需要改变目标存放路径,就在哪里加入上述的定义
       4. 相关: [[add_subdirectory]]()
    4. <<LIBRARY_OUTPUT_PATH>>
       1. 作用: 重新指定最终生成的共享库的路径
       2. 设置: set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
*** Variables for Languages
    1. <<CMAKE_<LANG>_COMPILER>>
       1. <<CMAKE_C_COMPILER>>
       2. 参考 [[Languages]]
    2. <<CMAKE_<LANG>_COMPILER_ID>>
       1. <<CMAKE_C_COMPILER_ID>>
       2. A short string unique to the compiler vendor
       3. 比如: set(CMAKE_C_COMPILER "ARMCC = ARM Compiler (arm.com)")
       4. 参考 [[Variables and Properties]]
    3. <<CMAKE_<LANG>_FLAGS>>
       1. <<CMAKE_C_FLAGS>>: 存储c编编译过程中的所有flags
          1. 可以通过[[add_compile_options]]命令以及[[add_definitions]]设置flags,但是不推荐,因为这两个命令设置的值对所有的编译器都有效.推荐使用set,它只对指定的编译器有效
       2. 该变量一旦定义,则[[CFLAGS]]将会被忽略,因此该变量的值在没有赋值之前为空
       3. 建议使用set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O3 -Wall")这种方式将CMAKE_C_FLAGS 设置为 -O3 -Wall (注意不是追加)
       4. 参考 [[Variables and Properties]]
*** Variables for CTest
*** Variables for CPack
 Blog creation time:[2017-11-08 三 09:24]
