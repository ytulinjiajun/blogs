* blogs-cmake-active
版本: 3.10.0-rc4
** WAITTING [#D] Theme:cmake-something			       :@Blog:@Cmake:
    SCHEDULED:<2017-11-08 三>
1. 网址: https://cmake.org/cmake/help/v3.10/ 
2. 查看 cmake 版本: cmake --version
Blog creation time:[2017-11-08 三 08:42]
** WAITTING [#D] Theme:cmake-buildsystem		       :@Blog:@Cmake:
    SCHEDULED:<2017-11-08 三>
1. 简介:
   1. 一组target构成CMake的buildsystem
   2. 每个 target 对应一个 executable, 或者对应一个 library,或者对应一个包含自定义命令的自定义目标
   3. 各个target之间的依赖关系在buildsystem之间进行表达
   4. 
2. 二进制目标
   1. 可执行文件和库文件使用 [[add_executable]]()和 [[add_library]]() 这两个命令进行定义
   2. 针对平台,产生的二进制文件有适当的前缀和后缀以及扩展名
   3. 二进制目标之间的依赖关系使用 [[target_link_libraries]]()命令来表示
   4. 示例:
	  1. [[add_library]](archive archive.cpp zip.cpp lzma.cpp)
	  2. [[add_executable]](zipapp zipapp.cpp)
	  3. [[target_link_libraries]](zipapp archive)
	  4. 
	  5. 
Blog creation time:[2017-11-08 三 09:45]
** WAITTING [#D] Theme:cmake-properties			       :@Blog:@Cmake:
     SCHEDULED:<2017-11-09 四>
1. Properties of Global Scope
   1. ALLOW_DUPLICATE_CUSTOM_TARGETS
   2. AUTOGEN_SOURCE_GROUP
   3. AUTOGEN_TARGETS_FOLDER
   4. AUTOMOC_SOURCE_GROUP
   5. AUTOMOC_TARGETS_FOLDER
   6. AUTORCC_SOURCE_GROUP
   7. CMAKE_C_KNOWN_FEATURES
   8. CMAKE_CXX_KNOWN_FEATURES
   9. DEBUG_CONFIGURATIONS
   10. DISABLED_FEATURES
   11. ENABLED_FEATURES
   12. <<ENABLED_LANGUAGES>>
       1. 存储当前使能的语言列表
       2. 由命令[[enable_language]]配置
       3. 只读
   13. FIND_LIBRARY_USE_LIB32_PATHS
   14. FIND_LIBRARY_USE_LIB64_PATHS
   15. FIND_LIBRARY_USE_LIBX32_PATHS
   16. FIND_LIBRARY_USE_OPENBSD_VERSIONING
   17. GENERATOR_IS_MULTI_CONFIG
   18. GLOBAL_DEPENDS_DEBUG_MODE
   19. GLOBAL_DEPENDS_NO_CYCLES
   20. IN_TRY_COMPILE
   21. PACKAGES_FOUND
   22. PACKAGES_NOT_FOUND
   23. JOB_POOLS
   24. PREDEFINED_TARGETS_FOLDER
   25. ECLIPSE_EXTRA_NATURES
   26. REPORT_UNDEFINED_PROPERTIES
   27. RULE_LAUNCH_COMPILE
   28. RULE_LAUNCH_CUSTOM
   29. RULE_LAUNCH_LINK
   30. RULE_MESSAGES
   31. TARGET_ARCHIVES_MAY_BE_SHARED_LIBS
   32. TARGET_MESSAGES
   33. TARGET_SUPPORTS_SHARED_LIBS
   34. USE_FOLDERS
   35. XCODE_EMIT_EFFECTIVE_PLATFORM_NAME
2. Properties on Directories
   1. ADDITIONAL_MAKE_CLEAN_FILES
   2. BINARY_DIR
   3. BUILDSYSTEM_TARGETS
   4. CACHE_VARIABLES
   5. CLEAN_NO_CUSTOM
   6. CMAKE_CONFIGURE_DEPENDS
   7. COMPILE_DEFINITIONS
   8. COMPILE_OPTIONS
   9. DEFINITIONS
   10. EXCLUDE_FROM_ALL
   11. IMPLICIT_DEPENDS_INCLUDE_TRANSFORM
   12. INCLUDE_DIRECTORIES
   13. INCLUDE_REGULAR_EXPRESSION
   14. INTERPROCEDURAL_OPTIMIZATION_<CONFIG>
   15. INTERPROCEDURAL_OPTIMIZATION
   16. LABELS
   17. LINK_DIRECTORIES
   18. LISTFILE_STACK
   19. MACROS
   20. PARENT_DIRECTORY
   21. RULE_LAUNCH_COMPILE
   22. RULE_LAUNCH_CUSTOM
   23. RULE_LAUNCH_LINK
   24. SOURCE_DIR
   25. SUBDIRECTORIES
   26. TEST_INCLUDE_FILES
   27. VARIABLES
   28. VS_GLOBAL_SECTION_POST_<section>
   29. VS_GLOBAL_SECTION_PRE_<section>
   30. VS_STARTUP_PROJECT
3. Properties on Targets
   1. ALIASED_TARGET
   2. ANDROID_ANT_ADDITIONAL_OPTIONS
   3. ANDROID_API
   4. ANDROID_API_MIN
   5. ANDROID_ARCH
   6. ANDROID_ASSETS_DIRECTORIES
   7. ANDROID_GUI
   8. ANDROID_JAR_DEPENDENCIES
   9. ANDROID_JAR_DIRECTORIES
   10. ANDROID_JAVA_SOURCE_DIR
   11. ANDROID_NATIVE_LIB_DEPENDENCIES
   12. ANDROID_NATIVE_LIB_DIRECTORIES
   13. ANDROID_PROCESS_MAX
   14. ANDROID_PROGUARD
   15. ANDROID_PROGUARD_CONFIG_PATH
   16. ANDROID_SECURE_PROPS_PATH
   17. ANDROID_SKIP_ANT_STEP
   18. ANDROID_STL_TYPE
   19. ARCHIVE_OUTPUT_DIRECTORY_<CONFIG>
   20. ARCHIVE_OUTPUT_DIRECTORY
   21. ARCHIVE_OUTPUT_NAME_<CONFIG>
   22. ARCHIVE_OUTPUT_NAME
   23. AUTOGEN_BUILD_DIR
   24. AUTOGEN_TARGET_DEPENDS
   25. AUTOMOC_COMPILER_PREDEFINES
   26. AUTOMOC_DEPEND_FILTERS
   27. AUTOMOC_MACRO_NAMES
   28. AUTOMOC_MOC_OPTIONS
   29. AUTOMOC
   30. AUTOUIC
   31. AUTOUIC_OPTIONS
   32. AUTOUIC_SEARCH_PATHS
   33. AUTORCC
   34. AUTORCC_OPTIONS
   35. BINARY_DIR
   36. BUILD_RPATH
   37. BUILD_WITH_INSTALL_NAME_DIR
   38. BUILD_WITH_INSTALL_RPATH
   39. BUNDLE_EXTENSION
   40. BUNDLE
   41. C_EXTENSIONS
   42. C_STANDARD
   43. C_STANDARD_REQUIRED
   44. COMPATIBLE_INTERFACE_BOOL
   45. COMPATIBLE_INTERFACE_NUMBER_MAX
   46. COMPATIBLE_INTERFACE_NUMBER_MIN
   47. COMPATIBLE_INTERFACE_STRING
   48. COMPILE_DEFINITIONS
   49. COMPILE_FEATURES
   50. COMPILE_FLAGS
   51. COMPILE_OPTIONS
   52. COMPILE_PDB_NAME
   53. COMPILE_PDB_NAME_<CONFIG>
   54. COMPILE_PDB_OUTPUT_DIRECTORY
   55. COMPILE_PDB_OUTPUT_DIRECTORY_<CONFIG>
   56. <CONFIG>_OUTPUT_NAME
   57. <CONFIG>_POSTFIX
   58. CROSSCOMPILING_EMULATOR
   59. CUDA_PTX_COMPILATION
   60. CUDA_SEPARABLE_COMPILATION
   61. CUDA_RESOLVE_DEVICE_SYMBOLS
   62. CUDA_EXTENSIONS
   63. CUDA_STANDARD
   64. CUDA_STANDARD_REQUIRED
   65. CXX_EXTENSIONS
   66. CXX_STANDARD
   67. CXX_STANDARD_REQUIRED
   68. DEBUG_POSTFIX
   69. DEFINE_SYMBOL
   70. DEPLOYMENT_REMOTE_DIRECTORY
   71. EchoString
   72. ENABLE_EXPORTS
   73. EXCLUDE_FROM_ALL
   74. EXCLUDE_FROM_DEFAULT_BUILD_<CONFIG>
   75. EXCLUDE_FROM_DEFAULT_BUILD
   76. EXPORT_NAME
   77. FOLDER
   78. Fortran_FORMAT
   79. Fortran_MODULE_DIRECTORY
   80. FRAMEWORK
   81. FRAMEWORK_VERSION
   82. GENERATOR_FILE_NAME
   83. GNUtoMS
   84. HAS_CXX
   85. IMPLICIT_DEPENDS_INCLUDE_TRANSFORM
   86. IMPORTED_CONFIGURATIONS
   87. IMPORTED_IMPLIB_<CONFIG>
   88. IMPORTED_IMPLIB
   89. IMPORTED_LIBNAME_<CONFIG>
   90. IMPORTED_LIBNAME
   91. IMPORTED_LINK_DEPENDENT_LIBRARIES_<CONFIG>
   92. IMPORTED_LINK_DEPENDENT_LIBRARIES
   93. IMPORTED_LINK_INTERFACE_LANGUAGES_<CONFIG>
   94. IMPORTED_LINK_INTERFACE_LANGUAGES
   95. IMPORTED_LINK_INTERFACE_LIBRARIES_<CONFIG>
   96. IMPORTED_LINK_INTERFACE_LIBRARIES
   97. IMPORTED_LINK_INTERFACE_MULTIPLICITY_<CONFIG>
   98. IMPORTED_LINK_INTERFACE_MULTIPLICITY
   99. IMPORTED_LOCATION_<CONFIG>
   100. IMPORTED_LOCATION
   101. IMPORTED_NO_SONAME_<CONFIG>
   102. IMPORTED_NO_SONAME
   103. IMPORTED_OBJECTS_<CONFIG>
   104. IMPORTED_OBJECTS
   105. IMPORTED
   106. IMPORTED_SONAME_<CONFIG>
   107. IMPORTED_SONAME
   108. IMPORT_PREFIX
   109. IMPORT_SUFFIX
   110. INCLUDE_DIRECTORIES
   111. INSTALL_NAME_DIR
   112. INSTALL_RPATH
   113. INSTALL_RPATH_USE_LINK_PATH
   114. INTERFACE_AUTOUIC_OPTIONS
   115. INTERFACE_COMPILE_DEFINITIONS
   116. INTERFACE_COMPILE_FEATURES
   117. INTERFACE_COMPILE_OPTIONS
   118. INTERFACE_INCLUDE_DIRECTORIES
   119. INTERFACE_LINK_LIBRARIES
   120. INTERFACE_POSITION_INDEPENDENT_CODE
   121. INTERFACE_SOURCES
   122. INTERFACE_SYSTEM_INCLUDE_DIRECTORIES
   123. INTERPROCEDURAL_OPTIMIZATION_<CONFIG>
   124. INTERPROCEDURAL_OPTIMIZATION
   125. IOS_INSTALL_COMBINED
   126. JOB_POOL_COMPILE
   127. JOB_POOL_LINK
   128. LABELS
   129. <LANG>_CLANG_TIDY
   130. <LANG>_COMPILER_LAUNCHER
   131. <LANG>_CPPCHECK
   132. <LANG>_CPPLINT
   133. <LANG>_INCLUDE_WHAT_YOU_USE
   134. <LANG>_VISIBILITY_PRESET
   135. LIBRARY_OUTPUT_DIRECTORY_<CONFIG>
   136. LIBRARY_OUTPUT_DIRECTORY
   137. LIBRARY_OUTPUT_NAME_<CONFIG>
   138. LIBRARY_OUTPUT_NAME
   139. LINK_DEPENDS_NO_SHARED
   140. LINK_DEPENDS
   141. LINKER_LANGUAGE
   142. LINK_FLAGS_<CONFIG>
   143. LINK_FLAGS
   144. LINK_INTERFACE_LIBRARIES_<CONFIG>
   145. LINK_INTERFACE_LIBRARIES
   146. LINK_INTERFACE_MULTIPLICITY_<CONFIG>
   147. LINK_INTERFACE_MULTIPLICITY
   148. LINK_LIBRARIES
   149. LINK_SEARCH_END_STATIC
   150. LINK_SEARCH_START_STATIC
   151. LINK_WHAT_YOU_USE
   152. LOCATION_<CONFIG>
   153. LOCATION
   154. MACOSX_BUNDLE_INFO_PLIST
   155. MACOSX_BUNDLE
   156. MACOSX_FRAMEWORK_INFO_PLIST
   157. MACOSX_RPATH
   158. MANUALLY_ADDED_DEPENDENCIES
   159. MAP_IMPORTED_CONFIG_<CONFIG>
   160. NAME
   161. NO_SONAME
   162. NO_SYSTEM_FROM_IMPORTED
   163. OSX_ARCHITECTURES_<CONFIG>
   164. OSX_ARCHITECTURES
   165. OUTPUT_NAME_<CONFIG>
   166. OUTPUT_NAME
   167. PDB_NAME_<CONFIG>
   168. PDB_NAME
   169. PDB_OUTPUT_DIRECTORY_<CONFIG>
   170. PDB_OUTPUT_DIRECTORY
   171. <<POSITION_INDEPENDENT_CODE>>
	1. 该变量的属性决定了将要创建的可执行文件或者共享库是否位置独立
	2. 对于SHARD 和 MODULE 库来说,这个属性是true
	3. 该属性值被变量 [[CMAKE_POSITION_INDEPENDENT_CODE]] 的值初始化
   172. PREFIX
   173. PRIVATE_HEADER
   174. PROJECT_LABEL
   175. PUBLIC_HEADER
   176. RESOURCE
   177. RULE_LAUNCH_COMPILE
   178. RULE_LAUNCH_CUSTOM
   179. RULE_LAUNCH_LINK
   180. RUNTIME_OUTPUT_DIRECTORY_<CONFIG>
   181. RUNTIME_OUTPUT_DIRECTORY
   182. RUNTIME_OUTPUT_NAME_<CONFIG>
   183. RUNTIME_OUTPUT_NAME
   184. SKIP_BUILD_RPATH
   185. SOURCE_DIR
   186. SOURCES
   187. SOVERSION
   188. STATIC_LIBRARY_FLAGS_<CONFIG>
   189. STATIC_LIBRARY_FLAGS
   190. SUFFIX
   191. TYPE
   192. VERSION
   193. VISIBILITY_INLINES_HIDDEN
   194. VS_CONFIGURATION_TYPE
   195. VS_DEBUGGER_WORKING_DIRECTORY
   196. VS_DESKTOP_EXTENSIONS_VERSION
   197. VS_DOTNET_REFERENCE_<refname>
   198. VS_DOTNET_REFERENCEPROP_<refname>_TAG_<tagname>
   199. VS_DOTNET_REFERENCES
   200. VS_DOTNET_REFERENCES_COPY_LOCAL
   201. VS_DOTNET_TARGET_FRAMEWORK_VERSION
   202. VS_GLOBAL_KEYWORD
   203. VS_GLOBAL_PROJECT_TYPES
   204. VS_GLOBAL_ROOTNAMESPACE
   205. VS_GLOBAL_<variable>
   206. VS_IOT_EXTENSIONS_VERSION
   207. VS_IOT_STARTUP_TASK
   208. VS_KEYWORD
   209. VS_MOBILE_EXTENSIONS_VERSION
   210. VS_SCC_AUXPATH
   211. VS_SCC_LOCALPATH
   212. VS_SCC_PROJECTNAME
   213. VS_SCC_PROVIDER
   214. VS_SDK_REFERENCES
   215. VS_USER_PROPS
   216. VS_WINDOWS_TARGET_PLATFORM_MIN_VERSION
   217. VS_WINRT_COMPONENT
   218. VS_WINRT_EXTENSIONS
   219. VS_WINRT_REFERENCES
   220. WIN32_EXECUTABLE
   221. WINDOWS_EXPORT_ALL_SYMBOLS
   222. XCODE_ATTRIBUTE_<an-attribute>
   223. XCODE_EXPLICIT_FILE_TYPE
   224. XCODE_PRODUCT_TYPE
   225. XCTEST
4. Properties on Tests
   1. ATTACHED_FILES_ON_FAIL
   2. ATTACHED_FILES
   3. COST
   4. DEPENDS
   5. DISABLED
   6. ENVIRONMENT
   7. FAIL_REGULAR_EXPRESSION
   8. FIXTURES_CLEANUP
   9. FIXTURES_REQUIRED
   10. FIXTURES_SETUP
   11. LABELS
   12. MEASUREMENT
   13. PASS_REGULAR_EXPRESSION
   14. PROCESSORS
   15. REQUIRED_FILES
   16. RESOURCE_LOCK
   17. RUN_SERIAL
   18. SKIP_RETURN_CODE
   19. TIMEOUT
   20. TIMEOUT_AFTER_MATCH
   21. WILL_FAIL
   22. WORKING_DIRECTORY
5. Properties on Source Files
   1. ABSTRACT
   2. AUTOUIC_OPTIONS
   3. AUTORCC_OPTIONS
   4. COMPILE_DEFINITIONS
   5. COMPILE_FLAGS
   6. EXTERNAL_OBJECT
   7. Fortran_FORMAT
   8. GENERATED
   9. HEADER_FILE_ONLY
   10. KEEP_EXTENSION
   11. LABELS
   12. LANGUAGE
   13. LOCATION
   14. MACOSX_PACKAGE_LOCATION
   15. OBJECT_DEPENDS
   16. OBJECT_OUTPUTS
   17. SKIP_AUTOGEN
   18. SKIP_AUTOMOC
   19. SKIP_AUTORCC
   20. SKIP_AUTOUIC
   21. SYMBOLIC
   22. VS_COPY_TO_OUT_DIR
   23. VS_CSHARP_<tagname>
   24. VS_DEPLOYMENT_CONTENT
   25. VS_DEPctLOYMENT_LOCATION
   26. VS_INCLUDE_IN_VSIX
   27. VS_RESOURCE_GENERATOR
   28. VS_SHADER_ENTRYPOINT
   29. VS_SHADER_FLAGS
   30. VS_SHADER_MODEL
   31. VS_SHADER_OUTPUT_HEADER_FILE
   32. VS_SHADER_TYPE
   33. VS_SHADER_VARIABLE_NAME
   34. VS_TOOL_OVERRIDE
   35. VS_XAML_TYPE
   36. WRAP_EXCLUDE
   37. XCODE_EXPLICIT_FILE_TYPE
   38. XCODE_FILE_ATTRIBUTES
   39. XCODE_LAST_KNOWN_FILE_TYPE
6. Properties on Cache Entries
   1. ADVANCED
   2. HELPSTRING
   3. MODIFIED
   4. STRINGS
   5. TYPE
   6. VALUE
7. Properties on Installed Files
   1. CPACK_DESKTOP_SHORTCUTS
   2. CPACK_NEVER_OVERWRITE
   3. CPACK_PERMANENT
   4. CPACK_START_MENU_SHORTCUTS
   5. CPACK_STARTUP_SHORTCUTS
   6. CPACK_WIX_ACL
8. Deprecated Properties on Directories
   1. COMPILE_DEFINITIONS_<CONFIG>
   2. TEST_INCLUDE_FILE
9. Deprecated Properties on Targets
   1. COMPILE_DEFINITIONS_<CONFIG>
   2. POST_INSTALL_SCRIPT
   3. PRE_INSTALL_SCRIPT
10. Deprecated Properties on Source Files
    1. COMPILE_DEFINITIONS_<CONFIG>
Blog creation time:[2017-11-09 四 15:16]
** WAITTING [#D] Theme:cmake-language			       :@Blog:@Cmake:
    SCHEDULED:<2017-11-08 三>
1. Variables
   1. 在 cmake 的语法中,变量是基本的存储单元
   2. 变量的值总是字符串类型
   3. set 和 unset 命令用于设置以及清除变量的值(当然了,也有其他的一些命令含有修改变量值的语义)
   4. 变量名是大小写敏感的,建议使用_和-来组合变量
   5. 变量有动态的范围,每个使用set或者unset赋值的变量实际上是在当前范围内创建了一个绑定 
Blog creation time:[2017-11-08 三 09:38]
** WAITTING [#D] Theme:cmake-toolchains			       :@Blog:@Cmake:
    SCHEDULED:<2017-11-08 三>
1. <<Introduction>>
   1. CMake使用工具链来进行编译,链接库,创建归档，以及使用一些任务去进行构建
   2. 命令[[project]]()以及 [[enable_language]]()中给出的语言决定了采用何种工具链工具
   3. 在常规构建中，CMake基于系统自检和缺省自动为宿主构建决定工具链
   4. 在交叉编译的情况下，可以通过相关的编译器和工具路径来指定工具链文件
2. <<Languages>>
   1. 在使用[[project]]()命令时,如果设置了LANGUAGE参数,或者使用[[enable_language]](),则内置变量[[CMAKE_C_COMPILER]]就会被设置为指定的语言,如果没有做出任何设置,则会默认隐式使用缺省的C以及CXX
   2. 采用的语言决定了一些信息，如编译器的供应商和版本，目标架构和位宽，相应工具的位置等
   3. 当语言被确定好以后，相应的就确定了使用 何种编译器,链接器
   4. 全局属性[[ENABLED_LANGUAGES]]包含当前启用的语言
   5. 通过目标中源文件的语言来计算采用的链接器,在静态库的情况下，也通过依赖库的语言来计算,CMake做出的选择可能被目标属性 [[LINKER_LANGUAGE]] 重写
3. <<Variables and Properties>>
   1. 几个关于工具链的语言组件变量会被使用
   2. [[CMAKE_TOOLCHIAIN_FILE]] 提供一个交叉编译的脚本
   3. [[CMAKE_SYSTEM_NAME]] 目标机上运行的操作系统的名称
   4. [[CMAKE_SYSTEM_PROCESSOR]] 目标机的硬件架构，例如ARM，X86
   5. [[CMAKE_<LANG>_COMPILER]] 指明了<LANG>语言的编译器所在的路径
   6. [[CMAKE_<LANG>_COMPILER_ID]] 作为编译器的标识
   7. [[CMAKE_<LANG>_COMPILER_VERSION]] 标识编译器的版本
   8. [[CMAKE_<LANG>_FLAGS]] 当编译一个特定语言的文件时,该变量中给出的选项将会被作为编译时的选项
   9. [[CMAKE_FIND_ROOT_PATH]] 搜索路径
   10. [[CMAKE_SYSROOT]]  搜索路径
4. Toolchain Features
5. <<Cross Compiling>> (Cross Compiling for Linux)
   1. <<CMAKE_TOOLCHIAIN_FILE>> 这应当是CMake交叉编译中最重要的概念了,CMake不知道你的目标平台是什么、用什么编译器、如何编译等等，所以你需要提供预设一些变量到CMake
   2. 其中最为方便的一个方法就是将相关的变量设置都放进一个文件(cmake脚本)中去，然后将该文件通过CMAKE_TOOLCHIAIN_FILE传递给CMake 
   3. 传递交叉编译脚本的方法: cmake -D CMAKE_TOOLCHIAIN_FILE="/path/to/my-cmake-toolchain-file" ..   (当然,也可以在CMakeList.txt中直接给出)
   4. <<目标机>>: 运行代码的实体机,比如stm32f407zgt6 
   5. <<宿主即>>: 也叫开发平台,比如linux,windows
   6. 交叉编译: 在宿主机上开发程序,烧录到目标机上运行
   7. cmake是无法自动判断出目标机的上运行的系统的,因此必须需要我们通过变量 [[CMAKE_SYSTEM_NAME]] 指定
   8. 在宿主机上交叉编译出来的可执行文件通常不能直接运行在宿主机上
   9. 交叉编译过程中不能使用宿主机上的原生头文件和库，而是需要用到一套专门针对目标机的头文件和库,如embi-arm-linux-xx
   10. 在交叉编译时(即指定了[[CMAKE_SYSTEM_NAME]]), [[CMAKE_CROSSCOMPILING]]变量将被设置为真值
   11. 稍微大一点的项目都会用到一些外部依赖库或者tool,CMake提供了 [[find_library]]() [[find_package]]() [[find_file]]() [[find_program]]() [[find_path]]()来进行外部依赖的搜索查找
   12. 变量[[CMAKE_FIND_ROOT_PATH]] 和 [[CMAKE_SYSROOT]] 指明了外部依赖的搜索路径,即所有find_*将在这两个变量指定的路径路径,以及宿主机相关的路径下搜索,当然了,可以限制只在某一路径下搜索,详情参考CMAKE_FIND_ROOT_PATH
Blog creation time:[2017-11-08 三 09:40]
** WAITTING [#D] Theme:cmake-env-variables 		       :@Blog:@Cmake:
    SCHEDULED:<2017-11-08 三>
1. 设置环境变量set(ENV{CMAKE_C_FLAGS} "-O3 -Wall")
2. 查看环境变量message(STATUS "CMAKE_C_FLAGS: " $ENV{CMAKE_C_FLAGS})
3. Environment Variables that Control the Build
   1. CMAKE_CONFIG_TYPE
   2. CMAKE_MSVCIDE_RUN_PATH
   3. CMAKE_OSX_ARCHITECTURES
   4. LDFLAGS
   5. MACOSX_DEPLOYMENT_TARGET
4. Environment Variables for Languages
   1. ASM<DIALECT>
   2. ASM<DIALECT>FLAGS
   3. CC
   4. <<CFLAGS>>
      1. 如果CMAKE_C_FLAGS没有定义,则在编译c源文件时,该变量存储默认的编译flags
      2. 如果CMAKE_C_FLAGS没有定义,仅仅在首次配置CC的默认编译状态时,该变量才被cmake使用,之后,这个值存储在CMAKE_C_FLAGS中
      3. 如果定义了[[CMAKE_C_FLAGS]],不论是首次配置还是任意次配置CC的编译flags,该变量CFLAGS都会被忽略
   5. CSFLAGS
   6. CUDACXX
   7. CUDAFLAGS
   8. CUDAHOSTCXX
   9. CXX
   10. CXXFLAGS
   11. FC
   12. FFLAGS
   13. RC
   14. RCFLAGS
5. Environment Variables for CTest
   1. CMAKE_CONFIG_TYPE
   2. CTEST_INTERACTIVE_DEBUG_MODE
   3. CTEST_OUTPUT_ON_FAILURE
   4. CTEST_PARALLEL_LEVEL
   5. CTEST_USE_LAUNCHERS_DEFAULT
   6. DASHBOARD_TEST_FROM_CTEST
Blog creation time:[2017-11-08 三 09:39]
** WAITTING [#D] Theme:cmake-compile-features				   :@Blog:@Cmake:
    SCHEDULED:<2017-11-08 三>

Blog creation time:[2017-11-08 三 09:41]
** WAITTING [#D] Theme:cmake-developer 					   :@Blog:@Cmake:
    SCHEDULED:<2017-11-08 三>

Blog creation time:[2017-11-08 三 09:42]
** WAITTING [#D] Theme:cmake-policies						   :@Blog:@Cmake:
    SCHEDULED:<2017-11-08 三>
1. introduction
   1. 开发中会遇到这样的事,使用cmake开发了一个项目,突然一不小心在系统升级时将cmake的版本也升级了
   2. 新版本的cmake相比于老版本的cmake,某些命令或者变量带来了行为上的改变,当前的项目在编译时会出现一些警告,甚至是行为不符的现象
   3. 在cmake中,为了解决这样的情况,提供了一种称为policy的机制,cmake的设计者每次发布新版本时,如果发现新版本相对老版本带来了某些行为上的改变,就会顺带发布一个CMP_<NNNN>的policy
   4. 每个CMP_<NNNN>中都会"旧行为"和"新行为",以及引入该policy的原因
   5. 在工程中可以设置各种policy来选择期望的行为
Blog creation time:[2017-11-08 三 13:28]
** WAITTING [#D] Theme:cmake-variables 						   :@Blog:@Cmake:
   SCHEDULED:<2017-11-08 三>
1. Variables that Provide Information
   1. CMAKE_AR
   2. CMAKE_ARGC
   3. CMAKE_ARGV0
   4. CMAKE_BINARY_DIR
   5. CMAKE_BUILD_TOOL
   6. CMAKE_CACHEFILE_DIR
   7. CMAKE_CACHE_MAJOR_VERSION
   8. CMAKE_CACHE_MINOR_VERSION
   9. CMAKE_CACHE_PATCH_VERSION
   10. CMAKE_CFG_INTDIR
   11. CMAKE_COMMAND
   12. CMAKE_CROSSCOMPILING
   13. CMAKE_CROSSCOMPILING_EMULATOR
   14. CMAKE_CTEST_COMMAND
   15. CMAKE_CURRENT_BINARY_DIR
   16. CMAKE_CURRENT_LIST_DIR
       1. 含义: 当前正在处理的列表文件(CMakelists.txt)所在的目录路径
       2. 动态变量
       3. 如: /home/ljj/workspace/test5/dir/
   17. CMAKE_CURRENT_LIST_FILE
       1. 含义: 当前正在处理的列表文件(CMakeLists.txt)
       2. 动态变量
       3. 如:  /home/ljj/workspace/test5/dir/CMakeLists.txt
   18. CMAKE_CURRENT_LIST_LINE
   19. CMAKE_CURRENT_SOURCE_DIR
   20. CMAKE_DIRECTORY_LABELS
   21. CMAKE_DL_LIBS
   22. CMAKE_EDIT_COMMAND
   23. CMAKE_EXECUTABLE_SUFFIX
   24. CMAKE_EXTRA_GENERATOR
   25. CMAKE_EXTRA_SHARED_LIBRARY_SUFFIXES
   26. CMAKE_FIND_PACKAGE_NAME
   27. CMAKE_FIND_PACKAGE_SORT_DIRECTION
   28. CMAKE_FIND_PACKAGE_SORT_ORDER
   29. CMAKE_GENERATOR
   30. CMAKE_GENERATOR_PLATFORM
   31. CMAKE_GENERATOR_TOOLSET
   32. CMAKE_HOME_DIRECTORY
   33. CMAKE_IMPORT_LIBRARY_PREFIX
   34. CMAKE_IMPORT_LIBRARY_SUFFIX
   35. CMAKE_JOB_POOL_COMPILE
   36. CMAKE_JOB_POOL_LINK
   37. CMAKE_<LANG>_COMPILER_AR
   38. CMAKE_<LANG>_COMPILER_RANLIB
   39. CMAKE_LINK_LIBRARY_SUFFIX
   40. CMAKE_LINK_SEARCH_END_STATIC
   41. CMAKE_LINK_SEARCH_START_STATIC
   42. CMAKE_MAJOR_VERSION
   43. CMAKE_MAKE_PROGRAM
   44. CMAKE_MATCH_COUNT
   45. CMAKE_MATCH_<n>
   46. CMAKE_MINIMUM_REQUIRED_VERSION
   47. CMAKE_MINOR_VERSION
   48. CMAKE_PARENT_LIST_FILE
   49. CMAKE_PATCH_VERSION
   50. CMAKE_PROJECT_DESCRIPTION
   51. CMAKE_PROJECT_NAME
   52. CMAKE_RANLIB
   53. CMAKE_ROOT
   54. CMAKE_SCRIPT_MODE_FILE
   55. CMAKE_SHARED_LIBRARY_PREFIX
   56. CMAKE_SHARED_LIBRARY_SUFFIX
   57. CMAKE_SHARED_MODULE_PREFIX
   58. CMAKE_SHARED_MODULE_SUFFIX
   59. CMAKE_SIZEOF_VOID_P
   60. CMAKE_SKIP_INSTALL_RULES
   61. CMAKE_SKIP_RPATH
   62. CMAKE_SOURCE_DIR
   63. CMAKE_STATIC_LIBRARY_PREFIX
   64. CMAKE_STATIC_LIBRARY_SUFFIX
   65. CMAKE_TOOLCHAIN_FILE
   66. CMAKE_TWEAK_VERSION
   67. CMAKE_VERBOSE_MAKEFILE
   68. CMAKE_VERSION
   69. CMAKE_VS_DEVENV_COMMAND
   70. CMAKE_VS_INTEL_Fortran_PROJECT_VERSION
   71. CMAKE_VS_MSBUILD_COMMAND
   72. CMAKE_VS_NsightTegra_VERSION
   73. CMAKE_VS_PLATFORM_NAME
   74. CMAKE_VS_PLATFORM_TOOLSET
   75. CMAKE_VS_PLATFORM_TOOLSET_CUDA
   76. CMAKE_VS_PLATFORM_TOOLSET_HOST_ARCHITECTURE
   77. CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION
   78. CMAKE_XCODE_GENERATE_SCHEME
   79. CMAKE_XCODE_PLATFORM_TOOLSET
   80. <PROJECT-NAME>_BINARY_DIR
       1. 作用: 该变量的值是命令project(<PROJECT-NAME> ......)中指定的项目名的顶层 binary directory 目录的路径
       2. 使用场合: 当使用add_subdirectory()命令来连接几个工程时,该变量就十分有用
       3. 个人建议: PROJECT_BINARY_DIR指代的对象没有该变量指代的清楚明了,建议使用该变量
   81. <PROJECT-NAME>_SOURCE_DIR
       1. 作用: 该变量的值是命令project(<PROJECT-NAME> ......)中指定的项目名的顶层 source directory 目录的路径
       2. 使用场合: 当使用add_subdirectory()命令来连接几个工程时,该变量就十分有用
       3. 个人建议: PROJECT_SOURCE_DIR指代的对象没有该变量指代的清楚明了,建议使用该变量
   82. <PROJECT-NAME>_VERSION
       1. 作用:  该变量用于存储命令project(<PROJECT-NAME>  [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]......)中指定的VERSION
       2. 备注: cmake_policy
   83. <PROJECT-NAME>_VERSION_MAJOR
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第1个号码<major>
   84. <PROJECT-NAME>_VERSION_MINOR
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第2个号码<minor>
   85. <PROJECT-NAME>_VERSION_PATCH
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第3个号码<patch> 
   86. <PROJECT-NAME>_VERSION_TWEAK
       1. 作用: 存储<PROJECT-NAME>_VERSION中的第4个号码<tweak>
   87. PROJECT_BINARY_DIR
   88. PROJECT_DESCRIPTION
       1. 作用: 存储project命令中<DESCRIPTION>参数,项目描述信息
   89. PROJECT_NAME
       1. 作用: 该变量的值是命令project(<PROJECT-NAME> ......)中指定的项目名<PROJECT-NAME>
       2. 使用场合: 可以通过查询该变量得知项目的名字
   90. PROJECT_SOURCE_DIR
   91. PROJECT_VERSION
   92. PROJECT_VERSION_MAJOR
   93. PROJECT_VERSION_MINOR
   94. PROJECT_VERSION_PATCH
   95. PROJECT_VERSION_TWEAK
2. Variables that Change Behavior
   1. <<BUILD_SHARED_LIBS>>
      1. 该变量如果设置为ON,则在全局范围内,[[ add_library]]() 创建的所有库均是 SHARD 库,除非明确的指出要创建一个STATIC库
      2. 该变量经常在项目中最为一个 [[option]]() 以便项目的每一个用户能够决定它们是否想要使用静态库或者动态库构建系统
   2. CMAKE_ABSOLUTE_DESTINATION_FILES
   3. CMAKE_APPBUNDLE_PATH
   4. CMAKE_AUTOMOC_RELAXED_MODE
   5. CMAKE_BACKWARDS_COMPATIBILITY
   6. CMAKE_BUILD_TYPE
   7. CMAKE_CODEBLOCKS_EXCLUDE_EXTERNAL_FILES
   8. CMAKE_CODELITE_USE_TARGETS
   9. CMAKE_COLOR_MAKEFILE
   10. CMAKE_CONFIGURATION_TYPES
   11. CMAKE_DEBUG_TARGET_PROPERTIES
   12. CMAKE_DEPENDS_IN_PROJECT_ONLY
   13. CMAKE_DISABLE_FIND_PACKAGE_<PackageName>
   14. CMAKE_ECLIPSE_GENERATE_LINKED_RESOURCES
   15. CMAKE_ECLIPSE_GENERATE_SOURCE_PROJECT
   16. CMAKE_ECLIPSE_MAKE_ARGUMENTS
   17. CMAKE_ECLIPSE_VERSION
   18. CMAKE_ERROR_DEPRECATED
   19. CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION
   20. CMAKE_EXPORT_COMPILE_COMMANDS
   21. CMAKE_EXPORT_NO_PACKAGE_REGISTRY
   22. CMAKE_FIND_APPBUNDLE
   23. CMAKE_FIND_FRAMEWORK
   24. CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX
   25. CMAKE_FIND_LIBRARY_PREFIXES
   26. CMAKE_FIND_LIBRARY_SUFFIXES
   27. CMAKE_FIND_NO_INSTALL_PREFIX
   28. CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY
   29. CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY
   30. CMAKE_FIND_PACKAGE_WARN_NO_MODULE
   31. <<CMAKE_FIND_ROOT_PATH>>
       1. 在交叉编译时,该变量是十分有用的,比如,在给一个ARM处理器的移动设备做交叉编译，其中需要寻找libjpeg.so
       2. 假如使用find_package(JPEG) 在没有设置该变量的前提下,返回的是/usr/lib/libjpeg.so
       3. 这是有问题的，因为找到的这个so库只是给你的宿主机系统(例如一个x86的Ubuntu主机)服务的，不能用于arm系统
       4. 所以你需要告诉CMake去其它地方去查找,该变量就是干这个事的,它在文件系统层次给出了一个用于搜索的根
       5. 比如 [[set]](CMAKE_FIND_ROOT_PATH /home/ljj/stm32/embi-arm-linux-xx)
       6. 默认情况下,CMake首先会到/home/ljj/stm32/embi-arm-linux-xxx/usr/lib或者/home/ljj/stm32/embi-arm-linux-xx/lib等子目录下面搜索所有find_*命令给出的条目
       7. 如果没有找到(且设置了 [[find_package(BOTH)]] 的情况下),可以接着到 [[CMAKE_SYSROOT]] 列出的路径下搜索, 如果还是没有找到的话就到宿主机的相关目录下搜索
       8. 默认这个变量是空,交叉编译中应当对该变量进行设置
       9. 配置该变量的同时还应配置[[CMAKE_FIND_ROOT_PATH_MODE_PROGRAM]] , [[CMAKE_FIND_ROOT_PATH_MODE_LIBRARY]] , [[CMAKE_FIND_ROOT_PATH_MODE_INCLUDE]] , [[CMAKE_FIND_ROOT_PATH_MODE_PACKAGE]]
       1. 参考 [[Cross Compiling]]  [[CMAKE_SYSROOT]] 
   32. <<CMAKE_FIND_ROOT_PATH_MODE_LIBRARY>>
       1. 该变量用于控制 [[find_library]]()命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]]给出的路径下面搜索
       2. 如果设置为ONLY,那么,find_library() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
       3. 如果设置为NEVER,那么, find_library() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
       4. 如果设置为BOTH,那么,find_library() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
   33. <<CMAKE_FIND_ROOT_PATH_MODE_INCLUDE>>
       1. 该变量用于控制 [[find_file]](), [[find_path]]() 命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]] 给出的路径下面搜索
       2. 如果设置为ONLY,那么,find_file(),find_path() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
       3. 如果设置为NEVER,那么, find_file(),find_path() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
       4. 如果设置为BOTH,那么,find_file(),find_path() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
   34. <<CMAKE_FIND_ROOT_PATH_MODE_PACKAGE>>
       1. 该变量用于控制 [[find_package]]()命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]]给出的路径下面搜索
       2. 如果设置为ONLY,那么,find_package() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
       3. 如果设置为NEVER,那么, find_package() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
       4. 如果设置为BOTH,那么,find_package() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
   35. <<CMAKE_FIND_ROOT_PATH_MODE_PROGRAM>>
       1. 该变量用于控制 [[find_program]]()命令是否可以在 [[CMAKE_FIND_ROOT_PATH]] , [[CMAKE_SYSROOT]]给出的路径下面搜索
       2. 如果设置为ONLY,那么,find_program() 仅仅只能在 CMAKE_FIND_ROOT_PATH  下面给出的路径中进行搜索
       3. 如果设置为NEVER,那么, find_program() 将无法在 CMAKE_FIND_ROOT_PATH 下面给出的路径中搜索,只能在宿主机相应的目录下进行搜索
       4. 如果设置为BOTH,那么,find_program() 可以在 CMAKE_FIND_ROOT_PATH 下面以及宿主机相应的目录下面进行搜索
   36. CMAKE_FRAMEWORK_PATH
   37. CMAKE_IGNORE_PATH
   38. CMAKE_INCLUDE_DIRECTORIES_BEFORE
   39. CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE
   40. <<CMAKE_INCLUDE_PATH>>
   41. CMAKE_INSTALL_DEFAULT_COMPONENT_NAME
   42. CMAKE_INSTALL_MESSAGE
   43. <<CMAKE_INSTALL_PREFIX>>
       1. 该变量被命令[[install]]()使用到
       2. 当 make install 被调用 或者 使用命令install()时,这个变量的目录所示的路径将会被安装路径的后面
       3. 在UNIX下,这个变量默认是/usr/local,在window下,默认是c:/Program Files/${PROJECT_NAME}
       4. 该变量的使用方法: cmake -DCMAKE_INSTALL_PREFIX=usr/ .. 此时 make DESTDIR=/home/john install 后,软件的安装路径就是usr/home/john
       5. 备注: 当然了,该变量也可以在CMakeLists.txt中使用set进行配置,原则是如果用户在命令行使用-D定义了默认路径的话,就使用命令行的路径,否则就使用set设置的路径
       6. 通过判断 [[CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT]] 的值实现该变量的配置:
	  1. if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
   	  2. [[set]](CMAKE_INSTALL_PREFIX "/my/default" CACHE PATH "..." FORCE)
	  3. endif()
   44. CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT
   45. CMAKE_LIBRARY_PATH
   46. CMAKE_MFC_FLAG
   47. CMAKE_MODULE_PATH
   48. CMAKE_NOT_USING_CONFIG_FLAGS
   49. CMAKE_POLICY_DEFAULT_CMP<NNNN>
       1. 作用: 存储某个policy的默认配置(OLD or NEW)
       2. 更改: cmake_policy(SET CMP0048 NEW)
       3. 说明: <NNNN>代表某个policy的编号,如0048,该编号具体是什么含义,参见cmake-policies
   50. CMAKE_POLICY_WARNING_CMP<NNNN>
   51. CMAKE_PREFIX_PATH
   52. CMAKE_PROGRAM_PATH
   53. CMAKE_PROJECT_<PROJECT-NAME>_INCLUDE
   54. CMAKE_SKIP_INSTALL_ALL_DEPENDENCY
   55. CMAKE_STAGING_PREFIX
   56. CMAKE_SUBLIME_TEXT_2_ENV_SETTINGS
   57. CMAKE_SUBLIME_TEXT_2_EXCLUDE_BUILD_TREE
   58. CMAKE_SYSROOT
   59. CMAKE_SYSROOT_COMPILE
   60. CMAKE_SYSROOT_LINK
   61. CMAKE_SYSTEM_APPBUNDLE_PATH
   62. CMAKE_SYSTEM_FRAMEWORK_PATH
   63. CMAKE_SYSTEM_IGNORE_PATH
   64. CMAKE_SYSTEM_INCLUDE_PATH
   65. CMAKE_SYSTEM_LIBRARY_PATH
   66. CMAKE_SYSTEM_PREFIX_PATH
   67. CMAKE_SYSTEM_PROGRAM_PATH
   68. CMAKE_USER_MAKE_RULES_OVERRIDE
   69. CMAKE_WARN_DEPRECATED
   70. CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION
3. Variables that Describe the System
   1. ANDROID
   2. APPLE
   3. BORLAND
   4. CMAKE_CL_64
   5. CMAKE_COMPILER_2005
   6. CMAKE_HOST_APPLE
   7. CMAKE_HOST_SOLARIS
   8. CMAKE_HOST_SYSTEM
   9. CMAKE_HOST_SYSTEM_NAME
   10. CMAKE_HOST_SYSTEM_PROCESSOR
   11. CMAKE_HOST_SYSTEM_VERSION
   12. CMAKE_HOST_UNIX
   13. CMAKE_HOST_WIN32
   14. CMAKE_LIBRARY_ARCHITECTURE
   15. CMAKE_LIBRARY_ARCHITECTURE_REGEX
   16. CMAKE_OBJECT_PATH_MAX
   17. CMAKE_SYSTEM
   18. <<CMAKE_SYSTEM_NAME>>
       1. [[目标机]]上运行的操作系统的名称,比如Linux,Android,如果你的嵌入式平台没有相关OS你即需要写成”Generic”
       2. 这是在toolchain脚本中必须要设置的变量,只有当CMAKE_SYSTEM_NAME这个变量被设置了，CMake才认为此时正在交叉编译
       3. 它会额外设置一个变量[[CMAKE_CROSSCOMPILING]]为TRUE
       4. 参考 [[CMAKE_TOOLCHIAIN_FILE]] 
   19. <<CMAKE_SYSTEM_PROCESSOR>>
       1. 代表[[目标机]]的硬件架构，例如ARM，X86
       2. 这个是可选项，但是在移动开发中很重要
   20. CMAKE_SYSTEM_VERSION
   21. CYGWIN
   22. ENV
   23. GHS-MULTI
   24. MINGW
   25. MSVC
   26. MSVC10
   27. MSVC11
   28. MSVC12
   29. MSVC14
   30. MSVC60
   31. MSVC70
   32. MSVC71
   33. MSVC80
   34. MSVC90
   35. MSVC_IDE
   36. MSVC_VERSION
   37. UNIX
   38. WIN32
   39. WINCE
   40. WINDOWS_PHONE
   41. WINDOWS_STORE
   42. XCODE
   43. XCODE_VERSION
4. Variables that Control the Build
   1. CMAKE_ANDROID_ANT_ADDITIONAL_OPTIONS
   2. CMAKE_ANDROID_API
   3. CMAKE_ANDROID_API_MIN
   4. CMAKE_ANDROID_ARCH
   5. CMAKE_ANDROID_ARCH_ABI
   6. CMAKE_ANDROID_ARM_MODE
   7. CMAKE_ANDROID_ARM_NEON
   8. CMAKE_ANDROID_ASSETS_DIRECTORIES
   9. CMAKE_ANDROID_GUI
   10. CMAKE_ANDROID_JAR_DEPENDENCIES
   11. CMAKE_ANDROID_JAR_DIRECTORIES
   12. CMAKE_ANDROID_JAVA_SOURCE_DIR
   13. CMAKE_ANDROID_NATIVE_LIB_DEPENDENCIES
   14. CMAKE_ANDROID_NATIVE_LIB_DIRECTORIES
   15. CMAKE_ANDROID_NDK
   16. CMAKE_ANDROID_NDK_DEPRECATED_HEADERS
   17. CMAKE_ANDROID_NDK_TOOLCHAIN_HOST_TAG
   18. CMAKE_ANDROID_NDK_TOOLCHAIN_VERSION
   19. CMAKE_ANDROID_PROCESS_MAX
   20. CMAKE_ANDROID_PROGUARD
   21. CMAKE_ANDROID_PROGUARD_CONFIG_PATH
   22. CMAKE_ANDROID_SECURE_PROPS_PATH
   23. CMAKE_ANDROID_SKIP_ANT_STEP
   24. CMAKE_ANDROID_STANDALONE_TOOLCHAIN
   25. CMAKE_ANDROID_STL_TYPE
   26. CMAKE_ARCHIVE_OUTPUT_DIRECTORY
   27. CMAKE_ARCHIVE_OUTPUT_DIRECTORY_<CONFIG>
   28. CMAKE_AUTOMOC
   29. CMAKE_AUTOMOC_COMPILER_PREDEFINES
   30. CMAKE_AUTOMOC_DEPEND_FILTERS
   31. CMAKE_AUTOMOC_MACRO_NAMES
   32. Example
   33. CMAKE_AUTOMOC_MOC_OPTIONS
   34. CMAKE_AUTORCC
   35. CMAKE_AUTORCC_OPTIONS
   36. CMAKE_AUTOUIC
   37. CMAKE_AUTOUIC_OPTIONS
   38. CMAKE_AUTOUIC_SEARCH_PATHS
   39. CMAKE_BUILD_RPATH
   40. CMAKE_BUILD_WITH_INSTALL_NAME_DIR
   41. CMAKE_BUILD_WITH_INSTALL_RPATH
   42. CMAKE_COMPILE_PDB_OUTPUT_DIRECTORY
   43. CMAKE_COMPILE_PDB_OUTPUT_DIRECTORY_<CONFIG>
   44. CMAKE_<CONFIG>_POSTFIX
   45. CMAKE_DEBUG_POSTFIX
   46. CMAKE_ENABLE_EXPORTS
   47. <<CMAKE_EXE_LINKER_FLAGS>>
       1. 作用: 存储创建可执行文件时用到的链接flags
       2. 这个变量中的flags将会在创建一个可执行文件时被使用
   48. CMAKE_EXE_LINKER_FLAGS_<CONFIG>
   49. CMAKE_EXE_LINKER_FLAGS_<CONFIG>_INIT
   50. CMAKE_EXE_LINKER_FLAGS_INIT
   51. CMAKE_Fortran_FORMAT
   52. CMAKE_Fortran_MODULE_DIRECTORY
   53. CMAKE_GNUtoMS
   54. CMAKE_INCLUDE_CURRENT_DIR
   55. CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE
   56. CMAKE_INSTALL_NAME_DIR
   57. CMAKE_INSTALL_RPATH
   58. CMAKE_INSTALL_RPATH_USE_LINK_PATH
   59. CMAKE_INTERPROCEDURAL_OPTIMIZATION
   60. CMAKE_INTERPROCEDURAL_OPTIMIZATION_<CONFIG>
   61. CMAKE_IOS_INSTALL_COMBINED
   62. CMAKE_<LANG>_CLANG_TIDY
   63. CMAKE_<LANG>_COMPILER_LAUNCHER
   64. CMAKE_<LANG>_CPPCHECK
   65. CMAKE_<LANG>_CPPLINT
   66. CMAKE_<LANG>_INCLUDE_WHAT_YOU_USE
   67. CMAKE_<LANG>_VISIBILITY_PRESET
   68. CMAKE_LIBRARY_OUTPUT_DIRECTORY
   69. CMAKE_LIBRARY_OUTPUT_DIRECTORY_<CONFIG>
   70. CMAKE_LIBRARY_PATH_FLAG
   71. CMAKE_LINK_DEF_FILE_FLAG
   72. CMAKE_LINK_DEPENDS_NO_SHARED
   73. CMAKE_LINK_INTERFACE_LIBRARIES
   74. CMAKE_LINK_LIBRARY_FILE_FLAG
   75. CMAKE_LINK_LIBRARY_FLAG
   76. CMAKE_LINK_WHAT_YOU_USE
   77. CMAKE_MACOSX_BUNDLE
   78. CMAKE_MACOSX_RPATH
   79. CMAKE_MAP_IMPORTED_CONFIG_<CONFIG>
   80. CMAKE_MODULE_LINKER_FLAGS
   81. CMAKE_MODULE_LINKER_FLAGS_<CONFIG>
   82. CMAKE_MODULE_LINKER_FLAGS_<CONFIG>_INIT
   83. CMAKE_MODULE_LINKER_FLAGS_INIT
   84. CMAKE_MSVCIDE_RUN_PATH
   85. CMAKE_NINJA_OUTPUT_PATH_PREFIX
   86. CMAKE_NO_BUILTIN_CHRPATH
   87. CMAKE_NO_SYSTEM_FROM_IMPORTED
   88. CMAKE_OSX_ARCHITECTURES
   89. CMAKE_OSX_DEPLOYMENT_TARGET
   90. CMAKE_OSX_SYSROOT
   91. CMAKE_PDB_OUTPUT_DIRECTORY
   92. CMAKE_PDB_OUTPUT_DIRECTORY_<CONFIG>
   93. <<CMAKE_POSITION_INDEPENDENT_CODE>>
	   1.该变量被用于初始化所有目标的  [[POSITION_INDEPENDENT_CODE]] 属性
       1. 该变量的值也被用于 [[try_compile]]()
   94. CMAKE_RUNTIME_OUTPUT_DIRECTORY
   95. CMAKE_RUNTIME_OUTPUT_DIRECTORY_<CONFIG>
   96. CMAKE_SHARED_LINKER_FLAGS
   97. CMAKE_SHARED_LINKER_FLAGS_<CONFIG>
   98. CMAKE_SHARED_LINKER_FLAGS_<CONFIG>_INIT
   99. CMAKE_SHARED_LINKER_FLAGS_INIT
   100. CMAKE_SKIP_BUILD_RPATH
   101. CMAKE_SKIP_INSTALL_RPATH
   102. CMAKE_STATIC_LINKER_FLAGS
   103. CMAKE_STATIC_LINKER_FLAGS_<CONFIG>
   104. CMAKE_STATIC_LINKER_FLAGS_<CONFIG>_INIT
   105. CMAKE_STATIC_LINKER_FLAGS_INIT
   106. CMAKE_TRY_COMPILE_CONFIGURATION
   107. CMAKE_TRY_COMPILE_PLATFORM_VARIABLES
   108. CMAKE_TRY_COMPILE_TARGET_TYPE
   109. CMAKE_USE_RELATIVE_PATHS
   110. CMAKE_VISIBILITY_INLINES_HIDDEN
   111. CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD
   112. CMAKE_VS_INCLUDE_PACKAGE_TO_DEFAULT_BUILD
   113. CMAKE_WIN32_EXECUTABLE
   114. CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS
   115. CMAKE_XCODE_ATTRIBUTE_<an-attribute>
   116. <<EXECUTABLE_OUTPUT_PATH>>
	1. 作用: 重新指定最终二进制目标的路径
	2. 设置: set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
	3. 备注: 一个重要的问题是,配置这个变量的这条指令应当写在哪个CMakeLists.txt中呢,其基本原则是在哪里 [[ADD_EXECUTABLE]] 或 [[ADD_LIBRARY]],如果需要改变目标存放路径,就在哪里加入上述的定义
	4. 相关: [[add_subdirectory]]()
   117. LIBRARY_OUTPUT_PATH
	1. 作用: 重新指定最终生成的共享库的路径
	2. 设置: set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
5. Variables for Languages
   1. CMAKE_COMPILER_IS_GNUCC
   2. CMAKE_COMPILER_IS_GNUCXX
   3. CMAKE_COMPILER_IS_GNUG77
   4. CMAKE_CUDA_HOST_COMPILER
   5. CMAKE_CUDA_EXTENSIONS
   6. CMAKE_CUDA_STANDARD
   7. CMAKE_CUDA_STANDARD_REQUIRED
   8. CMAKE_CUDA_TOOLKIT_INCLUDE_DIRECTORIES
   9. CMAKE_CXX_COMPILE_FEATURES
   10. CMAKE_CXX_EXTENSIONS
   11. CMAKE_CXX_STANDARD
   12. CMAKE_CXX_STANDARD_REQUIRED
   13. CMAKE_C_COMPILE_FEATURES
   14. CMAKE_C_EXTENSIONS
   15. CMAKE_C_STANDARD
   16. CMAKE_C_STANDARD_REQUIRED
   17. CMAKE_Fortran_MODDIR_DEFAULT
   18. CMAKE_Fortran_MODDIR_FLAG
   19. CMAKE_Fortran_MODOUT_FLAG
   20. CMAKE_INTERNAL_PLATFORM_ABI
   21. CMAKE_<LANG>_ANDROID_TOOLCHAIN_MACHINE
   22. CMAKE_<LANG>_ANDROID_TOOLCHAIN_PREFIX
   23. CMAKE_<LANG>_ANDROID_TOOLCHAIN_SUFFIX
   24. CMAKE_<LANG>_ARCHIVE_APPEND
   25. CMAKE_<LANG>_ARCHIVE_CREATE
   26. CMAKE_<LANG>_ARCHIVE_FINISH
   27. <<CMAKE_<LANG>_COMPILER>>
       1. <<CMAKE_C_COMPILER>>
       2. 参考 [[Languages]]
   28. CMAKE_<LANG>_COMPILER_ABI
   29. CMAKE_<LANG>_COMPILER_ARCHITECTURE_ID
   30. CMAKE_<LANG>_COMPILER_EXTERNAL_TOOLCHAIN
   31. <<CMAKE_<LANG>_COMPILER_ID>>
       1. 参考 [[Variables and Properties]]
   32. CMAKE_<LANG>_COMPILER_LOADED
   33. CMAKE_<LANG>_COMPILER_PREDEFINES_COMMAND
   34. CMAKE_<LANG>_COMPILER_TARGET
   35. <<CMAKE_<LANG>_COMPILER_VERSION>>
   36. CMAKE_<LANG>_COMPILER_VERSION_INTERNAL
   37. CMAKE_<LANG>_COMPILE_OBJECT
   38. CMAKE_<LANG>_CREATE_SHARED_LIBRARY
   39. CMAKE_<LANG>_CREATE_SHARED_MODULE
   40. CMAKE_<LANG>_CREATE_STATIC_LIBRARY
   41. <<CMAKE_<LANG>_FLAGS>>
       1. <<CMAKE_C_FLAGS>>: 存储c编编译过程中的所有flags
          1. 可以通过[[add_compile_options]]命令以及[[add_definitions]]设置flags,但是不推荐,因为这两个命令设置的值对所有的编译器都有效.推荐使用set,它只对指定的编译器有效
	  2. 该变量一旦定义,则[[CFLAGS]]将会被忽略,因此该变量的值在没有赋值之前为空
          3. 建议使用set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O3 -Wall")这种方式将CMAKE_C_FLAGS 设置为 -O3 -Wall (注意不是追加)
	  4. 参考 [[Variables and Properties]]
   42. CMAKE_<LANG>_FLAGS_DEBUG
   43. CMAKE_<LANG>_FLAGS_DEBUG_INIT
   44. CMAKE_<LANG>_FLAGS_INIT
   45. CMAKE_<LANG>_FLAGS_MINSIZEREL
   46. CMAKE_<LANG>_FLAGS_MINSIZEREL_INIT
   47. CMAKE_<LANG>_FLAGS_RELEASE
   48. CMAKE_<LANG>_FLAGS_RELEASE_INIT
   49. CMAKE_<LANG>_FLAGS_RELWITHDEBINFO
   50. CMAKE_<LANG>_FLAGS_RELWITHDEBINFO_INIT
   51. CMAKE_<LANG>_GHS_KERNEL_FLAGS_DEBUG
   52. CMAKE_<LANG>_GHS_KERNEL_FLAGS_MINSIZEREL
   53. CMAKE_<LANG>_GHS_KERNEL_FLAGS_RELEASE
   54. CMAKE_<LANG>_GHS_KERNEL_FLAGS_RELWITHDEBINFO
   55. CMAKE_<LANG>_IGNORE_EXTENSIONS
   56. CMAKE_<LANG>_IMPLICIT_INCLUDE_DIRECTORIES
   57. CMAKE_<LANG>_IMPLICIT_LINK_DIRECTORIES
   58. CMAKE_<LANG>_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES
   59. CMAKE_<LANG>_IMPLICIT_LINK_LIBRARIES
   60. CMAKE_<LANG>_LIBRARY_ARCHITECTURE
   61. CMAKE_<LANG>_LINKER_PREFERENCE
   62. CMAKE_<LANG>_LINKER_PREFERENCE_PROPAGATES
   63. CMAKE_<LANG>_LINK_EXECUTABLE
   64. CMAKE_<LANG>_OUTPUT_EXTENSION
   65. CMAKE_<LANG>_PLATFORM_ID
   66. CMAKE_<LANG>_SIMULATE_ID
   67. CMAKE_<LANG>_SIMULATE_VERSION
   68. CMAKE_<LANG>_SIZEOF_DATA_PTR
   69. CMAKE_<LANG>_SOURCE_FILE_EXTENSIONS
   70. CMAKE_<LANG>_STANDARD_INCLUDE_DIRECTORIES
   71. CMAKE_<LANG>_STANDARD_LIBRARIES
   72. CMAKE_Swift_LANGUAGE_VERSION
   73. CMAKE_USER_MAKE_RULES_OVERRIDE_<LANG>
6. Variables for CTest
   1. CTEST_BINARY_DIRECTORY
   2. CTEST_BUILD_COMMAND
   3. CTEST_BUILD_NAME
   4. CTEST_BZR_COMMAND
   5. CTEST_BZR_UPDATE_OPTIONS
   6. CTEST_CHANGE_ID
   7. CTEST_CHECKOUT_COMMAND
   8. CTEST_CONFIGURATION_TYPE
   9. CTEST_CONFIGURE_COMMAND
   10. CTEST_COVERAGE_COMMAND
   11. CTEST_COVERAGE_EXTRA_FLAGS
   12. CTEST_CURL_OPTIONS
   13. CTEST_CUSTOM_COVERAGE_EXCLUDE
   14. CTEST_CUSTOM_ERROR_EXCEPTION
   15. CTEST_CUSTOM_ERROR_MATCH
   16. CTEST_CUSTOM_ERROR_POST_CONTEXT
   17. CTEST_CUSTOM_ERROR_PRE_CONTEXT
   18. CTEST_CUSTOM_MAXIMUM_FAILED_TEST_OUTPUT_SIZE
   19. CTEST_CUSTOM_MAXIMUM_NUMBER_OF_ERRORS
   20. CTEST_CUSTOM_MAXIMUM_NUMBER_OF_WARNINGS
   21. CTEST_CUSTOM_MAXIMUM_PASSED_TEST_OUTPUT_SIZE
   22. CTEST_CUSTOM_MEMCHECK_IGNORE
   23. CTEST_CUSTOM_POST_MEMCHECK
   24. CTEST_CUSTOM_POST_TEST
   25. CTEST_CUSTOM_PRE_MEMCHECK
   26. CTEST_CUSTOM_PRE_TEST
   27. CTEST_CUSTOM_TEST_IGNORE
   28. CTEST_CUSTOM_WARNING_EXCEPTION
   29. CTEST_CUSTOM_WARNING_MATCH
   30. CTEST_CVS_CHECKOUT
   31. CTEST_CVS_COMMAND
   32. CTEST_CVS_UPDATE_OPTIONS
   33. CTEST_DROP_LOCATION
   34. CTEST_DROP_METHOD
   35. CTEST_DROP_SITE
   36. CTEST_DROP_SITE_CDASH
   37. CTEST_DROP_SITE_PASSWORD
   38. CTEST_DROP_SITE_USER
   39. CTEST_EXTRA_COVERAGE_GLOB
   40. CTEST_GIT_COMMAND
   41. CTEST_GIT_INIT_SUBMODULES
   42. CTEST_GIT_UPDATE_CUSTOM
   43. CTEST_GIT_UPDATE_OPTIONS
   44. CTEST_HG_COMMAND
   45. CTEST_HG_UPDATE_OPTIONS
   46. CTEST_LABELS_FOR_SUBPROJECTS
   47. CTEST_MEMORYCHECK_COMMAND
   48. CTEST_MEMORYCHECK_COMMAND_OPTIONS
   49. CTEST_MEMORYCHECK_SANITIZER_OPTIONS
   50. CTEST_MEMORYCHECK_SUPPRESSIONS_FILE
   51. CTEST_MEMORYCHECK_TYPE
   52. CTEST_NIGHTLY_START_TIME
   53. CTEST_P4_CLIENT
   54. CTEST_P4_COMMAND
   55. CTEST_P4_OPTIONS
   56. CTEST_P4_UPDATE_OPTIONS
   57. CTEST_SCP_COMMAND
   58. CTEST_SITE
   59. CTEST_SOURCE_DIRECTORY
   60. CTEST_SVN_COMMAND
   61. CTEST_SVN_OPTIONS
   62. CTEST_SVN_UPDATE_OPTIONS
   63. CTEST_TEST_LOAD
   64. CTEST_TEST_TIMEOUT
   65. CTEST_TRIGGER_SITE
   66. CTEST_UPDATE_COMMAND
   67. CTEST_UPDATE_OPTIONS
   68. CTEST_UPDATE_VERSION_ONLY
   69. CTEST_USE_LAUNCHERS
7. Variables for CPack
   1. CPACK_ABSOLUTE_DESTINATION_FILES
   2. CPACK_COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY
   3. CPACK_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION
   4. CPACK_INCLUDE_TOPLEVEL_DIRECTORY
   5. CPACK_INSTALL_SCRIPT
   6. CPACK_PACKAGING_INSTALL_PREFIX
   7. CPACK_SET_DESTDIR
   8. CPACK_WARN_ON_ABSOLUTE_INSTALL_DESTINATION
Blog creation time:[2017-11-08 三 09:24]
** WAITTING [#D] Theme:cmake-command 						   :@Blog:@Cmake:
    SCHEDULED:<2017-11-08 三>
1. Scripting Commands:
   1. break
   2. cmake_host_system_information
   3. <<cmake_minimum_required>>
      1. 泛型: cmake_minimum_required(VERSION major.minor[.patch[.tweak]] [FATAL_ERROR])
      2. 如果当前cmake的版本比该命令设置的版本VERSION还低,则会停止处理该项目,然后报告一个错误
      3. 该命令会隐式调用cmake_policy(VERSION),用于指定当前工程是在哪个版本的cmake上进行搭建的,因此,最好在该命令中设置cmake --version显示的版本
      4. 建议使用cmake_minimum_required而不是cmake_policy,因为前者调用了后者,同时,cmake_minimum_required禁止了当前版本小于VERSION的情况,这对项目的维护是有利的
      5. 备注: cmake_minimum_required给出的版本会传递给 cmake_policy, 这就意味着在新版本的cmake中的相关的策略会unset掉,此时需要结合警告信息,以及当前版本的版本号,去查看在cmake_minimum_required以及当前版本之间给出的policy,然后调用cmake_policy(SET CMP[NNNN])
   4. cmake_parse_arguments
   5. <<cmake-policy>>
      1. cmake_policy: 详情参见cmake-policies
      2. Setting Policies by CMake Version
	 1. cmake_policy(VERSION major.minor[.patch[.tweak]])
	 2. 上述命令指定当前的CMakeLists.txt是为给定版本的CMake书写的
	 3. 所有在指定的版本或更早的版本中引入的策略会被设置为使用“新行为”
	 4. 所有在指定的版本之后引入的策略将会变为无效（unset）
	 5. 命令中指定的策略版本必须至少是2.4，否则命令会报告一个错误,为了得到支持早于2.4版本的兼容性特性，查阅策略CMP0001的相关文档
	 6. 备注: 通常不会去使用该命令,而是使用cmake_minimum_required命令
      3. Setting Policies Explicitly
	 1. cmake_policy(SET CMP<NNNN> NEW/OLD)
	 2. 示例: cmake_policy(SET CMP0048 NEW)
	 3. 对于某种给定的策略，该命令要求CMake使用新的或者旧的行为
	 4. 该命令本质上是在配置变量CMAKE_POLICY_DEFAULT_CMP<NNNN>
	 5. 到3.10版本为止,一共有71个策略,可以为每个策略设置新旧行为来让工程的兼容性更好
	 6. 备注: 策略中,旧的行为是在将来的版本中可能会被丢弃的,因此,工程中应当尽量少使用旧的策略
      4. Checking Policy Settings
	 1. cmake_policy(GET CMP<NNNN> <variable>)
	 2. 检查一个策略使用了NEW还是OLD行为,如果该策略没有被配置过,那么返回空
      5. CMake Policy Stack: 待续
   6. configure_file
   7. continue
   8. <<elseif>>
      1. 参见 [[if]]
   9. <<else>>
      1. 参见 [[if]]
   10. <<endforeach>>
       1. 参见 [[foreach]]
   11. <<endfunction>>
       1. 参见 [[function]]
   12. <<endif>>
       1. 参见 [[if]]
   13. <<endmacro>>
       1. 参见 [[macro]]
   14. <<endwhile>>
       1. 参见 [[while]]
   15. execute_process
   16. <<file>>
       1. 泛型1: file(WRITE | APPEND <filename> <content>...)
          1. 作用: 写/追加<content>所示的内容到指定文件<filename> 
	  2. WRITE: 写内容到文件<filename>,如果<filename>不存在,则创建并写入内容,如果<filename>已经存在,则覆盖
	  3. APPEND: 追加内容到文件<filename>,如果如果<filename>不存在,则创建并写入内容,如果<filename>已经存在,则追加在其后面
	  4. <filename>: 指定的文件,如果该文件是一个带路径的文件如 test/a.txt 如果目录test不存在,则创建
	  5. 备注: 如果这个文件是一个 build input, 则当这个文件的内容改变时,使用[[configure_file]]()来更新这个文件
       2. 泛型2: file(READ <filename> <variable> [OFFSET <offset>] [LIMIT <max-in>] [HEX])
	  1. 作用: 从文件<filename>中读内容,存储在该变量<variabes>内
	  2. 可以从给定的<offset>个字节开始，最多读取<max-in>个字节
	  3. HEX选项会将数据转换为十六进制表示（对二进制数据有用）
       3. 泛型3: file(STRINGS <filename> <variable> [<options>...])
	  1. 作用: 从文件<filename>解析ASCII字符串的列表,然后存储在变量<variabes>内
	  2. 文件中的二进制数据将会被忽略,回车（\ r，CR）字符被忽略
	  3. 注意: 解析的是ASCII,有UNICOUDE编码的中文等是无法解析的,解析的意思就是遍历文件中的所有ASCII字符,读取出来存在指定变量内
	  4. <options>:
	     1. LENGTH_MAXIMUM <max-len>: 只考虑至多给定长度的字符串
	     2. LENGTH_MINIMUM <min-len>: 只考虑最少给定长度的字符串
	     3. LIMIT_COUNT <max-num>: 限制要提取的不同字符串的数量
	     4. LIMIT_INPUT <max-in>: 限制从文件读取的输入字节数
	     5. LIMIT_OUTPUT <max-out>: 限制要存储在<变量>中的总字节数
	     6. NEWLINE_CONSUME: 将换行符（\ n，LF）作为字符串内容的一部分，而不是终止于它们
	     7. NO_HEX_CONVERSION: 除非给出此选项，否则Intel Hex和Motorola S-record文件将在读取时自动转换为二进制文件
	     8. REGEX <regex>: 只考虑匹配给定正则表达式的字符串
	     9. ENCODING <encoding-type>: 考虑给定编码的字符串。目前支持的编码是：UTF-8，UTF-16LE，UTF-16BE，UTF-32LE，UTF-32BE。如果没有提供ENCODING选项，并且文件有一个字节顺序标记，那么ENCODING选项将被默认为遵守字节顺序标记
       4. 泛型4: file(<HASH> <filename> <variable>)
	  1. 作用: 计算<filename>内容的加密散列并将其存储在<variable>中
	  2. 支持的<HASH>算法名称是由字符串（<HASH>）命令列出的
       5. 泛型5: file(GLOB <variable> [LIST_DIRECTORIES true|false] [RELATIVE <path>] [<globbing-expressions>...])
	  1. 作用: 生成匹配<globbing-expressions>的文件列表并将其存储到<variable>中
	  2. Globbing表达式与正则表达式类似，但要简单得多
	  3. 默认情况下，GLOB列出目录,如果LIST_DIRECTORIES设置为false，则结果中的目录将被忽略
	  4. 如果指定了RELATIVE标志，结果将作为给定路径的相对路径返回,结果将按照字典顺序排列
	  5. 不建议使用GLOB从源代码树中收集源文件列表。如果在添加或删除源时没有更改CMakeLists.txt文件，则生成的生成系统无法知道何时要求CMake重新生成。
	  6. Globbing表达式的几个例子:
	     1. *.cxx: 匹配所有扩展名为cxx的文件
	     2. *.vt?: 匹配所有扩展名为vta,...,vtz的文件
	     3. f[3-5].txt: 匹配f3.txt, f4.txt, f5.txt
       6. 泛型6: file(GLOB_RECURSE <variable> [FOLLOW_SYMLINKS] [LIST_DIRECTORIES true|false] [RELATIVE <path>] [<globbing-expressions>...])
	  1. GLOB_RECURSE模式将遍历匹配目录的所有子目录并匹配文件
	  2. 只有在给定FOLLOW_SYMLINKS或策略CMP0009未设置为NEW的情况下才会遍历符号链接的子目录
	  3. 默认情况下，GLOB_RECURSE从结果列表中省略目录,将LIST_DIRECTORIES设置为true将目录添加到结果列表中
	  4. 如果给定FOLLOW_SYMLINKS或策略CMP0009未设置为OLD，则LIST_DIRECTORIES将符号链接视为目录
	  5. Globbing表达式: /dir/*.py: 匹配/ dir和子目录中的所有python文件
       7. 泛型7: file(RENAME <oldname> <newname>)
	  1. 作用: 在从<oldname>到<newname>的文件系统中删除文件或目录，以原子方式替换目标
       8. 泛型8: file(REMOVE [<files>...])
       9. 泛型9: file(REMOVE_RECURSE [<files>...])
       10. 泛型10: file(MAKE_DIRECTORY [<directories>...])
       11. 泛型11: file(RELATIVE_PATH <variable> <directory> <file>)
       12. 泛型12: file(TO_CMAKE_PATH "<path>" <variable>)
       13. 泛型13: file(TO_NATIVE_PATH "<path>" <variable>)
       14. 泛型14: file(DOWNLOAD <url> <file> [<options>...])
       15. 泛型15: file(UPLOAD   <file> <url> [<options>...])
       16. 泛型16: file(TIMESTAMP <filename> <variable> [<format>] [UTC])
       17. 泛型17: file(GENERATE OUTPUT output-file  <INPUT input-file|CONTENT content> [CONDITION expression])
       18. 泛型18: file(<COPY|INSTALL> <files>... DESTINATION <dir> [FILE_PERMISSIONS <permissions>...] [DIRECTORY_PERMISSIONS <permissions>...] [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS] [FILES_MATCHING] [[PATTERN <pattern> | REGEX <regex>] [EXCLUDE] [PERMISSIONS <permissions>...]] [...])
       19. 泛型19: file(LOCK <path> [DIRECTORY] [RELEASE] [GUARD <FUNCTION|FILE|PROCESS>] [RESULT_VARIABLE <variable>] [TIMEOUT <seconds>])
   17. <<find_file>>
   18. <<find_library>>
       1. 泛型:
	  1. find_library (
	  2. <VAR>
	  3. name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
	  4. [HINTS path1 [path2 ... ENV var]]
	  5. [PATHS path1 [path2 ... ENV var]]
	  6. [PATH_SUFFIXES suffix1 [suffix2 ...]]
	  7. [DOC "cache documentation string"]
	  8. [NO_DEFAULT_PATH]
	  9. [NO_CMAKE_PATH]
	  10. [NO_CMAKE_ENVIRONMENT_PATH]
	  11. [NO_SYSTEM_ENVIRONMENT_PATH]
	  12. [NO_CMAKE_SYSTEM_PATH]
	  13. [CMAKE_FIND_ROOT_PATH_BOTH |
	  14. ONLY_CMAKE_FIND_ROOT_PATH |
	  15. NO_CMAKE_FIND_ROOT_PATH]
	  16. )
       2. 基本用法:
	  1. 用法一: find_library (<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
	  2. 用法二: find_library (<VAR> NAMES name1)
	     1. set(CMAKE_FIND_ROOT_PATH xx/yy)
	     2. set([[CMAKE_FIND_ROOT_PATH_MODE_LIBRARY]] ONLY)   只允许在xx/yy下搜索
	     3. find_library (MY_LIB NAMES libmylib.a libmylib.so)
	  3. add_executable(${PROJECT_NAME} main.c)
	  4. target_link_libraries(${PROJECT_NAME} ${MY_LIB})
       3. 作用: 查找(name | NAMES name1 [name2 ...] [NAMES_PER_DIR])所示的库文件
       4. <VAR>: 存储查找结果,如果找到了库文件,则将该文件(带绝对路径)存储在该变量内,如果没找到,该变量的值为<VAR>-NOTFOUND
       5. 如果找到了库文件,搜索过程将不再重复，除非该变量被清空,如果没有找到库文件,下次使用相同变量调用find_library()命令时，搜索过程会再次尝试
       6. NAMES: 指定一个或者更多个待搜索库的名字,当给NAMES选项赋予多个值时，默认情况下这个命令会一次考虑一个名字并搜索每个目录
       7. NAMES_PER_DIR选项告诉该命令一次考虑一个目录，并搜索其中的所有名称
       8. 给予NAMES选项的每个库名首先被认为是库文件名，然后考虑平台特定的前缀（例如lib）和后缀（例如.so）,因此可以直接指定libfoo.a等库文件名
       9. 如果找到的库是一个框架，那么<VAR>将被设置为框架<fullPath> /A.framework的完整路径。当框架的完整路径被用作库时，CMake将使用-framework A和-F <fullPath>将框架链接到目标
       10. HINTS, PANTS: 指明除了默认位置之外,还要搜索的目录. ENV var子选项从系统环境变量中读取路径
       11. PATH_SUFFIXES: 指定了每个搜索路径下待搜索的子路径
       12. DOC: 之后的参数用来作为cache中的注释字符串
       13. NO_DEFAULT_PATH: 如果指定了该选项，那么搜索的过程中不会有其他的附加路径,如果没有指定该选项，搜索过程如下：
	   1. NO_CMAKE_PATH: 默认会搜索cmake特有的cache变量中被指定的路径(这些变量是在用cmake命令行时，通过-DVAR=value指定的变量),如果指定了该选项,则跳过该搜索路径,但是还包括如下的路径
	      1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 [[CMAKE_PREFIX_PATH]] 中的每一个前缀
	      2. [[CMAKE_LIBRARY_PATH]]
	      3. [[CMAKE_FRAMEWORK_PATH]]
	   2. NO_CMAKE_ENVIRONMENT_PATH: 默认会搜索cmake特有的环境变量中被指定的路径,这是用户在shell配置中设置的变量,如过指定了该选项, 则跳过该搜索路径,但是还包括如下的路径
	      1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 CMAKE_PREFIX_PATH 中的每一个前缀
	      2. CMAKE_LIBRARY_PATH
	      3. CMAKE_FRAMEWORK_PATH
	   3. 搜索由HINTS选项指出的路径,这些应该是系统内省计算的路径
	   4. NO_SYSTEM_ENVIRONMENT_PAT: 默认会搜索标准的系统环境变量,如果指定了该选项，这些环境变量中的路径会被跳过,但是搜索的路径还包括：PATH LIB
	   5. NO_CMAKE_SYSTEM_PATH: 默认会搜索当前系统平台文件中定义的cmake变量,如果指定了该选项,这些变量中的路径将会被跳过,但是还包括如下的路径
	      1. 如果设置了[[CMAKE_LIBRARY_ARCHITECTURE]] ,则会搜索 <prefix>/lib/<arch> ,其中的<prefix>是 [[CMAKE_SYSTEM_PREFIX_PATH]] 中的每一个前缀
	      2. [[CMAKE_SYSTEM_LIBRARY_PATH]]
	      3. [[CMAKE_SYSTEM_FRAMEWORK_PATH]]
	   6. 搜索由PATHS或者精简版命令中指定的路径
       14. CMake变量[[CMAKE_FIND_ROOT_PATH]]指定一个或多个目录作为所有其他搜索目录的前缀
       15. [[CMAKE_SYSROOT]]变量也可以用来指定一个目录作为前缀
       16. 默认情况下，首先搜索CMAKE_FIND_ROOT_PATH中列出的目录,然后搜索CMAKE_SYSROOT目录，然后搜索非根目录的目录。默认行为可以通过设置[[CMAKE_FIND_ROOT_PATH_MODE_LIBRARY]]进行调整
       17. 在13中所示的行为可以通过下面的参数覆盖
	   1. CMAKE_FIND_ROOT_PATH_BOTH: 按照13所述的顺序搜索
	   2. ONLY_CMAKE_FIND_ROOT_PATH: 不使用CMAKE_FIND_ROOT_PATH变量
	   3. NO_CMAKE_FIND_ROOT_PATH: 只搜索re-rooted目录以及[[CMAKE_STAGING_PREFIX]]下的目录
       18. 默认的搜索顺序的设计逻辑是按照使用时从最具体到最不具体。通过多次调用find_library命令以及NO_*选项，可以覆盖工程的这个默认顺序
       19. 如果设置了[[CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX]]变量，所有的搜索路径将被正常测试，附带后缀，并且所有匹配的lib /替换为lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/
	   1. 如果[[FIND_LIBRARY_USE_LIB32_PATHS]]全局属性被设置，所有的搜索路径将被正常测试，32 /附加，lib /所有匹配替换为lib32 /。如果至少启用了project（）命令支持的一种语言，则会自动为已知需要的平台设置此属性
	   2. 如果[[FIND_LIBRARY_USE_LIB64_PATHS]]全局属性被设置，所有的搜索路径将被正常地测试，64 /追加，并且所有匹配的lib /替换为lib64 /。如果至少启用了project（）命令支持的一种语言，则会自动为已知需要的平台设置此属性
       20. 变量CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX将覆盖FIND_LIBRARY_USE_LIB32_PATHS，FIND_LIBRARY_USE_LIBX32_PATHS和FIND_LIBRARY_USE_LIB64_PATHS全局属性
   19. <<find_package>>
   20. <<find_path>>
   21. <<find_program>>
   22. <<foreach>>
       1. 泛型1：
	  1) set(mylist arg1 arg2 arg3)
	  2) foreach(loop_var ${mylist})
	  3) message(STATUS “${loop_var}”)
	  4) endforeach(loop_var)	  
	  5) 
	  6) 返回： arg1 arg2 arg3
       2. 泛型2： 
	  1) set(result 0)
	  2) foreach(_var RANGE 0 100)
	  3) math(EXPR result "${result}+${_var}")
	  4) endforeach()
	  5) message("from 0 plus to 100 is:${result}")
	  6) 
	  7) 返回： 5050
	  8) 备注：如果是foreach(_var RANGE 30),则表示从0~30,如果是foreach(_var RANGE 4 10 2),则表示从4~10，步长为2
       3. 泛型3：
	  1) foreach(loop_var IN [LISTS [list1 [...]]] [ITEMS [item1 [...]]])
	  2) 作用： 暂未研究
   23. <<function>>
       1. 泛型: 
          1. function(<name>  [arg1 [arg2 [arg3 ...]]])
	  2. COMMAND1(... arg1 ...)
	  3. COMMAND1(... arg2 ...)
	  4. COMMAND1(... arg3 ...)
          5. COMMAND1(... ARGC ...)
          6. COMMAND2(... ARGV1 ...)
          7. COMMAND3(... ARGV2 ...)
	  8. ......
	  9. COMMAND4(... ARGVN ...)
          10. endfunction(<name>)
       2. 作用: 定义一个名为<name>的函数
       3. function()与[[macro]]()的区别: 在宏中设置的的变量在可以在外部被访问到,而在函数中设置的变量是局部的,外部无法访问
       4. 函数的语法以及参数的传递同macro()别无二致,参考它即可
       5. 想要使得函数内部定义的变量可以被外部访问到也有可行的方法: function(T tmp)  set(${tmp} "hello" PARENT_SCOPE)  endfunction(T) 外部就可以 T(V2)message(STATUS "V2=${V2}"),返回hello,注意set(${tmp} ... PARENT_SCOPE)的写法(必须这样写),tmp想象成C语言中的函数传入指针和传入变量的问题就可以理解为什么是${tmp}而不是tmp了,使用 PARENT_SCOPE 是因为函数会构建一个局部作用域
       6. 说明: 除非函数 <name> 被调用,否则在function()以及endfunction()之间的命令不会被调用
       7. 注意: 函数内部的变量应当让他外部不可见,如果非要让外部可见,那么最好使用macro
   24. get_cmake_property
   25. get_directory_property
   26. get_filename_component
   27. <<get_property>>
       1. 泛型:
	  1. get_property(
	  2. <variable>
	  3. <
	  4. GLOBAL             |
	  5. DIRECTORY [dir]    |
	  6. TARGET    <target> |
	  7. SOURCE    <source> |
	  8. INSTALL   <file>   |
	  9. TEST      <test>   |
	  10. CACHE     <entry>  |
	  11. VARIABLE
	  12. >
	  13. PROPERTY <name>
	  14. [SET | DEFINED | BRIEF_DOCS | FULL_DOCS])
       2. 第一个参数<variable>: 该参数是一个变量,用于存储该命令获取属性的结果
       3. 第二个参数<...>: 决定了获取该属性的作用域
       4. 第三个参数PROPERTY是必须的,它后面紧跟要获取的属性名(在set_property中给出),如果该属性没有被设置，该命令将返回空值
       5. 第四个参数: 如果给定了SET选项，那么返回值会被设置为一个布尔值，用来指示该属性是否被设置过。如果给定了DEFINED选项，那么返回值会被设置为一个布尔值，用来指示该属性是否被类似于define_property的命令定义过。如果指定了BRIEF_DOCS或者FULL_DOCS选项，那么该变量将会被设置为被查询属性的文档的字符串。如果被请求的属性的文档没有被定义，将返回NOTFOUND。
   28. <<if>>
       1. 泛型:
	  1. if(expression)
	  2. # then section.
	  3. COMMAND1(ARGS ...)
	  4. COMMAND2(ARGS ...)
	  5. #...
	  6. elseif(expression2)
	  7. # elseif section.
	  8. COMMAND1(ARGS ...)
	  9. COMMAND2(ARGS ...)
	  10. #...
	  11. else(expression)
	  12. # else section.
	  13. COMMAND1(ARGS ...)
	  14. COMMAND2(ARGS ...)
	  15. #...
	  16. endif(expression)
       2. 执行逻辑: 首先是(exepreesion)被计算
       3. expressions的可选类型: 注意,需要 cmake_policy(SET CMP0012 NEW)才能使用下面给出的关键字
	  1. if(<constant>): 如果constant的值是 1, ON, YES, TRUE, Y, 或者  non-zero 数字,则为true; 如果constant的值是 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND, the empty string, or ends in the suffix -NOTFOUND 则为false,命名布尔常量不区分大小写。如果参数不是这些特定常量中的一个，则将其视为变量或字符串，并使用以下签名
	  2. if(<variable|string>): 如果给定的变量没有被定义为使得常量值为false的那些值，则为真否则为假（注意宏参数不是变量）
	  3. if(NOT <expression>): 如果<expression>是false,则为true
	  4. if(<expr1> AND <expr2>): 如果两个表达式都为 true, 结果才为true
	  5. if(<expr1> OR <expr2>): 只要有一个表达式为 true, 结果就为true
	  6. if(COMMAND command-name): 如果给定的 command-name 是可以调用的命令，宏或函数，则为true
	  7. if(POLICY policy-id): 如果给定的 policy-name 是现有策略（形式为CMP<NNNN>,如CMP0012),则为true
	  8. if(TARGET target-name): 如果给定的target-name是通过调用的add_executable（），add_library（）或add_custom_target（）命令（在任何目录中）创建的现有逻辑目标名称，则为true
	  9. if(TEST test-name): 如果给定名称是由add_test（）命令创建的现有测试名称，则为true
	  10. if(EXISTS path-to-file-or-directory):如果指定的文件或目录存在，则为真。只有完整路径的行为才被定义好
	  11. if(file1 IS_NEWER_THAN file2): 如果file1比file2更新或两个文件之一不存在，则为true。只有完整路径的行为才被定义好。如果文件时间戳完全相同，则IS_NEWER_THAN比较返回true，以便在发生平局时发生任何相关的构建操作。这包括为file1和file2传递相同的文件名的情况
	  12. if(IS_DIRECTORY path-to-directory): 如果给定的名称是一个目录，则为真。只有完整路径的行为才被定义好
	  13. if(IS_SYMLINK file-name): 如果给定名称是符号链接，则为真。只有完整路径的行为才被定义好
	  14. if(IS_ABSOLUTE path): 如果给定的路径是绝对路径，则为真
	  15. if(<variable|string> MATCHES regex): 如果给定的字符串或变量的值与给定的正则表达式匹配，则为真
	  16. if(<variable|string> LESS <variable|string>): 如果给定的字符串或变量的值是有效的数字并且小于右边的值，则为真
	  17. if(<variable|string> GREATER <variable|string>): 如果给定的字符串或变量的值是有效的数字并且大于右边的值，则为真
	  18. if(<variable|string> EQUAL <variable|string>): 如果给定的字符串或变量的值是一个有效的数字并且等于右边的数字，则为真
	  19. if(<variable|string> LESS_EQUAL <variable|string>): 如果给定的字符串或变量的值是有效的数字并且小于或等于右边的值，则为真
	  20. if(<variable|string> GREATER_EQUAL <variable|string>): 如果给定的字符串或变量的值是有效数字并且大于或等于右边的值，则为真
	  21. if(<variable|string> STRLESS <variable|string>): 如果给定的字符串或变量的值按字典顺​​序小于右侧的字符串或变量，则为真
	  22. if(<variable|string> STRGREATER <variable|string>): 如果给定的字符串或变量的值按字典顺​​序大于右侧的字符串或变量，则为真
	  23. if(<variable|string> STREQUAL <variable|string>): 如果给定的字符串或变量的值按字典顺​​序等于右侧的字符串或变量，则为真
	  24. if(<variable|string> STRLESS_EQUAL <variable|string>): 如果给定的字符串或变量的值按字典顺​​序小于或等于右侧的字符串或变量，则为真
	  25. if(<variable|string> STRGREATER_EQUAL <variable|string>): 如果给定的字符串或变量的值按字典顺​​序大于或等于右侧的字符串或变量，则为真
	  26. if(<variable|string> VERSION_LESS <variable|string>): 组件式整数版本号比较（版本格式是主要[.minor [.patch [.tweak]]]）
	  27. if(<variable|string> VERSION_GREATER <variable|string>)
	  28. if(<variable|string> VERSION_EQUAL <variable|string>)
	  29. if(<variable|string> VERSION_LESS_EQUAL <variable|string>)
	  30. if(<variable|string> VERSION_GREATER_EQUAL <variable|string>)
	  31. if(<variable|string> IN_LIST <variable>): 如果给定元素包含在指定的列表变量中，则为true
	  32. if(DEFINED <variable>): 如果给定变量已定义，则为真。变量是否是真或者假是没有关系的，只要它已经被设置就没有关系（注意宏参数不是变量）
	  33. if((expression) AND (expression OR (expression))): 首先评估括号内的表达式，然后再评估其余的表达式。如果有嵌套圆括号，则最内层是作为评估包含它们的表达式的一部分来评估的
       4. [[while]]()的语法与if的一致
   29. <<include>>
       1. 泛型: include(<file|module> [OPTIONAL] [RESULT_VARIABLE <VAR>] [NO_POLICY_SCOPE])
       2. 作用: 从一个文件或者一个模块加载然后运行CMake代码
       3. 被include的文件里面的变量的作用域是动态的,取决于调用include命令调用者
       4. 如果存在OPTIONAL，那么如果文件不存在则不会产生错误
       5. 如果给出RESULT_VARIABLE，该变量将被设置为已经包含的完整文件名，或者失败时将被设置为NOTFOUND
       6. 如果指定了模块而不是文件，则首先在CMAKE_MODULE_PATH中搜索名称<modulename> .cmake的文件，然后在CMake模块目录中搜索
       7. 有一个例外：如果调用include（）的文件位于CMake内置模块目录中，则首先搜索CMake内置模块目录，然后搜索[[CMAKE_MODULE_PATH]]。另见策略CMP0017。
   30. include_guard
   31. list
   32. <<macro>>
       1. 泛型:
          1. macro(<name>  [arg1 [arg2 [arg3 ...]]])
	  2. COMMAND1(... arg1 ...)
	  3. COMMAND1(... arg2 ...)
	  4. COMMAND1(... arg3 ...)
          5. COMMAND1(... ARGC ...)
          6. COMMAND2(... ARGV1 ...)
          7. COMMAND3(... ARGV2 ...)
	  8. ......
	  9. COMMAND4(... ARGVN ...)
          10. endmacro(<name>)
       2. 作用: 定义一个名为<name>的宏
       3. 调用宏示例:
	  1. 在cmake/xxx.make中给出如下宏定义
	  2. macro(macro_test arg1 arg2)
	  3. message(STATUS "ARGC=${ARGC}")                                               
          4. message(STATUS "ARGV0=${ARGV0}")                                             
          5. message(STATUS "ARGV1=${ARGV1}")                                             
          6. message(STATUS "ARGV2=${ARGV2}")                                             
          7. message(STATUS "ARGN=${ARGN}")                                               
          8. endmacro(macro_test)     
	  9. 
	  10. 在CMakeLists.txt中给出如下代码
	  11. include(cmake/xxx.make)
	  12. macro_test("hello" "word" "hi")
	  13. 
	  14. 结果: 
	  15. ARGC = 3
	  16. ARGV0 = hello
	  17. ARGV1 = world
	  18. ARGV2 = hi
	  19. ARGV =  hello;world;hi
	  20. ARGN = hi
       4. 参数说明: 比如存在宏定义 macro(T arg1 arg2), 调用 T("t1" "t2" "t3" "t4"),
       5. ARGC 记录传入参数的个数: 3
       6. ARGV0: 记录第1个传入参数的值: t1 
       7. ARGV1: 记录第2个传入参数的值: t2
       8. ARGV2: 记录第3个传入参数的值: t3
       9. ARGV: 记录传入的所有参数列表: t1;t2;t3;t4
       10. ARGN: 记录超出宏定义参数的那些参数: t3;t4
       11. 注意: 宏参数不是变量,而if(<variabes>)要求一个变量,这意味着如果在宏内部想要使用if()而且要和宏参数做关联,需要先使用set()将宏参数赋值给一个变量,然后用这个变量去传递给if()
       12. macro()与[[function]]()的区别在于: 在宏中设置的的变量在外部被访问到,而在函数中设置的变量是局部的
   33. mark_as_advanced
   34. <<math>>
       1. 泛型： math(EXPR <output-variable> <math-expression>)
       2. 作用： EXPR计算<math-expression>的值，将结果保存在<output_variable>中
       3. <output_variable>支持的操作符有+, -, *, /, %, |, &, ^, ~, <<, >>, and (...)，他们与C里面的操作符有相同的意思
   35. <<message>>
       1. 泛型: message([<mode>] "message to display")
       2. 作用:显示一条信息给用户
       3. <mode>:
	  1. (none)         = Important information
	  2. STATUS         = Incidental information
	  3. WARNING        = CMake Warning, continue processing
	  4. AUTHOR_WARNING = CMake Warning (dev), continue processing
	  5. SEND_ERROR     = CMake Error, continue processing,but skip generation
	  6. FATAL_ERROR    = CMake Error, stop processing and generation
	  7. DEPRECATION    = CMake Deprecation Error or Warning if variable CMAKE_ERROR_DEPRECATED or CMAKE_WARN_DEPRECATED is enabled, respectively, else no message
   36. option
   37. return
   38. separate_arguments
   39. set_directory_properties
   40. <<set_property>>
       1. 泛型:
	  1. set_property(
	  2. <
	  3. GLOBAL                            |
	  4. DIRECTORY [dir]                   |
	  5. TARGET    [target1 [target2 ...]] |
	  6. SOURCE    [src1 [src2 ...]]       |
	  7. INSTALL   [file1 [file2 ...]]     |
	  8. TEST      [test1 [test2 ...]]     |
	  9. CACHE     [entry1 [entry2 ...]]
	  10. >
	  11. [APPEND] [APPEND_STRING]
	  12. PROPERTY <name> [value1 [value2 ...]])
       2. 作用: 在一个给定作用域内设置一个<name>的属性
       3. 第一个参数<...>: 决定该<name>的属性可以影响的作用域,有以下几种选择:
	  1. GLOBAL: 全局作用域，唯一，并且不接受名字
	  2. DIRECTORY: 路径作用域，默认为当前路径，但是也可以用全路径或相对路径指定其他值
	  3. TARGET: 目标作用域,可以命名0个或多个已有的目标
	  4. SOURCE: 源文件作用域，可以命名0个或多个源文件。注意，源文件属性只对加到相同路径（CMakeLists.txt）中的目标是可见的
	  5. INSTALL:  安装文件作用域, 可以命名0个或多个已经安装的文件的路径
	  6. TEST:  测试作用域,可以命名0个或多个已有的测试
	  7. CACHE: 作用域必须指定0个或多个cache中已有的条目
       4. 第二个参数APPEND
       5. 第三个参数PROPERTY: 该选项是必须的，其后面紧跟一个变量<name>,该变量之后是变量的值
       6. 使用场合: 该命令可以实现将子目录下的变量共享,让父目录能访问到
       7. 特点: 该方法设置的变量必须通过get_property才能访问到
       8. 典型用法: set_property(GLOBAL PROPERTY CURR_PATH_DIR "${CMAKE_CURRENT_LIST_DIR}/include/1.2")
       9. 引用: get_property(tmp GLOBAL PROPERTY CURR_PATH_DIR)  message(STATUS "${tmp}")
   41. <<set>>: 
       1. 作用: 为 普通变量,cache变量,环境变量 赋值
       2. 特点: 使用set定义的变量可以从父目录传递到子目录,但是不能从子目录传递到父目录(实现变量共享的另外一个方法是使用 set_property 命令)
       3. 提示: 变量的值均是字符串类型,因此,推荐使用双引号将<value>包含
       4. 普通变量: set(<variable> <value>... [PARENT_SCOPE])
	  1. 含义: 在[PARNET_SCOPE]给出的范围之内,为变量<variable>设置值<value>
	  2. 注意,通常会省略[PARENT_SCOPE],表示在变量被设置的值在当前函数或者当前目录范围内有效
	  3. 如果给出了[PARENT_SCOPE],那么,变量被设置的值在[PARENT_SCOPE]所示的范围内有效,此时该变量将会传递到父目录或者调用它的那个函数
       5. cache变量: set(<variable> <value>... CACHE <type> <docstring> [FORCE])
       6. 环境变量: set(ENV{<variable>} <value>...)
	  1. 作用: 为 
	  2. 示例: set(ENV{[[CMAKE_C_FLAGS]]} "-O3 -Wall")
   42. site_name
   43. string
   44. unset
   45. variable_watch
   46. <<while>>
       1. 泛型:
	  1. while(condition)
	  2. COMMAND1(ARGS ...)
	  3. COMMAND2(ARGS ...)
	  4. ...
	  5. endwhile(condition)
       2. 作用: 在条件为真的时候计算一组命令
       3. 示例:  while(__queue AND NOT ${resultvar}) ... endwhile()
       4. while 中 condition 的语法参考 [[if]]()命令
       5. 另一个常用的循环命令是 [[foreach]]()
2. Project Commands:
   1. <<add_compile_options>>
      1. 泛型: add_compile_options(-std=c++11)
      2. 备注: 该令添加的编译选项是针对所有编译器的(包括c和c++编译器)，而set命令设置[[CMAKE_C_FLAGS]]或[[CMAKE_CXX_FLAGS]]变量则是分别只针对c和c++编译器的
      3. 使用set(CMAKE_CXX_FLAGS "-std=c++11 ${CMAKE_CXX_FLAGS}")比使用add_compile_option好,因为set只针对CMAKE_CXX_FLAGS配置,而不会对CMKAE_C_FLAGS配置
      4. 建议使用set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O3 -Wall")这种方式将CMAKE_C_FLAGS 设置为 -O3 -Wall (注意不是追加)
      5. 查阅 [[COMPILE_OPTIONS]]
   2. add_custom_command
   3. add_custom_target
   4. <<add_definitions>>
      1. 泛型:add_definitions(-DFOO -DBAR ...)
      2. 作用: 该命令可以用来增加任何flags,但是,主要是用它来增加预处理定义,增加其他flag的命令为 [[add_compile_options]]()
      3. 那些以-D或/D开头的、看起来像预处理器定义的flag，会被自动加到当前路径的[[COMPILE_DEFINITIONS]]属性中
      4. FOO以及BAR可以在源文件中使用,如ifdef FOO ...... endif
      5. 备注: 该命令是针对所有编译器的
   5. <<add_dependencies>>
   6. <<add_executable>>
      1. 泛型1: add_executable(<name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...])
	 1. 作用: 使用源文件列表中指定的源文件来构建可执行目标<name>
	 2. <name>对应于逻辑目标名字，并且在工程范围内必须是全局唯一的
	 3. 默认情况下，可执行文件将会在构建树的路径下被创建，对应于该命令被调用的源文件树的路径。如果要改变这个位置，查看[[RUNTIME_OUTPUT_DIRECTORY]]目标属性的相关文档
	 4. 果要改变最终文件名的<name>部分，查看[[OUTPUT_NAME]]目标属性的相关文档
	 5. 如果指定了WIN32选项,那么, WIN32_EXECUTABLE 这个属性将会在目标被创建的时候被设置
	 6. 如果指定了MACOSX_BUNDLE选项，对应的属性会附加在创建的目标上,查看MACOSX_BUNDLE目标属性的文档可以找到更多的细节
	 7. 如果指定了EXCLUDE_FROM_ALL选项，对应的属性将会设置在被创建的目标上。查看EXCLUDE_FROM_ALL目标属性的文档可以找到更多的细节
	 8. 源文件列表source1 [source2 ...] 到 add_executable 可以使用语法为$<...> 的 “生成器表达式”,更多信息查看 [[cmake-generator-expressions]]
      2. 泛型2: add_executable(<name> IMPORTED [GLOBAL])

      3. 泛型3: add_executable(<name> ALIAS <target>)
   7. <<add_library>>
      1. Normal Libraries
	 1. 泛型:
	    1. add_library(
	    2. <name> [STATIC | SHARED | MODULE]
	    3. [EXCLUDE_FROM_ALL]
	    4. source1 [source2 ...]
	    5. )
	 2. 作用: 创建一个名为<name>的库,该库中的目标集合通过给出的源文件列表构建
	 3. 参数<name>: 一个项目中全局且独一无二的终极目标
	 4. [STATIC | SHARED | MODULE]: 指明被创建的库的类型
	    1. STATTIC 库是目标文件的归档文件,在链接其他目标的时候使用
	    2. SHARD 库被动态链接,在运行时加载
	    3. MODULE库是不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数动态链接
	    4. 对于 SHARD 和 MODULE 库, [[POSITION_INDEPENDENT_CODE]] 目标属性会自动被设置为ON
	    5. 对于 SHARD 和 STATIC 库,为了创建 OS X Framework, [[FRAMEWORK]] 目标属性会被标记
	    6. 备注: 如果没有明确的给出类型参数,那么是 STATIC 还是 SHARD 取决于变量 [[BUILD_SHARD_LIBS]]
	    7. 如果一个库不导出任何符号,那么这个库一定不能声明为 SHARD ,这是因为CMake在Windows上希望一个SHARD 库总是有一个与之相关联的导入库
	 5. [EXCLUDE_FROM_ALL]: 如果该选项被给出,相应的属性在目标被创建时将会被设置,细节参看 [[EXCLUDE_FROM_ALL]] 
	 6. 默认情况下库文件将会在于源文件目录树的构建目录树的位置被创建，该命令也会在这里被调用
	 7. 查阅[[ARCHIVE_OUTPUT_DIRECTORY]]，[[LIBRARY_OUTPUT_DIRECTORY]]，和[[RUNTIME_OUTPUT_DIRECTORY]]这三个目标属性的文档来改变创建库文件的位置
	 8. 查阅[[OUTPUT_NAME]]目标属性的文档来改变最终文件名的<name>部分
      2. Imported Libraries
      3. Object Libraries
      4. Alias Libraries
      5. Interface Libraries
   8. <<add_subdirectory>>
      1. 泛型: add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
      2. 参数source_dir指定了子目录的文件名,每个子目录下面都有一个CMakeLists.txt
      3. [binary_dir]指定中间二进制文件以及目标二进制文件存放的位置,比如指定为bin,那么存放的路径就是build/bin,这个选项一般不用,因为有更好的方法,那就是将目标文件单独存放在一个目录,即同中间文件分开
      4. EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除
      5. 备注: 通常只会使用第一个参数,第二个参数关于目标路径问题,参考 [[EXECUTABLE_OUTPUT_PATH]] 以及 [[LIBRARY_OUTPUT_PATH]] 
   9. add_test
   10. <<aux_source_directory>>
       1. 泛型: aux_source_directory(<dir> <variable>)
       2. 作用: 在指定目录<dir>下收集所有的源文件,然后存储在<variable>中
   11. build_command
   12. create_test_sourcelist
   13. define_property
   14. <<enable_language>>
       1. 使用方法: 在 [[project]](T NONE) 中禁用所有语言,然后使用 enable_language(CXX) 使能C++语言
       2. 使用何种语言意义重大,它决定了一些重要信息: 编译器的版本以及供应商,目标架构和位宽,相关工具的位置等,在跨平台是还决定了采用何种工具链,详情参考[[Introduction]]
       3. 该命令实质上是配置了 [[ENABLED_LANGUAGES]] 
   15. enable_testing
   16. export
   17. fltk_wrap_ui
   18. get_source_file_property
   19. get_target_property
   20. get_test_property
   21. include_directories
       1. 
       2. 
       3. 
   22. include_external_msproject
   23. include_regular_expression
   24. <<install>>
       1. Introduction
	  1. 该命令为一个项目生成安装规则,安装的内容可以包括 目标、动态库、静态库以及文件、目录、脚本
	  2. DESTINATION: 指定文件将被安装在磁盘上的哪个目录下,可以给出绝对路径,也可以给出相对路径,相对路径时会加上变量 [[CMAKE_INSTALL_PREFIX]] 给出的前缀
	  3. PERMISSIONS: 指定待安装文件的权限: OWNER_READ, OWNER_WRITE, OWNER_EXECUTE, GROUP_READ, GROUP_WRITE, GROUP_EXECUTE, WORLD_READ, WORLD_WRITE, WORLD_EXECUTE, SETUID, and SETGID
	  4. CONFIGURATIONS: Specify a list of build configurations for which the install rule applies (Debug, Release, etc.).
	  5. COMPONENT: 
       2. Installing Targets
	  1. 泛型:
	     1. install(
	     2. TARGETS
	     3. targets... [EXPORT <export-name>]
	     4. [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE|
	     5. PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]
	     6. [DESTINATION <dir>]
	     7. [PERMISSIONS permissions...]
	     8. [CONFIGURATIONS [Debug|Release|...]]
	     9. [COMPONENT <component>]
	     10. [OPTIONAL] [NAMELINK_ONLY|NAMELINK_SKIP]
	     11. ] [...]
	     12. )
	  2. 
	  3. 
       3. Installing Files
       4. Installing Directories
       5. Custom Installation Logic
       6. Installing Exports
       7. 作用: 用于定义安装规则,
       8. 泛型:
	  1. 
	  2. 
	  3. 
	  4. 
	  5. 
	  6. 
   25. link_directories
       1. 泛型: link_directories(directory1 directory2 ...)
       2. 作用: 指出链接器将在哪个目录下搜索库
       3. 很少会需要使用这个命令,因为,[[find_package]]() and [[find_library]]() 这两个命令可以返回库位置的绝对路径,然后直接将这个绝对路径传递给[[target_link_libraries]]()
       4. CMake中应当确保链接器能找到相应的库
   26. link_libraries
   27. load_cache
   28. project
       1. 泛型:
	  1. 泛型1: project(<PROJECT-NAME> [LANGUAGES] [<language-name>...])
	  2. 
	  3. 泛型2: project(<PROJECT-NAME>
	  4. [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]
	  5. [DESCRIPTION <project-description-string>]
	  6. [LANGUAGES <language-name>...])
       2. 作用: 为整个项目设置 名字, 版本, 描述, 语系
       3. 为项目设置名字: 该命令会将整个项目的名字设置为泛型中给出的<PROJECT-NAME>, 并将其存入变量PROJECT-NAME中
       4. 为项目设置版本号:
	  1. 除非 policy CMP0048 is set to NEW ,不然的话,选项 VERSION 可能不会被使用到(使用cmake_policy(SET CMP0048 NEW)命令进行设置)
	  2. 如果上面泛型2中需要指明 VERSION ,那么要求给出的版本号应当是一个非负整数
	  3. 如果没有指定 VERSION, 那么默认的版本号将会是一个空字符串
	  4. VERSION存入: <PROJECT-NAME>_VERSION, <PROJECT-NAME>_VERSION_MAJOR, <PROJECT-NAME>_VERSION_MINOR,<PROJECT-NAME>_VERSION_PATCH,<PROJECT-NAME>_VERSION_TWEAK中
	  5. 备注: 当然了,PROJECT_VERSION,PROJECT_VERSION_MAJOR,PROJECT_VERSION_MINOR,PROJECT_VERSION_PATCH,PROJECT_VERSION_TWEAK中也会记录版本信息,但是不推荐
       5. 为项目设置描述信息: 该命令会将项目的描述信息设置为泛型中给出的DESCRIPTION,并将其存入变量PROJECT_DESCRIPTION中
       6. 为项目设置支持的语言: 如果没有给出该选项,默认支持C,CXX语言
       7. 顶层的CMakeLists.txt文件必须包含project命令
   29. qt_wrap_cpp  
   30. qt_wrap_ui
   31. remove_definitions
   32. set_source_files_properties
   33. set_target_properties
   34. set_tests_properties
   35. source_group
   36. target_compile_definitions
   37. target_compile_features
   38. target_compile_options
   39. target_include_directories
   40. target_link_libraries
   41. target_sources
   42. try_compile
   43. try_run
3. CTest Commands:
   1. ctest_build
   2. ctest_configure
   3. ctest_coverage
   4. ctest_empty_binary_directory
   5. ctest_memcheck
   6. ctest_read_custom_files
   7. ctest_run_script
   8. ctest_sleep
   9. ctest_start
   10. ctest_submit
   11. ctest_test
   12. ctest_update
   13. ctest_upload
4. Deprecated Commands:  这些已经弃用的命令仅仅只是为了兼容老版本,在新版本中已经不再使用这些命令了
   1. build_name
   2. exec_program
   3. export_library_dependencies
   4. install_files
   5. install_programs
   6. install_targets
   7. load_command
   8. make_directory
   9. output_required_files
   10. remove
   11. subdir_depends
   12. subdirs
   13. use_mangled_mesa
   14. utility_source
   15. variable_requires
   16. write_file
Blog creation time:[2017-11-08 三 08:53]
