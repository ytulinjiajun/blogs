* blogs-makefile-active
** DONE [#D] theme:专题2:linux开发stm32之Makefile			:@Blog:@Makefile:
   - State "DONE"       from "TODO"       [2017-09-04 一 23:00]
*** 声明
>>规则 = 目标： 依赖
         <回车>命令
备注：研究makefile实际就是研究：规则，目标，依赖，命令四者之间的关系

>>$@:目标文件集；$<依赖文件集，这两个变量都是最常用的自动化变量，有它两的地方，基本上
都少不了有模式匹配：%

>>Makefile 中的第一个目标会被作为其默认目标,默认目标的特性是，总是会被执行，即使它是
一个伪目标（大家都知道，伪目标只能外部调用，但是如果伪目标放在Makefile中的第一个位置，
成了默认目标，那么它就会被自动执行）

>>理论上，一个Makefile只会有一个终极目标，该目标会依据依赖关系派生出其他目标，但是，有
all的情况是个特例

>>伪目标的特性：伪目标做为标签，在被执行之后不会生成文件，结合Makefile 中的第一个
目标的特性：总是会被执行。结合这两个特性，能够产生一个十分不错且常规的
功能：一口气生成多个目标
*** 目录搜索：VPATH和vpath：
>>工程由文件组成，文件有不同种类(源代码.c,汇编.S,头文件.h,目标文件.o,二进制
文件.hex),文件还被组织在不同的目录中，这些不同目录中不同种类的文件正是构成Makefile
规则中的基本操作对象

>>Makefile中的规则在执行过程中，会根据依赖文件和目标文件的时间戳的新旧关系来决定是否
要执行当前目标下的命令，然而，这里有一个问题，Makefilez自己是不能知道依赖文件和目标文件
的路径的，需要用户告诉它，它才能自动去推导

>>使用VPATH和vpath正是这么一个告诉Makefile目标文件和依赖文件路径的操作，注意我的措辞，
VPATH和vpath指明的是“目标文件”和“依赖文件”的搜索路径，所以，“命令”中，需要单独使用-I
来指明头文件路径

>>VPATH是一个特殊变量，作为变量，它自然可以有值，VPATH的赋值方式为：VPATH = dir1 dir2 ...
即，VPATH的值是目录，指明该变量的值以后，Makefile在执行时，会首先在该Makefile文件所在的
当前目录下搜索涉及的目标文件和依赖文件，如果找不到，就会到VPATH所指明的dir1下面搜索，如果
找不到，就到dir2目录下找如果始终没找到，就会报错！

>>vpath是一个关键字，它的用法是：vpath %.c dir1 dir2,其工作的步骤是，首先在该Makefile
文件所在的当前目录下搜索符合模式%.c的文件，如果找不到，就会到vpath所指明的dir1下面搜索，
如果找不到，就到dir2目录下找如果始终没找到，就会报错！
*** 伪目标
>>伪目标不是一个文件，而是一个标签，所以伪目标在被执行之后不会生成文件

>>伪目标的取名不能和文件名重名

>>请使用一个特殊的标记“.PHONY”来显式地指明一个目标是“伪目标”

>>伪目标只能通过外部显示的调用

>>伪目标一般没有依赖文件，但是也可以为伪目标指明依赖文件，比较特殊且常用的一个具有
依赖文件的伪目标是all,它有着大作用！

>>伪目标的三大运用：
(1)一口气生成多个目标
.PHONY: all
all: prog1 prog2 prog3

prog1: prog1.o utils.o
	cc -o prog1 prog1.o utils.o
prog2: prog2.o
	cc -o prog2 prog2.o
prog3: prog3.o sort.o utils.o
	cc -o prog3 prog3.o sort.o utils.o
原理：
--伪目标是一个标签而不是一个文件，一般只能由外部调用
--Makefile的第一个目标(默认目标)一定会被执行
--一般情况下，一个Makefile只会有一个终极目标，该目标会依据依赖关系派生出其他目标，所以，
可以称该终极目标为Makefile的“入口”，即，一个Makefile一般有一个“入口”
--过程：伪目标all放在了Makefile的第一个目标出，必然被执行，然而执行的结果却不产生目标文件
所以，其依赖项必然会被决议（prog1 prog2 prog3均被当做“入口”），也就达到了一口气生成多个
目标的目的

(2)install:

(3)清楚目标，以便重新编译
.PHONY: clean
clean:
	rm -f *.o
备注：既然我们生成了许多文件编译文件,那也应该提供一个清除它们的“目标”以备完整地重编译而用

(4)让伪目标带有依赖文件的妙用：
.PHONY: cleanall 
cleanall: cleanobj cleandiff
	rm program
.PHONY: cleanobj 
cleanobj:
	rm *.o
.PHONY: cleandiff
cleandiff:
	rm *.diff
--前面说过，伪目标一般是不带依赖文件的，但是有时候带上依赖文件却时有大作用
--从第一个例子得出结论，目标可以成为依赖，所以，伪目标也可以成为依赖
原理：伪目标不能生成文件，外部调用cleanall时，会引起决议，伪目标后面带的依赖文件均会被
作为入口，并发执行这些“入口”，所以，调用cleanall的结果是执行rm program，然后是rm *.o  
最后是rm *.diff
*** 自动变量
>>$@:在具有模式规则(%.c)的条件下，表示规符合匹配要求的目标文件集合；而在普通情况下，
表示目标文件集合

>>$<:在具有模式规则(%.c)的条件下，表示符合匹配要求的依赖文件集合；而在普通情况下，
表示依赖文件集合中的第一个依赖文件

>>$^:只在普通情况下使用，表示规则中所有的依赖文件的集合，以空格分隔，如果在依赖
文件中有多个重复的,那个这个变量会去除重复的依赖文件,只保留一份

>>$+:只在普通情况下使用，同$^作用相同,区别在于，如果在依赖文件中有多个重复的,
它不去除重复的依赖目标

>>$?:只在普通情况下使用，表示规则中所有比目标文件新的依赖文件的集合，以空格分隔。
当你希望只对更新过的依赖文件进行操作时,“$?”在显式规则中很有用

>>$*:在模式匹配中，$*表示%及其之前的部分，例如，目标的模式匹配为a.%.b,且目标是
dir/a.foo.b,那么$*就是dir/a.foo,这个变量对于构造有关联的文件名是比较有用，
如果目标中没有模式的定义,那么“$*”也就不能被推导出
*** 模型推导
**** 基础版本：
edit: main.o kbd.o command.o display.o insert.o search.o files.o utils.o
	cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit $(objects)
**** 改良版一：使用变量
objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o

edit: $(objects)
	cc -o edit $(objects)
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit $(objects)
**** 改良版二：自动推导
GNU 的 make 很强大,它可以自动推导文件以及文件依赖关系后面的命令，只要 make 看到
一个.o 文件,它就会自动的把.c 文件加在依赖关系中,如果 make 找到一个 whatever.o,
那么 whatever.c,就会是 whatever.o 的依赖文件。并且 cc -c whatever.c也会被推导
出来,于是,我们的 makefile 再也不用写得这么复杂。我们的新 makefile 又出炉了

objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o

edit: $(objects)
	cc -o edit $(objects)
main.o: defs.h
kbd.o: defs.h command.h
command.o: defs.h command.h
display.o: defs.h buffer.h
insert.o: defs.h buffer.h
search.o: defs.h buffer.h
files.o: defs.h buffer.h command.h
utils.o: defs.h
.PHONY : clean
clean:
	rm edit $(objects)
备注：这里的自动推导实际上是利用了make的隐式规则，make 和我们约定好了：
第一：只要 make 看到一个.o 文件,它就会自动的把.c 文件加在依赖关系中
第二：用 C 编译器“cc”编译.c：$(CC) –c $(CPPFLAGS) $(CFLAGS)
总结：隐式规则使得我们可以做出以上简化而实际效果是同基础范式一样的
**** 改良版三：使用多目标规则
objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o

edit: $(objects)
	cc -o edit $(objects)
$(objects): defs.h
kbd.o command.o files.o: command.h
display.o insert.o search.o files.o: buffer.h
.PHONY: clean
clean:
	rm edit $(objects)
备注：该模式的与静态模式有莫大的渊源，应当弄清楚二者的区别与联系
**** 改良版三(终极版)：使用静态模式
objects = foo.o bar.o
all: $(objects)
$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@

通俗理解：从$(objects)中匹配出%.o的文件，然后%.o和%.c互相匹配，从而构造出符合匹配模型
的规则，上面的例子按照其含义可推导如下：
foo.o bar.o： foo.c bar.c
	$(CC) -c $(CFLAGS) $< -o $@
其中：-c和-o同时出现的情况，表示-c(编译)为-o所指出的文件名而不是按照默认方式
上面的规则继续分解：
foo.o: foo.c
	 $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o: bar.c
	 $(CC) -c $(CFLAGS) bar.c -o bar.o

特别地：
%.o: %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
表示将所有的%.c挨个取出来编译(-c),编译后的目标命名(-o)为%.o
**** 简化终极版：自动生成依赖性
在Makefile中,我们的依赖关系可能会需要包含一系列的头文件，但是,如果是一个比较大型
的工程,你必需清楚哪些 C 文件包含了哪些头文件,并且,你在加入或删除头文件时,也需要小心地修改 
Makefile,这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情,我们可以使用 
C/C++ 编译的一个功能。大多数的 C/C++编译器都支持一个“-M”的选项,即自动找寻源文件中包含
的头文件,并生成一个依赖关系
*** 多目标以及多目标规则
>>一个规则中可以有多个目标,规则所定义的命令对所有的目标有效，多目标规则意味着所有的目标
具有相同的依赖文件
例如：test1.o test2.o test3.o: command.h
分析：根据模型推导中改良版二所述，该规则描述了但command.h的时间戳比test1.o test2.o 
test3.o中任意目标的时间戳新时，就会触发隐式命令$(CC) –c $(CPPFLAGS) $(CFLAGS) $@
所以，该语句的真实身份应该如下：
test1.o test2.o test3.o: test1.c test2.c test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) $@

>>一个具有多目标的规则相当于多个规则
分析：以上面的例子而言，该句的意思相当于：（应该是下面两种中的一种，具体是哪种，需要测试）
test1.o: test1.c test2.c test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test1.c -Ixx
test2.o: test1.c test2.c test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test2.c -Ixx
test3.o: test1.c test2.c test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test3.c -Ixx
---------------------
test1.o: test1.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test1.c -Ixx
test2.o: test2.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test2.c -Ixx
test3.o: test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test3.c -Ixx

其中：-Ixx是command.h的路径
备注：所有依赖文件将会被合并成此目标一个依赖文件列表,当其中任何一个依赖文件比目标新时，
命令都会被执行，所以，对于test1.o test2.o test3.o: command.h不难得出结论：
当依赖列表(test1.c test2.c test3.c command.h)中任意一个文件的时间戳比目标列表
(test1.o test2.o test3.o)中的某个，某两个，某三个新时，那么，test1.o test2.o test3.o
各自对应的命令就会得到执行

>>规则的命令对不同的目标的执行效果不同,因为在规则的命令中可能使用了自动环变量“$@”，
而且多目标规则确实也少不了$@,但是，多目标的规则并不能做到根据目标文件自动改变依赖文件(像
上边例子中使用自动化变量“$@”改变规则的命令一样)。需要实现这个目的是,要用到make的静态模式
通俗理解：多目标规则依托自动变量$@，能够根据目标，自动改变命令，但是，不能根据目标，自动
改变依赖，后者的实现可通过静态模式

>>一个仅仅描述依赖关系的述规则可用来给出一个或做多个目标文件的依赖文件:
分析：Makefile 中通常存在一个变量,就像以前我们提到的“objects”,它定义为所有的
需要编译生成的.o 文件的列表。当这些.o 文件在其源文件及其所包含的头文件“config.h”
发生变化之后能够自动的被重建,我们可以使用多目标的方式来书写 Makefile:
objects = foo.o bar.o
foo.o: defs.h
bar.o: defs.h test.h
$(objects): config.h
这样做的好处是:我们可以在源文件增加或者删除了包含的头文件以后不用修改已经存
在的Makefile的规则,只需要增加或者删除某一个.o文件依赖的头文件（如bar.o: defs.h test.h）
中的test.h,当然，头文件的依赖描述也可以使用自动生成依赖性章节所描述的方法产生！

>>多目标，很简单也很方便，对于一个大的工程来说,这样做的好处是显而易见的，在一个大的工程中,
对于一个单独目录下的.o文件的依赖规则建议使用此方式。（我感觉，还有更好的方案？？）
规则中头文件的依赖描述规则也可以使用gcc自动产生。可参考 4.14 自动产生依赖 一节
*** 静态模式
>>静态模式的规则:存在多个目标,并且不同的目标可以根据目标文件的名字来自动构造出依赖文件

>>例子：
objects = foo.o bar.o
all: $(objects)
$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@
通俗理解：从$(objects)中匹配出%.o的文件，然后%.o和%.c互相匹配，从而构造出符合匹配模型
的规则，上面的例子按照其含义可推导如下：
foo.o bar.o： foo.c bar.c
	$(CC) -c $(CFLAGS) $< -o $@
其中：-c和-o同时出现的情况，表示-c(编译)为-o所指出的文件名而不是按照默认方式
上面的规则继续分解：
foo.o: foo.c
	 $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o: bar.c
	 $(CC) -c $(CFLAGS) bar.c -o bar.o

静态模式规则比多目标规则更通用,它不需要多个
目标具有相同的依赖。但是静态模式规则中的依赖文件必须是相类似的而不是完全相同
的
*** 自动生成依赖性
>>目的：在Makefile中,我们的依赖关系可能会需要包含一系列的头文件，但是,如果是一个比较大型
的工程,你必需清楚哪些 C 文件包含了哪些头文件,并且,你在加入或删除头文件时,也需要小心地修改 
Makefile,这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情,我们可以使用 
C/C++ 编译的一个功能。大多数的 C/C++编译器都支持一个“-M”的选项,即自动找寻源文件中包含
的头文件,并生成一个依赖关系

>>基本使用：gcc -M main.c,其输出结果是：
main.o: main.c def.h 
备注：GNU 的 C/C++ 编译器,你得用“-MM”参数,不然,“-M”参数会把一些标准库的头文件也包含进来

>>如此一来，由编译器自动生成的依赖关系,这样一来,你就不必再手动书写若干文件的依赖关系,
而由编译器自动生成了

>>那么，编译器的这个功能如何与我们的 Makefile 联系在一起呢？GNU 组织建议,为每一个源文件
产生一个描述其依赖关系的makefile文件,即，编译器为每一个NAME.c的源文件都生成一个
NAME.d的Makefile文件作为中间文件，NAME.d中描述了文件NAME.o所要依赖的所有文件
备注：每一个源文件(xxx.c xxx.S)都对应一个中间文件(xxx.d xxx.d)

>>这样做的目的是：采用这种方式,只有源文件在修改之后才会重新使用命令生成新的依赖关系描述
文件NAME.o,通俗理解:xxx.c的内容发生改变后(去掉yy.h)，使用make命令编译，如果Makefile
中有下面的语句，那么，xxx.d中会重新生成新的依赖(xxx.o: xxx.c),即，去掉yy.h

>>规则：该模式规则用来自动生成每一个NAME.c文件对应的NAME.d 文件:
%.d: %.c
	$(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$
含义：指定所有的.d 文件依赖于同名的.c 文件
理解：第一行，使用 c 编译器自动生成依赖文件($<)的头文件的依赖关系,并输出成为一个临时文件,
“$$$$”表示当前进程号，注意，如果$(CC)为 GNU 的 c 编译工具，-M产生的依赖头文件除了用户
定义的头文件之外还有系统头文件，如果不想包含系统头文件，使用-MM。所以，第一行执行完毕后，
应当产生了NAME.c的临时Makefile文件，NAME.d，并且里面有依赖关系：NAME.o: NAME.c xxx.h 
注意，这个依赖关系存在于NAME.d这个Makefile文件下

第二行，处理NAME.d中的NAME.o: NAME.c xxx.h，生成多规则目标的形式：
NAME.o NAME.d: NAME.c xxx.h,这样就将NAME.d 加入到了规则的目标中,根据多规则目标的知识，
当NAME.c xxx.h的时间戳比NAME.o NAME.d新时，命令会被重新执行，NAME.o NAME.d都会被重新
生成

第三行，删除临时文件NAME.d

>>使用上例的规则就可以建立一个描述目标文件依赖关系的.d文件。我们可以在Makefile中使用
include指示符将描述将这个文件包含进来。在执行make时,Makefile所包含的所有.d文件就会被
自动创建或者更新,具体过程可参考 3.7 makefile文件的重建一节
*** 隐式规则	
Blog creation time:[2017-08-29 二 08:00]
** DONE [#D] theme:makefile中vpath，规则中依赖部分.h，规则中recipe的命令中-I参数三者关系的认识 :@Blog:@Makefile:
	- State "DONE"       from "TODO"       [2017-09-04 一 23:00]
	今天分析Makefile过程中，研究了关于头文件依赖问题，有以下认识：
--vpath是一个关键字，定义了一组规则的依赖部分查找的路径，比如：
vpath %.c CORE/src USER/src
vpath %.h CORE/inc USER/inc
	我们不禁会问，这个vpath给出的路径究竟有什么用，正如其定义的意义所言，用于规则的依赖文件
的查找，当编译器分析到一组规则时，总会拿依赖文件和目标文件的时间戳做比较，来决定是否执行
recip命令，比较的前提自然是先找到依赖文件：
（1）首先会在当前路径下查找，找不到的话
（2）到vpath指定的路径下查找找不到的话
（3）分析Makefile中其他规则是否有生成该依赖，都没有的话就会报错
显然，这个vpath的用途自然在于编译源文件的规则中，因为其他规则如链接，都会走（3）的路线

--规则中依赖文件中.h又该怎样理解呢，它和vpath有什么关系？
	既然它在该规则中依赖文件的位置，说明该规则的目标受到它的制约，这种制约一般是该规则的
目标（源文件）中引入了该头文件，所以该头文件发生变化，该目标会重新编译生成。既然说了该.h
文件是依赖文件，那么，也就可以通过vpath的%.h路径来寻找，所以，在Makefile中如果定义了
vpath %.h，那么在规则的依赖中.h相关的只用写出它的文件名加.h后缀即可，不用标明全路径，
该规则会根据vpath去%.h路径下查找：%o: %c main.h
	注意，有了vpath,我们的依赖中，只用使用%.c来表示依赖文件即可（比如/USER/src/main.c）,
因为程序会到vpath路径下匹配所有.c结尾的文件放到此处。但是，注意了，亲测，%.h,不可以这么干，
好像理论上可以，这么干的朋友应该是这么思考的：“每个.c文件的头文件依赖多个.h,要时刻关注
这个.c文件和其依赖的.h文件，并在适当时候在Makefile中做出增减，这是很烦人的事情，不如让
每个.c都依赖与所有的.h吧，于是写出了%.o: %.c %.h"这样的语法”，这中做法是非常不高效的，
我猜测，现在的编译器不允许这么干了， 一种好的方法是自动生成依赖关系技术（利用-MM）,详情见
Makefile中文手册

--规则中，命令部分的-I又干了什么，这里说的规则自然就是编译生成目标的那条规则啦，-I的
作用的在gcc -c的时候告诉编译器如果.c中出现了#include <xxx.h>,应该去-I指出的路径下
查找。注意了-I指出的头文件路径和vpath以及依赖处的.h是没有太大关系的

结论：
	一个Makefile中，应该使用自动依赖生成技术来解决头文件的依赖关系，所以呢，vpath中
%.h应该是没有什么必要了
Blog creation time:[2017-08-31 四 15:36]
** DONE [#D] theme:gcc										:@Blog:@Makefile:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
*** 基本操作
--预处理：
gcc -E test.c -o test.i

--编译：
gcc -S test.i -o test.s

--汇编(compilation)
gcc -c test.s -o test.o

--链接：
gcc test.o -o test

--运行：
./test

--变形一：适合在单独使用gcc时使用，因为一步到位，简单
gcc test.c -o test

--变形二：适合在Makefile中使用，因为符合Makefile中依赖的处理方案
gcc -c test.c -o test.o
gcc test.o -o test

总结：
>> 口头语：gcc “谁” ， -o "什么"

>> “谁”，代表输入，“什么”，代表输出

>> -o一律理解为：输出(output)即可 

>> 实际干活时，基本上都使用变形式，基本式一般在调试过程中使用

>> 以变形一为例子：参数一般加在test.c的前面和后面，前面一般加的参数有：-E(预处理), -S(编译)， -c(汇编)，这三个参数的加入直接决定 -o(输出)的文件类型，
此时必须严格对应四个基础式；test.c后面加的参数一般有-O,-Wall,-g,-I,-l,-L,-Shared等
*** 隐含规则
--“N.o”自动由“N.c” 生成,执行命令为“$(CC) -c $(CPPFLAGS) $(CFLAGS)”

--“N.o”自动由“N.cc”或者“N.C” 生成,执行命令为“$(CXX) -c $(CPPFLAGS) $(CFLAGS)”
建议使用“.cc”作为C++源文件的后缀,而不是“.C

--“N.s”是不需要预处理的汇编源文件,“N.S”是需要预处理的汇编源文件，汇编器为“as”，
“N.o” 可自动由“N.s”生成,执行命令是:“$(AS) $(ASFLAGS)”，“ N.s ” 可 由 “ N.S ” 生 成 , 
C 预 编 译 器 “ cpp ”, 执 行 命 令 是 :“ $(CPP) $(CPPFLAGS)”

备注：这意味着，我们可以在Makefile中定义一下CPPFLAGS和CFLAGS这两个变量，在书写
关于生成机器码（*.o）的目标文件时，可以省略掉依赖文件中的*.c以及命令，因为隐含规则
会自动被使用
*** 模式规则
--Makefile中自己定义了一些隐含规则，但是有时候这些隐含规则不够我们使用，所以我们需要自己定义
一些隐含的规则，称用户自己定义的隐含规则为模式规则

--模式规则的基本要求：模式规则的目标有且仅有一个%，用于匹配任意非空的字符串

--定义一个自己的隐含规则：
%.o : %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $^ -o $@
备注：如此，便定义了一个用户的隐含规则，make会把该规则加入到自己的隐含规则里面，该规则
表示把任意一个%.c的文件都使用该规则描述的命令编译成%.o文件

--任意模式匹配规则：
% ： %.c
	touch $@
备注：该规则表示将任意一个目标都更新一下
任意模式匹配规则可以匹配任意一个target,但是，这种理解起来需要注意一点，比如:foo:foo.o bar.o,
由于默认隐含规则中指明foo.o是依赖于foo.c的，但是套用%：%.c得出的结果是foo.o:foo.o.c,这个就有问题，
在makefile中，有两种机制来解决这种问题的，第一种机制：先使用默认的隐含规则来寻找，找不到才会使用这种任意模式规则，
由于foo.o的默认隐含规则就匹配到foo.c了，所以，就不会再去理会用户自己定义的隐含规则：任意模式匹配规则，来解析
出foo.o.c这样的依赖；第二种机制：用户使用双冒号来定义任意模式规则而不是单冒号，称为terminal规则，如：
% :: %.c
	touch $@
其中：双冒号对依赖进行了限制，只有依赖确实存在时，才会使用这种规则，比如，foo:foo.o,使用foo.o来套用这种
规则后是foo.o :: foo.o.c,双冒号规定了会对依赖文件的存在性进行检查，由于foo.o.c在当前目录下是找不到的，
所以，foo.o是不可以套用该规则的

--取消隐含规则
有时候，我们会觉得makefile自带的隐含规则用不到，多余，或者对真实的情况造成麻烦，就需要取消这些隐含规则，
取消的方法就是重新定义来覆盖掉默认的隐含规则，其原理是，当用户自定义的目标和依赖同默认的隐含规则的相同时，
默认的隐含规则就会被覆盖
例如：使用%.o:%.s就可以将所有.s文件汇编成机器码.o的默认规则给取消掉
*** 指令(编译+连接+运行)
情景一:
--test目录下:src inc两个目录 
--src目录下:hello thanks两个目录
--hello目录下:hello.c
--thanks目录下:thanks.c
--inc目录下:thanks.h
备注:hello.c文件中调用到thanks.c文件提供的一个函数thank_you(),所以thanks.h被hello.c文件和thank.c文件所依赖

编译:(在test目录下执行下面指令)
--gcc -c ./src/hello/hello.c ./src/thanks/thanks.c -Wall -O -I ./inc ./src/
-->-c:编译
-->-Wall:编译过程信息
-->-O:优化
-->-I:指定头文件路径:./inc
-->./src:编译后产生的目标文件放置到哪
语义:在test目录下执行gcc命令,编译./src/hello这个路径下面的hello.c以及./src/thanks这个路径下面的thanks.c,要求实时显示
编译产生的信息,同时做一个-O1的优化,由于thanks.h被hello.c文件和thank.c文件所依赖,所以将thank.h的路径./inc告知gcc,以便能找到路径
备注：有一个比较奇怪的写法：gcc -c test.c -o xxx.o 其含义同gcc -c test.c是一样的，只不过gcc -c test.c编译的结果默认是test.o,而
在gcc -c test.c后面加上-o xxx.o则表示希望编译的结果是xxx.o而不是test.o 


链接:
--gcc -o  test test.o test1.o test2.o
-->-o:链接
-->test:链接之后生成的可执行文件
-->*.o:被链接的目标文件

运行: ./test   -->  thank you very! hello world!
*** 静态库和动态库
**** 函数库:
	有若干源文件(.c),每个源文件里面都提供了一些独立的工具函数,比如一个好的算法策略,一个常用的数学函数公式的实现(标准偏差)等,
如果这些源文件需要经常被使用,或者这些工具函数已经比较成熟了,那么可以考虑将它们编译成一个函数库并统一命名,然后提供出这个函数库中
所有工具函数的函数原型如:void *malloc(size_t size),同时附上使用说明,以后如果使用到该函数库中的某一个函数时,只用在该函数库的说明文档
中找到该函数,然后参照使用说明,在编译时,将函数库与用户程序建立起联系,即可使用该函数
**** 静态库策略:
--策略概述:
-->制作出静态链接库文件
-->编译用户源代码,生成用户的目标文件
-->链接用户目标文件为可执行文件期间,将静态库.a链接进来,生成最终的可执行文件,其链接方式是:整个静态库被连接到了用户代码里面成了用户代码的一部分
特点:整个函数库被链接到用户代码中,所以生成的可执行文件比较大,但是执行速度快(不过如今CPU的运算速度高速发展,这点速度的提升已经没有太大的追求价值,而文件的
大小可能在嵌入式领域那种内存宝贵的情况下就比较看中,这也是静态连接没有动态连接火爆的原因吧)
备注:当同时运行许多运用程序并且他们都使用来自同一个函数库的函数时,内存中就会有同一个函数的多份副本,而且在程序文件自身中也会有很多份副本,这样将会消耗很多宝贵的内存

--细节:
-->在.c文件中的工具函数实现应该是独立的,不可再引用其他函数库(没有头文件)
-->函数库是在链接阶段(gcc -o main main.o -lstatic -L ./mylib)而不是编译阶段,被整合到用户的代码里面的
-->静态函数库发生改变时,整个程序必须重新编译
-->extern int a 和include "xxx.h"都是用来应付编译器的编译阶段,在编译源文件时,extern关键字告知编译器,a在其他文件定义了,虽然你现在找不到a,但是
我跟你保证a是存在的,现在你不要因为找不到a而报错,接着编译即可;到了连接阶段,所有源文件都已经编译成了目标文件,这时所有文件的内容都可见了,编译器就会
在所有的目标文件中查找有没有a,如果找到了a,那好,说明在编译阶段extern没有骗编译器,如果没有找到,那就报错;显然,include也有这样的功能,其目的就是解决编译器
在编译阶段因为暂时找不到某个编译对象而终止编译的情况,连接阶段就是真正考究编译正确性的时刻
--在Windows下,静态链接库文件以.lib为后缀,在Linux下,以.a为后缀,即archive

--静态库操作命令:arr
-->arr -cr libxxx.a yyy1.o yyy2.o:创建库libxxx.a并插入yyy1.o yyy2.o模块到该库(c,创建,r,c插入,注意,单独使用c是不会创建libxxx.a的,报错没有执行的操作,r就是一个操作)
-->arr -pv libxxx.a yyy.o:打印出静态库libxxx.a中的yyy.o的内容(p,打印,v标识各个模块)
-->arr -tv libxxx.a:显示库中的模块清单,只显示库名
-->arr -rv libxxx.a yyy1.o yyy2.o:在静态库libxxx.a中所有模块的最后插入模块yyy1.o,yyy2.o,如果静态库libxxx.a不存在则创建,并插入模块yyy1.o,yyy2.o,如果存在静态库,并且静态库
里面存在待插入的模块,则替换同名模块(r,插入,v显示操作信息:a - xx或者d - xx,即增加还是删除)
-->arr -qv libxxx.a yyy4.o:在静态库libxxx.a的结尾处快速追加模块yyy4.o,而不去检查是否需要替换
-->arr -dv libxxx.a yyy2.o:从静态库libxxx.a中删除模块yyy2.o(d,删除模块,v提示删除信息d - yyy2.o)
-->arr -s libxxx.a:写入符号表索引到库libxxx.a中 
备注:arr还有几个指令可以指定插入模块的位置,不过没有测试过,就不列举出来了,有需要时再man ar即可

总结:创建静态库常规的指令:arr -crs libxxx.a ${objects}
**** 动态库策略:
--策略概述:
-->制作出动态链接库文件
-->编译用户源代码,生成用户的目标文件
-->链接用户目标文件为可执行文件期间,将动态库.so链接进来,生成最终的可执行文件,其链接的方式是:动态链接库的名字以及库内部的所有函数名字被连接到用户代码里面
成为用户代码的一部分,而动态库内部函数的实现代码不会被连接进入用户代码,即,用户代码只是引用了动态库,链接的结果形成可执行文件,当可执行文件被执行时,通过该执行文件
内部在链接阶段加入的动态库名以及函数名,找到具体的动态库(.so)下面的具体的函数并调用,如果有必要的话才会将动态库加载到内存中去

特点:动态库策略在制作的动态库文件体积比较小,同时动态库策略使用的是一种共享的原则,不会在内存中产生库的多份拷贝,另外,动态库的一个好处是动态库的更新可以独立于依赖
它的运用程序,这句话有相当的份量,动态库在连接阶段只是将库名和所有函数原型封装到可执行文件中了,在以后调用可执行文件时会实时去动态库里面找具体的实现,这不就意味着,
只要我们不改变动态库的名字和函数原型,我们可以随意更改构成动态库的源代码(比如用一个更好的算法来替换某一个函数中一般的算法),该完以后,重新生成一遍动态库,替换掉老的,
那么当以前依赖该动态库的一些运用程序(比如test),当执行./test时,还是可以依据动态库名和函数原型去动态库(.so)找具体的实现,只不过现在的实现用了一个更加牛叉的算法来改善
了程序的性能而已,所以,针对那些个依赖该动态库的运用来说,是感受不到影响的,当然了,你如果针对动态库的某个函数不是做优化,而是直接改变其功能(比如将gui运用程序所调用的动态库的
某个描述颜色的函数的颜色值改变了),那么依赖该动态库的运用如果调用到该函数,则其主题颜色自然就发生改变,还有就是,以后也可以往该动态库中加入函数,由于是新加入的函数,以前依赖
该动态库的运用程序肯定没有用到自然也不会受到影响,新加入的函数能可以用于从这一版本的动态库发布后开发其他的运用;显然,删除动态库内的函数就一定得谨慎了,因为如果你删除的
这个函数如果恰好被某个运用程序调用过,那么,以后最新版本发布的动态库,如果那个运用进行了更新,那么基本上他的这个运用是不能运行了.

总结:综上所述,动态库也叫共享库,该共享库的制作者(发布者)可以修改,添加该共享库的函数的实现,但是删除共享库中的某一函数需要慎重,除非你决定在这一版本中,或者以后将不再
维护和支持该功能,明白你要做的事情之后才能进行删除,并且在产品发布的时候并告知用户不再支持某一项功能,基于这一个原因,为了避免程序更新而导致不能使用,当Linux启动运用程序时,
会考虑运用程序需要的函数版本,以防止动态库的新版本导致某些旧的运用程序无法使用

细节:
--可以使用ldd命令查看动态库的使用情况:ldd main 
--在Windows下,态链接库文件以.dll为后缀,即Dynamic Link Library,在Linux下以.so为后缀
--LD_LIBRARRY_PATH:该环境变量指示动态连接器可以装载动态库的路径
--静态库策略以空间换时间,动态库策略是以时间换空间
*** 制作静态链接库文件libstatic.a
--环境:
-->工作目录:test,该目录下有一个库目录libstatic,以及两个文件main.c,libstatic.h
-->libstatic目录下面有add.c,sub.c,mul.c,div.c,Makefile四个文件

--目的:
-->将libstatic目录下的.c文件生成静态库libstatic.a,在main.c中调用静态库中的工具函数
-->libstatic.h下面给出了静态库libstatic.a中的所有工具函数的原型

--实现步骤:
-->在4个文件内里面分别编写add.c,sub.c,mul.c,div.c文件:
float add(int a,int b)
{
	return (a+b);
}
float sub(int a,int b)
{
	return (a-b);
}
float mul(int a,int b)
{
	return (a*b);
}
float div(int a,int b)
{
	return (a/b);
}

-->编写库函数的头文件libstatic.h:
## libstatic.h
#ifndef _LIBSTATIC_H 
#define _LIBSTATIC_H
float add(int a,int b);
float sub(int a,int b);
float mul(int a,int b);
float div(int a,int b);
#endif

-->编写Makefile文件
objects = add.o sub.o mul.o div.o

libstatic.a : ${objects}
	ar -rcs libstatic.a ${objects}    将目标文件(.o)归档入库libstatic.a
备注:
--ar:静态库操作命令,参见上面的介绍
--libstatic.a:linux中默认规定静态库文件需要以lib开头,以.a结尾;
--${objects}:有很多.c文件,每个.c文件里面都是一些组成库libstatic.a的独立的工具函数,这些.c文件编译后会生成.o文件,${objects}就是这些.o文件的集合
这种书写方式在makefile文件中称之为宏,定义的格式是:macro = xx xx xx,其中xx可以是命令如gcc,也可以是选项参数如-Wall,也可以是路径./inc;使用的格式是:$(macro)或者${macro}

add.o : add.c
	gcc -c add.c

sub.o : sub.c
	gcc -c sub.c

mul.o : mul.c
	gcc -c mul.c

div.o : div.c
	gcc -c div.c

clean:
	rm libstatic.a $(objects)

-->生成静态库:make -f Makefile 

-->使用静态函数库libstatic.a
## main.c
#include <stdio.h>
#include "libstatic.h"

int main()
{
	int a,b;
	a = 10;
	b = 3;

	printf("a+b = %f\n",add(a,b));
	printf("a-b = %f\n",sub(a,b));
	printf("a*b = %f\n",mul(a,b));
	printf("a/b = %f\n",div(a,b));
	return 0;
}

-->编译mani.c:gcc -c main.c -I ./

-->链接:gcc -o main main.o -lstatic -L ./libstatic 
-l:指明静态库的名字,全名应当是libstatic.a,但是由于lib和.a是linux默认识别的,所以只用写static即可,比如在使用到数学库的场合,加入-lm即可,表示加入libm.a这个静态数学库
-L:指明静态库的路径,GCC在链接时,默认只会链接/usr/lib下面的C函数库,如果没有该参数的话,linux就会到/usr/lib里面查找-l指定的静态库,如果找不到就报错/usr/bin/ld:cancont find -lstatic
备注:如果自己做了一个静态库libxxx.a,或者要使用第三方提供的静态库libxxx.a,只用将该静态库添加到/usr/lib目录下,链接时加上-lxxx即可,不用再指明路径

-->运行:./main 

*** 制作动态链接库文件libdynamic.so
--环境:
-->工作目录:test,该目录下有一个库目录libdynamic,以及两个文件main.c,libdynamic.h
-->libdynamic目录下面有add.c,sub.c,mul.c,div.c,Makefile四个文件

--目的:
-->将libdynamic目录下的.c文件生成动态库libdynamic.so,在main.c中调用动态库中的工具函数
-->libdynamic.h下面给出了动态库libdynamic.so中的所有工具函数的原型

--实现步骤:
-->在4个文件内里面分别编写add.c,sub.c,mul.c,div.c文件: 见静态库制作

-->编写库函数的头文件libstatic.h:见静态库制作

-->编写Makefile文件:
objects = add.o sub.o mul.o div.o

libdynamic.so: ${objects}
	gcc -fPIC -shared -o libdynamic.so ${objects}
备注:
--fPIC:编译为位置独立的代码,即编译后的库可以存放在内存的任何位置
--shared:指定生成动态链接库

add.o : add.c
	gcc -c add.c

sub.o : sub.c
	gcc -c sub.c

mul.o : mul.c
	gcc -c mul.c

div.o : div.c
	gcc -c div.c

clean:
	rm libdynamic.so $(objects)

-->编写库函数的头文件libdynamic.h:见静态函数制作

-->使用动态函数库:libdynamic.so
## main.c
#include <stdio.h>
#include "libdynamic.h"

int main()
{
	int a,b;
	a = 10;
	b = 3;

	printf("a+b = %f\n",add(a,b));
	printf("a-b = %f\n",sub(a,b));
	printf("a*b = %f\n",mul(a,b));
	printf("a/b = %f\n",div(a,b));
	return 0;
}
-->编译mani.c:gcc -c main.c -I ./

-->链接:gcc -o main main.o -L ./libdynamic -ldynamic 

-->环境变量的处理:
方案一:将动态链接库拷贝到/usr/lib和/lib目录下,执行./main即可
方案二:在~/.profile下面添加:export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$MY_PATH (其中,MY_PATH为你所生成的libdynamic.so所在的目录的路径),执行. .profile 
方案三:在/etc/profile下面添加:export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$MY_PATH (其中,MY_PATH为你所生成的libdynamic.so所在的目录的路径),执行 . /etc/profile
方案四:在/etc/ld.so.conf.d目录下新建一个文件my.conf,打开该文件,并在里面添加你之前制作的动态库libdynamic.so所在目录的路径,保存退出,执行sudo ldconfig即可运行

备注:方案一,方案三,方案四是全局有效的,方案二只针对当前用户有效,其中方案一的做法将自己的库和系统的库混合在一起,我不太喜欢,个人认为方案四是一种比较优雅的方案
对于linux来说,负责装载共享库并解析用户程序函数引用情况的程序是动态装载器ld.so,该装载器会在/etc/ld.so.conf.d/下面的文件中索引共享库的额外位置(/usr/lib是标准位置),
所以只用将你的动态库的路径写入到/etc/ld.so.conf.d/下面的某一文件中(通常是新建一个自己的文件mylib.conf),并调用sudo ldconfig,动态装载器ld.so就能找到你的动态库了,
可以使用运行工具ldd来查看一个运用程序所需要的共享库,如ldd test

-->运行: ./main

Blog creation time:[2017-09-05 二 08:36]
** DONE [#D] theme:makefile语法规则							:@Blog:@Makefile:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:30]
用户自定义的隐含规则称模式规则，这些规则建议放到一个叫做BIN/rule.mk的Makefile文件中去，
其他makefile使用include包含进来，应该是include而不是make -C rule.mk,所以，rule.mk
就相当于各个makefile文件公共文件，有点公共函数的意思，被调用 

重新认识一下makefile中模式规则的原理以及如何被使用，模式规则就是用户定义出来，告诉
make,遇到符合自己定义的模式规则模型的，就套用该模型，并调用其下面的命令

Blog creation time:[2017-09-05 二 08:38]
** DONE [#D] theme:linux-kernel 的makefile架构解析			:@Blog:@Makefile:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:40]
**** 基本框架：
-- 内核makefile.txt中将makefile分为5部分：Kernel Makefile、ARCH Makefile、KBuild Makefile、.config文件以及scripts/Makefile.*

--kbuild将所有与编译过程相关的共用规则和变量都提取到scripts 目录下的Makefile.build中,具体的子目录下的 Makefile 文件则可以编写的非常简单与直接

--用 obj-* 连接的Objects 在指明的文件夹中被用作模块或者综合进built-in.o，也有可能被列出的objects 将会被包含进一个库,lib.a

--所有用lib-y 列出的objects 在那个文件夹中被综合进单独的一个库

--列在obj-y 且 附加列在lib-y 中的Objects 将不会被包含在库中

--对于被连接在lib-m 中，连续的objects 将会被包含在lib.a 中

--kbuild makefile 可能列出文件用作built-in ，并且作为库的一部分。因此，同一个文件夹可能包含一个built-in.o 和lib.a 文件  

--lib-y 的使用方法通常被限制在lib/ 和arc/*/lib 中
**** Makefile
--路径：位于linux kernel源码的顶层目录，该Makefile也就是顶层Makefile

--顶层的Makefile也叫做Kernel Makefile

--顶层Makefile文件负责产生两个主要的程序：vmlinux (内核image)和模块

--主要用于指定编译Linux Kernel 目标文件（vmlinux ）和模块（module ）路径

--顶层Makefile文件根据内核配置，通过递归编译内核代码树子目录建立这两个文件。

--顶层Makefile文件文本一个名为 arch/$(ARCH)/Makefile的机器体系Makefile文件。

--机器体系Makefile文件为顶层Makefile文件提供与机器相关的信息。

--根据.config文件决定了内核根目录下那些文件、子目录被编译进内核
**** ARCH/$(ARCH)/Makefile 
--系统对应平台的Makefile

--Makefile 会包含这个文件来指定平台相关信息

--根据.config文件，决定了ARCH/$(ARCH) 目录下 那些文件、子目录被编译进内核
**** scripts/Makefile.build: 
--被顶层Makefile所调用

--与各级子目录的Makefile合起来构成一个完整的Makefile文件，定义built-in.o、.lib以及目标文件.o的生成规则

--这个Makefile文件生成了子目录的.lib、built-in.o以及目标文件.o

**** scripts/Kbuild.include:
--被Makefile.build所调用

--定义了一些函数，如if_changed、if_changed_rule、echo-cmd
**** scripts/Makefile.clean
--被顶层Makefile所调用

--用来删除目标文件等
**** scripts/Makefile.lib
--被Makefile.build所调用
--主要是对一些变量的处理，比如说在obj-y前边加上obj目录
**** .config
--位于linux内核的根目录下

--产生自来自配置过程

--被顶层的Makefile包含

--配置过程产生.config文件

--.config又产生auto.conf以及autoconf.h文件
**** KBuild Makefile
--从Linux 内核2.6 开始，Linux 内核的编译采用Kbuild 系统 

--大多的Kbuild 文件的名字都是Makefile 。为了与其他Makefile 文件相区别，你也可以指定Kbuild Makefile 的名字为 Kbuild

--如果“Makefile ”和“Kbuild ”文件同时存在，则Kbuild 系统会使用“Kbuild ”文件,linux内核中,Kbuild Makefile 就是各个子目录的Makefile 

--Kbuild 系统使用Kbuild Makefile 来编译内核或模块

--每个子目录下都有一个KBuild Makefile，作用就是 指定当前目录下的文件，哪些被编译进当前目录的built-in.o、那些被编译成模块、那些不编译

--当顶层 Makefile 被解析完成后，Kbuild 会读取相关的Kbuild Makefile 进行内核或模块的编译

--Kbuild Makefile 有特定的语法指定哪些编译进内核中、哪些编译为模块、及对应的源文件是什么

--Kbuild Makefile 的一个最主要功能就是指定编译什么，这个功能是通过下面两个对象指定的obj-? 和xxx-objs  
例1：
     obj-y += foo.o 
     obj-m += abc.o 
实际：obj-$(CONFIG_DM9000) += dm9000.o，CONFIG_DM9000 是y 还是m取决于配置过程

例2：
	如果内核模块是通过几个源文件编译而成的，此时Kbuild需要知道编译模块时是基于哪些目标文件的,因此需要设置一个$(<module_name>-objs)变量来告诉编译器
    obj-$(CONFIG_ISDN) += isdn.o
    isdn-objs := isdn_net_lib.o isdn_v110.o isdn_common.o
由于obj-$(CONFIG_ISDN)是由isdn_net_lib.o isdn_v110.o isdn_common.o这三个目标文件编译而成的，所以，需要定义isdn-objs

**** scripts/kconfig/Makefile
--顶层Makefile调用： include scripts/kconfig/Makefile ，用于指定目标

--顶层Makefile调用： include scripts/kconfig/Makefile ，生成auto.conf autoconf.h auto.conf.cmd
**** .config文件
.config文件在进行内核编译时（make uImage）生成了include/config/auto.conf和include/linux/autoconf.h
Linux的内核配置，就是为了生成.config文件。因为在编译时需要用.config文件生成其他相关配置文件。我们的配置项大多是例如CONFIG_XXXDRIVER，这里的XXXDRIVER指的是各种驱动。我们需要告诉内核，这些驱动是编译进内核，还是编译成模块。通过查找CONFIG_XXXDRIVER，我们可以发现，它出现在四个地方：

　　1>C源代码

　　2>子目录Makefile:drivers/XXX/Makefile

　　3>include/config/auto.conf

　　4>include/linux/autoconf.h
里首先说明：.config文件在进行内核编译时（make uImage）生成了include/config/auto.conf和include/linux/autoconf.h。
通过查看C源代码我们发现CONFIG_XXXDRIVER是一个宏定义，等于一个常量。在include/linux/autoconf.h中宏定义CONFIG_XXXDRIVER为一个常量，可能是0或1。
那么现在有一个问题，就是CONFIG_XXXDRIVER到底被编译进内核还是编译成一个模块呢？这在C语言中是无法进行区分的，这种区分体现在哪里呢？这种区分体现在子目录的Makefile文件中。
在子目录的Makefile中，若有 obj -y += XXX.o则表示XXX.c被编译进内核；obj -m +=XXX.o则表示XXX被编译成模块，为XXX.ko。include/config/auto.conf文件则是对CONFIG_XXXDRIVER进行赋值，
为y时表示编译进内核，为m时表示编译成独立模块

--在Linux内核里，每个子目录都有一个makefile，它被称作Kbuilt-makefile，它将当前目录的文件编译成built-in.o、以及库文件、模块文件。
然后顶层Makefile里指定这些built-in.o的路径，将它们连接在一起

--通过内核配置操作产生.config文件，顶层Makefile文件读取该文件的配置。

Blog creation time:[2017-09-04 一 15:17]

*** 入口：
1.顶层Makefile---- 指定目标-----include scripts/kconfig/Makefile
如在终端中执行配置命令make nitrogen6x_defconfig
%config: scripts_basic outputmakefile FORCE
    $(Q)mkdir -p include/linux include/config
    $(Q)$(MAKE)$(build)=scripts/kconfig $@

2.auto.conf autoconf.h auto.conf.cmd的生成----指定目标-----include scripts/kconfig/Makefile
include/config/%.conf:$(KCONFIG_CONFIG)include/config/auto.conf.cmd
    $(Q)$(MAKE)-f$(srctree)/Makefile silentoldconfig

将在顶层Makefile中递归到上述1中的%config规则，所以，其最终还会包含scripts/kconfig/Makefile

3. 目标编译和链接----不指定目标-----include 各个build目标下的Makefile
$(vmlinux-dirs): prepare scripts
        $(Q)$(MAKE) $(build)=$@

4. 模块----模块建构中单独讨论
$(module-dirs):crmodverdir$(objtree)/Module.symvers
    $(Q)$(MAKE)$(build)=$(patsubst _module_%,%,$@)

modules:$(module-dirs)
    @$(kecho)'  Building modules, stage 2.';
    $(Q)$(MAKE)-f$(srctree)/scripts/Makefile.modpost

5. 单目标----不指定目标
%.o:%.c prepare scripts FORCE
    $(Q)$(MAKE)$(build)=$(build-dir)$(target-dir)$(notdir $@)

6. 子目录递归----不指定目标-----include递归的子目录下Makefile
scripts/Makefile.build
$(subdir-ym):
    $(Q)$(MAKE)$(build)=$@
*** 暂存
--

*** 基本流程
--在scripts/Kbuild.include中有一条规则：build := -f $(srctree)/scripts/Makefile.build obj

--在scripts/Makefile.build中：

*** 内核makefile源码分析
**** 顶层makefile
***** make参数信息:MAKEFLAGS
MAKEFLAGS += -rR --include-dir=$(CURDIR)
****** 分析
(1) MAKEFLAGS：
--该变量是一个系统级别的环境变量，包含了 make 的参数信息;
--这个变量不管你是否export,其总是要传递到下层 Makefile 中;
--如果我们在命令行使用make执行“总控 Makefile”时有 make参数,或是在上层 Makefile 中定义了这个变量,
那么MAKEFILES 变量将会是这些参数,并会传递到下层 Makefile 中
--但是 make 命令中的有几个参数并不往下传递,它们是“-C”,“-f”,“-h”“-o”和“-W”

(2) -r：
--取消所有内嵌的隐含规则
--但是，仍然可以在Makefile中使用模式规则来定义你自己的隐含规则
--同时，还会取消所有支持后追规则的隐含后缀列表
--但是，可以在Makefile中使用“.SUFFIXES”定义我们自己的后缀规则

(3) -R:
--取消 make 内嵌的隐含变量
--不过我们可以在 Makefile 中明确定义某些变量

(4) --include-dir=$(CURDIR)
--该参数指定包含makefile文件的搜索目录(也就是下面的filename的路径)
--include filename: filename 是 shell 所支持的文件名(可以使用通配符),一般是makefile文件，在自动依赖关系技术中，也用来包含.d文件
--如果filename的内容是空的，那么相当于什么事也没有做，继续执行当前Makefile之后的内容（不报错）
--在Makefile中出现“include”另外一个文件时，首先在当前目录下搜索，找不到的话将会在include-dir指定的目录下搜索，
找不到的话去/usr/gnu/include,或者/usr/local/include, /usr/include这几个目录下找，
还是找不到的话make将会提示一个包含文件未找到的告警提示,但是不会立刻退出，而是继续处理Makefile的后续内容，
当完成读取整个Makefile后,make将试图使用规则来创建通过指示符“include”指定的但未找到的文件
--在搜索include-dir指定的目录时，按照指定顺序进行
--include”指示符告诉 make 暂停读取当前的 Makefile,而转去读取“include”指定的一个或者多个文件，完成以后再继续当前 Makefile 的读取
--指示符“include”和文件名之间、多个文件之间使用空格隔开，行尾的空白字符在处理时被忽略

(5) CURDIR
--此变量代表 make 的工作目录
--当使用“-C”选项进入一个子目录后,此变量将被重新赋值
--总之,如果在Makefile 中没有对此变量进行显式的赋值操作,那么它代表 make 的工作目录
--我们也可以在 Makefile 为这个变量赋一个新的值,此时这变量将不再代表 make 的工作目录

总结：该语句为存储make参数的专用系统环境变量MAKEFLAGS，追加了三个参数，不论用户传递任何参数进来，这三个参数都将作为MAKEFLAGS
里面默许的，这三个参数宏观上取消了内嵌的隐含规则和隐含变量，使得编译器不能干涉用户的配置，然后指出Makefile文件的搜索路径，这一点
在make -C $(subdir)时尤其重要，有了--include-dir=$(CURDIR)，用户不用再考虑编译器怎样寻找子目录下的Makefile文件的问题
***** 从命令行传递参数
ifeq ("$(origin V)", "command line")
  KBUILD_VERBOSE = $(V)
endif
****** 分析
(1) V:一个来源尚不明确的变量

(2) $(origin V): 函数，返回这个变量的来源，变量有以下几种来源：
--undefined： 没定义
--default： V是内嵌变量，比如CC,MAKE之类的变量就是内嵌变量，不过一般情况下我们会取消隐含变量
--environment： 变量V是一个系统环境变量,并且make没有使用命令行选项“-e”(Makefile中不存在同名的变量定义,此变量没有被替代)
--environment override： 变量V是一个系统环境变量,并且make使用了命令行选项“-e”(Makefile中存在一个同名的变量定义,使用“make -e”时
环境变量值替代了文件中的变量定义)
--file: 变量V在某一个的makefile文件中定义
--command line：变量V在命令行中定义，比如：make V=1
--override: 变量V在某一个在makefile文件中定义并使用“override”指示符声明
--automatic： 变量V是一个自动化变量

(3) ifeq ("$(origin V)", "command line")
           xxx
    endif
--此关键字用来判断参数是否相等,如果相等，则执行xxx
--通常我们会使用它来判断一个变量的值是否为空(不是任何字符)
--参数值可能是通过引用变量或者函数得到的,因而在展开过程中可能造成参数值中包含空字符(空格等)，
一般在这种情况时我们使用make的“strip”函数来去除空字符
***** 从MAKEFLAGS中找出
ifneq ($(findstring s,$(filter-out --%,$(MAKEFLAGS))),)
  quiet=silent_
  tools_silent=s
endif
****** 分析
--首先过滤掉MAKEFLAGS中所有以--打头的单词(夹在两个空格之间的串称为一个单词，比如--include-dir就是一个单词)
--在剩下的集合中再去查找含有字符s的单词，找到则返回字符s，找不到则返回空字符。(make -s时，-s中有s，所以返回s)
--该语句的意思是，过滤掉MAKEFLAGS中以--打头的参数之后，查找MAKEFLAGS中有没有-s参数
--选项-s解析
1）该选项是--silent和--quiet的组合，其作用是：取消命令执行过程的打印，同时还禁止所有规则的命令的回显
2）说到执行过程的打印，就得聊一下-w参数，见下面
3）说到规则命令的回显，就得聊一下make执行命令之前所做的那些事

make在执行规则的命令之前会做什么？
1）会把要执行的命令行输出到标准输出设备，我们称之为“回显”，注意回显的是规则中的命令的原型
2）如果规则的命令行以字符“@”开始,则 make 在执行这个命令时就不会回显这个将要被执行的命令
3）使用了-s参数，相当于在规则的所有命令前面加上了@
备注：如果使用make的命令行参数“-n”或“--just-print”,那么make执行时只显示所要执行的命令,但不会真正的去执行这些命令，
这个选项对于我们调试Makefile非常有用,使用这个选项我们可以《按执行顺序》打印出Makefile中所有需要执行的所有命令

聊一聊-w:
1）该选项可以让 make 在开始编译一个目录之前和完成此目录的编译之后给出相应的提示信息，如
在目录“/u/gnu/make”目录下执行“make -w”会有：make: Entering directory `/u/gnu/make'以及make: Leaving directory `/u/gnu/make'的提示
2）通常,选项“-w”会被自动打开。在主控Makefile中当如果使用“-C”参数来为make指定一个目录或者使用“cd”进入一个目录时,“-w”选项会被自动打开
3）那么，可以使用 -s 选项来禁止所有关于目录信息的打印

** DONE [#D] theme:GNU Make中文手册阅读笔记					:@Blog:@Makefile:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:40]
>> Linux下面的可执行文件的ELF格式

>> 链接器的工作对象是.o文件，使用ld工具，最终生成elf可执行文件

>> 一个简单的Makefile可能只包含规则，但是通常还会包含规则之外的许多东西

>> Makefile的五大要点：规则，目标，依赖，命令，规则的触发

>>规则的触发：规则的触发决定着该规则是否能得到执行
	规则触发的基本原则就是任意规则中，依赖的时间戳比目标的时间戳新时，该规则一定被触发，在
Makefile中有很多规则，一个规则的依赖一般都是(伪目标除外)另一个规则的目标，单就某一规则而言，它被触发可以
理解为两种情况，第一：该规则依赖的时间戳比目标的时间戳新；第二：该规则的依赖是其他规则的目标，那该规则有被
触发的“潜质”
	Makefile中第一条规则（默认规则）一定会被触发执行，无论其是目标文件，还是伪目标
	伪目标（非默认）必须通过外部调用才能触发
小结：Makefile中规则能否被执行的依据是规则是否能被触发，即，不是所有只要写在Makefile中的规则都能被执行的，
那得看其是否有被触发的条件（当然，只要写在Makefile中的变量都会被执行）

>> makefile程序的入口：如同C语言的入口是main函数，在run时，程序从main开始执行，makefile文件中的程序也
有入口，当在终端下执行make命令时，系统会在当前目录下查找名字为Makefile的文件，然后从入口处开始解析规则，满足
规则触发条件的规则，其下面的命令会得到执行，那么，Makefile中的入口是什么呢？应该是该Makefile中，从上到下，
第一个出现的规则，也称其做默认规则，第一个规则无论如何都会被make执行，即使它是一个伪目标
	所以，一个Makefile中第一个出现的规则是至关重要的，一般情况下，该规则中的目标应当是终极目标，其他规则的目标
均是从该规则的依赖文件中繁衍出去，一般而言，我们习惯用一个伪目标all来作为第一规则

>>伪目标：只是一个标识，一般没有依赖，一般被外部调用，伪目标规则被执行时，不会生成目标文件

>>可以将一个较长行使用反斜线(\)来分解为多行,但需要注意:反斜线之后不能有空格

>>规则的目标如果是文件：在执行make时，依照规则的触发条件，该文件会被重新生成

>>规则的命令，所完成的工作主要是如何根据依赖文件来更新目标文件，当然了，一些规则是可以没有命令行的，如利用隐式规则，
还有，伪目标规则的命令的作用并非如此

>>make会将所有出现在第一条规则之后，所有以TAB开始的行当做命令行来处理

>> %.o: %.c 我们称这样的写法为“匹配”，既然是匹配，两个%自然要告知一个(niutou.o和mazui.c凑到一起是牛头不对马嘴)，
如果告知了%.o中的%是stm32f7xx,立即就知道%.c应当匹配到stm32f7xx.c,这才对嘛，既然%.c是依赖，那么，就可以根据
vpath到当前目录下找具体的stm32f7xx.c这个文件了，所以呢，目标%.o一般是需要明确在Makefile中使用变量告知的
Blog creation time:[2017-09-02 六 10:12]
