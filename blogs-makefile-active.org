* blogs-makefile-active
** WAITTING [#D] Theme:gcc基础							:@Blog:@Makefile:
    SCHEDULED:<2017-10-27 五>
1. 预处理:  gcc -E test.c -o test.i  ---->  完成头文件展开,宏替换等工作之后,将源文件生成预处理文件
2. 编译:    gcc -S test.i -o test.s  ---->  编译预处理文件,生成汇编文件
3. 汇编:    gcc -c test.s -o test.o  ---->  将汇编文件汇编成机器码,即目标文件
4. 链接:    gcc    test.o -o test    ---->  将机器码链接起来生成可执行文件(.ELF)
5. 使用gcc命令处理源文件文件: gcc test.c -o test     备注: test.c后面加的参数一般有-O,-Wall,-g,-I,-l,-L,-Shared等
6. 使用make命令和Makefile文件处理源文件: gcc -c test.c -o test.o      gcc test.o -o test
Blog creation time:[2017-10-27 五 09:10]
** WAITTING [#D] Theme: makefile基础 						:@Blog:@Makefile:
1. makefile默认文件名: 
   1. 默认的情况下,make 会在工作目录(执行 make 的目录)下按照文件名顺序寻找makefile 文件读取并执行,查找的文件名顺序为:“GNUmakefile”、“makefile”、“Makefile”
   2. 当然了,也可以在命令行执行make时,加入路径参数,强制指定去make哪个路径下的makefile文件
   3. 推荐使用“Makefile”,首字母大写而比较显著,GNUmakefile”是不推荐使用的文件名,因为以此命名的文件只有“GNU make”才可以识别
   4. 如果make程序在工作目录下无法找到以上三个文件中的任何一个,它将不读取任何其他文件作为解析对象
2. 指定makefile的文件名:
   1. 当makefile 文件的命名不是上面所述三个中的任何一个时,需要通过 make 的“-f”或者“--file”选项来指定 make 读取的 makefile 文件
   2. 也可以通过多个“-f”或者“--file”选项来指定多个需要读取的 makefile 文件,多个 makefile 文件将会被按照指定的顺序进行链接并被 make 解析执行
   3. 当通过“-f”或者“--file”指定 make 读取 makefile 的文件时,make 就不再自动查找这三个标准命名的 makefile 文件
3. "终极目标":
   1. make默认执行的是Makefile中的第一个规则,此规则的第一个目标称“终极目标”
   2. 除了 makefile 的“终极目标”所在的规则以外,其它规则的顺序在 makefile 文件中没有意义
   3. 如果在 makefile 中第一个规则有多个目标的话,那么多个目标中的第一个将会被作为 make 的“终极目标”
   4. 如果 makefile 中第一规则的目标名以点号“.”开始并且其后不存在斜线“/”时,即便是第一规则,但是也不会当做"终极目标"
   5. 如果 makefile 中第一规则的目标名是模式规则的目标,,即便是第一规则,但是也不会当做"终极目标"
   6. 在生成"终极目标"的过程中,如果任何一个规则执行出现错误 make 就立即报错并退出
   7. 终极目标”是执行 make 的唯一目的,其它的规则是在完成重建“终极目标”的过程中被连带出来的,所以这些目标所在规则在 Makefile 中的顺序无关紧要
   8. 因此,我们书写的 makefile 的第一个规则应该就是重建整个程序或者多个程序的依赖关系和执行命令的描述
4. 除了 makefile 的“终极目标”所在的规则以外,其它规则的顺序在 makefile 文件中没有意义
5. Makefile 中第一个规则之后的所有以[Tab]字符开始的的行, make 程序都会将其交给系统 shell 程序去解释执行
6. make 只是负责执行规则,而对具体规则所描述的依赖关系的正确性、规则所定义的命令的正确性不做任何判断, 因此需要用户自己保证在Makefile中写的依赖和命令的正确性
7. Makefile的五大要点："规则"，"目标"，"依赖"，"命令"，"规则触发"
   1. 规则:
	  1. "规则"的模型:
	     TARGET... : PREREQUISITES...
         ----COMMAND
	  2. 规则中“TARGETS”可以是空格分开的多个文件名,也可以是一个标签
	  3. “TARGETS”的文件名可以使用通配符,格式“A(M)”表示档案文件(Linux下的静态库.a文件)的成员“M”(参考静态库的重建)
	  4. 通常规则只有一个目标文件(建议这么做),偶尔会在一个规则中需要多个目标(参考多目标)
	  5. "COMMAND"可以和依赖列表放在同一行,之间用;分隔开来,例如,test.o: test.c defs.h; $(CC) -c $< -I../inc -o $@(备注: 分号之后可以没有空格,也可以有多个空格)
	  6. "规则"由"目标","依赖","命令"组成,而且三者关系密切
	  7. make总是去关注"依赖"和"目标"时间戳,一旦发现二者时间戳不一致,则"触发规则",执行"命令"
	  8. make默认执行的是Makefile中的第一个规则,此规则的第一个目标称“终极目标”
	  9. 命令可以和目标,依赖描述放在同一行,命令在依赖文件列表后并使用分号(;)和依赖文件列表分开
   2. 目标:
	  1. 在"规则"中, TARGET... 所给出的就是该"规则"的"目标"
	  2. "目标"通常是一个文件名
	  3. "终极目标":  Makefile 文件中的第一个目标
	  4. "伪目标": 
		 1. Makefile中把那些没有任何依赖只有执行动作的目标称为“伪目标”(phony targets)
		 2. 以关键字 .PHONY: clean 来标识clean是一个"伪目标"
		 3. "伪目标"不是文件名,可以理解为一个标签
		 4. 由"伪目标"组成的"规则",通常没有"依赖",但是有"命令",因此,伪目标一般由外部调用
   3. 依赖:
	  1. 在"规则"中, PREREQUISITES 所给出的就是该"规则"的"依赖"
	  2. 依赖有两种不同类型: 常规依赖, “order-only”依赖
	  3. 常规依赖的意义: 要完成目标之前,必须向进行依赖的生成,因此,依赖实际上是对一个大目标进行切割成小目标;另外,依赖的时间戳决定了执行规则的时机
	  4. 常规依赖的特点: 依赖文件中的任何一个被更新,则规则的目标相应地也应该被更新
	  5. “order-only”依赖的意义: "一次性创建",比如静态库,某个目标依赖于某静态库,我们只会希望该目标不存在是执行命令去更新目标,而以后修改静态库,不再去更新目标
	  6. “order-only”依赖的特点: 只有当规则的目标不存在时,才会触发该规则,执行规则的命令
	  7. “order-only”依赖的格式: foo : foo.c | $(LIBS), 其中管道符号“|”左边的是常规依赖,管道符号右边的就是“order-only”依赖,这样的规则中常规依赖文件可以是空
	  8. 规则依赖文件列表中如果一个文件同时出现在常规列表和“order-only”列表中,那么此文件被作为常规依赖处理
   4. 命令:
	  1. "命令"表征该规则被触发之后将要执行的动作
	  2. 一个规则中"命令"可以有多条,每条"命令"均需要以<TAB>开头,
	  3. 如果一条"命令"过长,可以以 \ 将其分解为多行以便阅读,但是\之后不能有空格
	  4. 在命令行之前使用“-”,意思是忽略命令的执行错误: -rm -rf $(OBJS)
	  5. 在gcc命令中,我们使用-I来指定源文件的头文件路径
   5. 规则触发
	  1. 当"目标"不存在时,规则被触发,执行命令
	  2. 当"依赖"的时间戳比"目标"的时间戳新时,规则被触发.执行命令
	  3. 当规则的"目标"不是"终极目标"的"子孙",即"终极目标"的依赖,或者"依赖的依赖..."时,该规则永远不会被触发,除非外部向执行伪目标那样明确指明执行该规则
	  4. 当"目标"存在,"目标"的时间戳比"依赖"的时间戳新时,什么都不做
   6. 备注: 书写规则建议的方式是:单目标,多依赖。就是说尽量要做到一个规则中只存在一个目标文件,可有多个依赖文件。尽量避免使用多目标,单依赖的方式
8. 在一个完整的 Makefile 中,包含了 5 个东西: 显式规则, 隐含规则, 变量定义, 指示符, 注释
9. makefile文件可以由其他文件生成(如RCS 或 SCCS 文件),因此,make在读取makefile文件时也像规则中的目标那样去试图重建makefile
10. 实际应用中,我们会明确给出makefile文件,而并不需要来由make自动重建它们,但是make在每一次执行时总会自动地试图重建那些已经存在的makefile文件,出于效率上的考虑,可以书写一个明确的规则,以makefile文件作为目标,规则的命令定义为空,可以避免多次试图重建makefile文件带来的效率上的损失
11. makefile中在"规则"的"命令"前面的加号+，减号-和@的含义:
	1. 这个做法，其实是Linux中的Shell中的规则而不是Makefile中内建的
	2. 减号- : 该命令执行时候如果遇到错误,则忽略错误,继续向下执行
	3. @: make 在执行命令行之前会把要执行的"命令"输出到标准输出设备,称之为命令的“回显”,如果"规则"的"命令"以字符“@”开始,则则不会回显
	4. 加号+ : 使命令行可以通过指定 -n、-q 或 -t 选项来执行 
** WAITTING [#D] Theme:make如何解析makefile文件的? 			:@Blog:@Makefile:
   SCHEDULED:<2017-10-26 四>
1. 第一阶段:
   1. 读取所有的 makefile 文件(包括“MAKIFILES”变量指定的、指示符“include”指定的、以及命令行选项“-f(--file)”指定的 makefile 文件)
   2. 内建所有的变量,显示规则,隐含规则
   3. 建立所有目标和依赖之间的依赖关系结构链表
2. 第二阶段:
   1. 根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新
   2. 使用对应的规则来重建这些目标
3. 意义: 理解 make 执行过程的两个阶段是很重要的,它能帮助我们更深入的了解执行过程中变量以及函数是如何被展开的
4. "立即展开"
   1. 在 make 执行的第一阶段中如果变量和函数被展开,那么称此展开是“立即”的
   2. 此时所有的变量和函数被展开在需要构建的结构链表的对应规则中
   3. 当变量使用追加符(+=)时,如果此前这个变量是使用 := 定义的,则认为该变量是立即展开的
   4. 所有"条件指示符" “ifdef”、“ifeq”、“ifndef” 和 “ifneq” 在产生分支的地方都会立即展开,即,条件分支的展开是“立即”的
   5. "规则"中,目标和依赖如果引用其他的变量,则被立即展开,命令中的使用到的变量引用会被延后展开,此模板适合所有的规则,包括明确规则、模式规则、后缀规则、静态模式规则
5. "延后展开"
   1. 变量和函数不在 make 执行的第一阶段被展开,那么称此展开是“延后”的
   2. 直到后续某些规则须要使用时或者在 make 处理的第二阶段它们才会被展开
   3. 当变量使用追加符(+=)时,如果此前这个变量是使用 = , ?= , define 定义的,则认为该变量是立即展开的
Blog creation time:[2017-10-26 四 14:27]
** WAITTING [#D] Theme:make执行过程						:@Blog:@Makefile:
    SCHEDULED:<2017-10-27 五>
1. 依次读取变量“MAKEFILES”定义的 makefile 文件列表
2. 读取工作目录下的 makefile 文件(根据命名的查找顺序“GNUmakefile”,“makefile”,“Makefile”,首先找到那个就读取那个)
3. 依次读取工作目录 makefile 文件中使用指示符“include”包含的文件
4. 查找重建所有已读取的 makefile 文件的规则(如果存在一个目标是当前读取的某一个 makefile 文件,则执行此规则重建此 makefile 文件,完成以后从第一步开始重新执行)
5. 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支
6. 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表
7. 执行除“终极目标”以外的所有的目标的规则(规则中如果依赖文件中任一个文件的时间戳比目标文件新,则使用规则所定义的命令重建目标文件)
8. 执行“终极目标”所在的规则
Blog creation time:[2017-10-27 五 15:38]
** WAITTING [#D] Theme:规则执行过程						:@Blog:@Makefile:
    SCHEDULED:<2017-10-27 五>
1. 首先,构建出该规则的所有依赖文件,并建立所有目标和依赖之间的依赖关系结构链表
2. 然后,根据已经建立的依赖关系结构链表决定哪些目标需要更新,即比较目标文件和所有的依赖文件的时间戳
6. 如果目标的时间戳比所有依赖文件的时间戳更新,那么什么也不做
7. 如果依赖文件中的某一个或者全部在上一次执行make后已经被修改过,规则所定义的重建目标的命令将会被执行
Blog creation time:[2017-10-27 五 15:38]
** WAITTING [#D] Theme:目录搜索							:@Blog:@Makefile:
    SCHEDULED:<2017-10-28 六>
1. 搜索的第一步首先会关注"目标"和"依赖"在"规则"中给出的路径(以Makefile文件所在路径为根)
2. 目录搜索示例的已知条件:
   1. test目录下存在 inc/, src/, obj/
   2. inc/下存在test.h文件
   3. src/下存在test.c和Makefile文件
   4. obj/打算用于存储编译过程中生成的*.obj,初始时刻为空
3. "所有类型文件"的搜索路径: VPATH变量
   1. 使用背景:
	  1. 对于较大的工程,通常会将源代码文件,目标文件,头文件等安排在不同的目录下分别管理
	  2. 但是,我们经常会频繁的进行增加,修改,删除子目录的操作,这样的话,Makefile中"规则"的"依赖"也得跟着改动(比如, test: test.o 就得改为 test: ../src/test.o)
	  3. 在大型工程中,这样是很不方便的,我们可能希望Makefile中的规则一旦设计好以后,就不要变动,当进行子目录的增加,修改,删除等操作时,设计好的Makefile规则能适应这种变化
	  4. 通用的办法就是: 将Makefile中"规则"的"依赖文件"的路径用一个全局的变量来记录,如此一来,每当进行子目录的增加,修改,删除等操作时,只用稍微修改一下该全部变量即可
   2. 作用: 为"规则"的"依赖文件"以及"目标"提供搜索路径,当"规则"的"依赖文件"在当前目录不存在时,make 会在此变量所指定的目录下去寻找这些依赖文件
   3. 定义变量“VPATH”时,使用空格或者冒号将多个需要搜索的目录分开
   4. make搜索目录的顺序是按照变量“VPATH”定义中的目录顺序进行的(当前目录永远是第一搜索目录)
   5. “VPATH”变量指定的路径在 Makefile 中对所有类型的文件都有效,当需要为不类型的文件指定不同的搜索目录时,使用vpath关键字
   6. 当使用了VAPTH时,规则中就必须显示给出自动化形式的"命令"
4. "指定类型文件"的搜索路径: vpath关键字
   1. 示例: vpath %.h ../headers:../lib/inc
   2. "%.h"表示所有以“.h”结尾的文件
   3. 多个目录使用空格或者冒号分开
   4. Makefile 中出现的所有.h文件,如果在Makefile当前所在目录下找不到的话,就依次在 ../headers:../lib/inc中寻找
   5. 注意:这里指定的路径仅限于在 Makefile 文件内容中出现的.h文件,并不能指定源文件中包含的头文件所在的路径(在.c 源文件中所包含的头文件路径需要使用 gcc 的“-I”选项来指定)
5. VPATH和vpath的目录搜索机制:
   1. 示例: test.o: test.c
   2. 假定定义了: vpath %.o ../OBJ     vpath %.c ../src
   3. 假定 test.c在../src目录下,test.o在../OBJ目录下有一个之前生成的版本
   4. 首先,无论是test.o还是test.c,make都会在当前目录下搜索,该示例中自然是没有在当前路径下找到test.o和test.c
   5. 接着会到vpath指定的路径下搜索test.o以及test.c,因此,返回搜索结果: test.o的全路径../OBJ/test.o以及test.c的全路径../src/test.c
   6. 此处有个问题需要搞明白, 在Makefile中规则是test.o: test.c,但是返回的搜索结果构成的规则却是../OBJ/test.o: ../src/test.c
   7. 如果按照搜索返回的结果来构建规则,那么,目标test.o就产生在../OBJ目录下去了,这样的行为改变我们在Makefile中规则test.o: test.c的语义,这是不对的
   8. 因此,make给出的机制是: 搜索到全路径之后,使用全路径构成的规则../OBJ/test.o: ../src/test.c判断"目标"../OBJ/test.o是否需要重建
   9. 如果需要重建../OBJ/test.o,则会废除全路径,只剩test.o,也就是说,重建的文件test.o将会在当前Makefile所在的路径下生成而不会在../OBJ/下面生成
   10. 如果不需要重建,"目标"的全路径被保存
   11. 再来分析一下"依赖"的路径,"依赖"路径必须使用全路径,因为这是构建出目标所必须的,因此,不论目标是否需要重建,"依赖"的路径均是全路径../src/test.c
   12. "依赖"的路径一定是全路径,而Makefile中给出的"规则"是test.o: test.c,这意味着,规则的命令行中必须使用自动化变量$^来代表依赖文件
   13. 结论:
	   1. 从vpath和VPATH的搜索机制可知: 不仅提供"依赖"的搜索路径,而且还提供"目标"的搜索路径,事实也是如此
	   2. 搜索到的文件,"依赖"一定是使用全路径,当需要重建"目标"时,对"目标"使用废弃的路径(即,始终是在当前目录下生成目标)
	   3. 提示: 那有没有办法让make在需要重建"目标"时,对"目标"也使用全路径呢(即,让目标生成到指定目录),办法是有的,那就是使用GPATH变量
6. GPATH变量
   1. 在上面的目录搜索机制中,给出结论: 搜索到的文件,"依赖"一定是使用全路径,当需要重建"目标"时,对"目标"使用废弃的路径(即,始终是在"规则"中"目标"指定的目录下生成目标)
   2. GPATH变量则是实现,搜索到的文件,"依赖"一定是使用全路径,"目标"也使用全路径(即,在目标的全路径指定的目录下生成目标)
   3. “GPATH”变量和“VPATH”变量具有相同的语法格式
   4. 实测"GPATH"不能单独使用,必须搭配VPATH一起使用
   5. "VPATH"提供"规则"中"依赖"和"目标"的全路径",然而"搜索到的目标"的全路径会被废除,只保留 GPATH"主要用于处理"规则"中的"目标",
   6. make 在执行时,如果通过"VPATH"得到一个过时的完整的目标文件路径名,而目标存在的目录又出现在“GPATH”变量的定义列表中,则该目标的完整路径将不废弃,目标将在该路径下被重建
   7. 当使用了VAPTH和GPATH时,规则中就必须显示给出自动化形式的"命令"
7. 目标在指定目录下生成的两种手段:
   1. 只使用VPATH:
	  1. VPATH = ../src:../inc
	  2. ../obj/test.o: test.c test.h
	  3. ----$(CC) -c $< -I../inc -o $@
	  4. 分析:
		 1. 对于"依赖"test.c和test.h,默认make会以当前Makefile文件的路径为根,然后在根路径下寻找test.c和test.h
		 2. 由前面的已知条件中给出的可知,test.c和test.h不在Makefile所在的目录下,因此,会去VPATH列表中找,最终返回: ../inc/test.h   ../src/test.c
	     3. 对于"目标"test.o,默认make会以当前Makefile文件的路径为根,然后相对寻址到../obj/下面去寻找test.o是否存在
		 4. 初始时刻"目标"肯定不存在,因此会去执行"命令"
		 5. "命令"中使用了自动变量,$@就代表了../obj/test.o,而$<就代表了../src/test.c(不是test.c哦),"命令"会在../obj/下面生成test.o
		 6. 对test.c进行修改,之后再编译make ../obj/test.o,同样的,默认make会以当前Makefile文件的路径为根,然后相对寻址到../obj/下面去寻找test.o是否存在
		 7. 这时候test.o在../obj/下面是存在的,接下来会将../src/test.c的时间戳和../obj/test.o进行比较,由于修改过了test.c,因此会执行命令更新../obj/test.o
	  5. 备注: 该方案实际上只考虑"依赖"的路径,"目标"的路径则手动给出其全路径,
   2. 使用VPATH和GPATH的组合:
	  1. VPATH = ../src:../inc:../obj
	  2. GPATH = ../obj
	  3. 
	  4. OBJ = $(patsubst %.c,../obj/%.o,$(wildcard *.c))
	  5. 
	  6. create: 
	  7. ----touch $(OBJ)
	  8. 
	  9. test.o: test.c test.h
	  10. ----$(CC) -c $< -I../inc -o $@
	  11. 分析: 
		  1. 执行make create,使得在../obj目录下生成空的*.o文件(GPATH)
		  2. 对于"依赖"test.c和test.h,默认make会以当前Makefile文件的路径为根,然后在根路径下寻找test.c和test.h
		  3. 由前面的已知条件中给出的可知,test.c和test.h不在Makefile所在的目录下,因此,会去VPATH列表中找,最终返回: ../inc/test.h   ../src/test.c
		  4. 对于"目标"test.o,默认make会以当前Makefile文件的路径为根,然后在根路径下面去寻找test.o是否存在,没有找到
		  5. 然后去VPATH所给出的列表中寻找,结果在../obj下面找到了test.o,最终返回: ../obj/test.o
		  6. 由于../obj目录被放进了GPATH,"规则"的"目标"会使用全路径,此时,规则中"命令"$@变成../obj/test.o而不是test.o
		  7. 之后对于test.o的更新实际上是更新../obj/test.o
Blog creation time:[2017-10-28 六 19:31]
** WAITTING [#D] Theme:显示规则							:@Blog:@Makefile:
   SCHEDULED:<2017-10-27 五>
1. 对"makefile文件"的重建: (该规则不是很常用,因为一般情况下都会明确的给出makefile文件)
   1. 通常接触的"重建"是"规则"中对目标的重建,在这里想说的是,makefile文件也能重建
   2. Makefile 可由其它文件生成,例如 RCS 或 SCCS 文件,此时,必然要用到makefile文件的重建机制,因为makefile文件不是固定的,而是由其他文件动态生成
   3. 如果用到了makefile文件的重建机制的话,make 在开始解析这个 Makefile 时需要重新读取更新后的 Makefile、而不是之前的 Makefile
   4. makefile文件重建的过程:
	  1. make 在读入所有 makefile 文件之后,首先将所读取的每个 makefile 作为一个目标,寻找更新它们的规则 (即寻找重建makefile文件的规则,比如在RCS中)
	  2. 如果存在并找到了一个更新某一个 makefile 文件明确规则或者隐含规则,就去更新对应的 makefile 文件
	  3. 完成对所有的 makefile 文件的更新之后,如果之前所读取任何一个 makefile 文件被更新,那么 make 就清除本次执行的状态重新读取一遍所有的 makefile 文件
      4. 这一遍的读取同样会去寻找更新它们的规则,试图更新所有的makefile文件,但是,一般这些文件不会再次被重建,因为它们在时间戳上已经是最新的
	  5. 读取完成以后再开始解析已经读取的 makefile 文件并开始执行必要的动作
	  6. 备注: 实际运用中,一般都会明确的给出makefile文件,而并不需要来由make自动重建它们,但是,make却不会理会,如果需要处于效率考虑,以书写一个明确的规则,以makefile文件作为目标,规则的命令定义为空,如此一来,makefile文件的重建就演化为规则中目标的重建
   5. 运用:
      1. 执行make时,如果没有指定-f,则make默认会去当前目录下寻找缺省的文件,但是,make 无法确定工作目录下是否存在缺省名称的 makefile 文件
	  2. 如果缺省 makefile 文件不存在,则会可以通过一个隐式规则来创建它,之后重新读取它并开始执行
	  3. 需要明确的一点是:执行 make 时,如果不能成功地创建缺省的 makefile 文件,并不一定会导致错误
2. 对makefile文件中"规则"中"目标"的重建:
   1. make 读取当前目录下的 Makefile 文件
   2. 将 Makefile 文件中的第一个规则的目标作为其执行的“终极目标”
   3. 开始解析第一规则中,终极目标,依赖,命令: a: b c d e 
   4. 首先,用 b 和 a 进行比较,发现 b 不存在
   5. 然后,去寻找 b 作为目标的那个规则: b : A B C D E
   6. 用 A 和 b 进行比较,发现 A 不存在
   7. 然后,去寻找 A 作为目标的那个规则: A : 1 2 3 4
   8. 用 1 和 A 进行比较, 发现1的时间戳比A新(A不存在,1存在)
   9. 立即执行以A为目标的这条规则的命令
   10. 接着执行以b为目标的这条规则的命令,便生成了b
   11. 随后用c和a比较,试图生成c,以此类推
   12. 直到a,b,c,d,e均生成,最后一步次去执行以a为目标规则的命令来重建终极目标a
   13. 备注: 不仅仅只是终极目标a的规则如此,任意规则均是如此: 即,先依次重建完毕该规则的依赖后,最后才去重建该规则的目标(执行该规则的命令)
3. "命令"的执行
   1. "命令"执行的原理:
      1. 规定每一行"命令"的执行是在一个独立的 shell 进程中完成,因此,如果是多行命令,那么每一行命令将在一个独立的子 shell 进程中被执行即, 各行命令互相之间没有什么联系
	  2. 规定在同一行中的用分号分隔的多个命令属于一个完整的 shell 命令行
   2. "命令"执行的原理1所引发的问题:
	  1. test.o: test.c
	  2. ----cd ../src
	  3. ----touch tmp.txt
	  4. 分析:
	     1. 该例子的意图十分明显,希望规则被触发时,进入../src目录下.然后创建tmp.txt
		 2. 但是,显然没法实现,行号2,3所在的两行命令均是独立行,make在解析时会为其开辟各自独立的进程,两个进程之间没有必然的联系
   3. 解决"命令"执行的原理1所引发的问题
	  1. "命令"执行的原理2规定: 在同一行中的用分号分隔的多个命令属于一个完整的 shell 命令行,因此可以给出如下规则
	  2. test.o: test.c
	  3. ----cd ../src;    \
	  4. ----touch tmp.txt
	  5. 分析: \ 表明当前行和下一行是在同一行
4. "所有匹配模式"规则  
   1. 重载的概念,在c++语言里面已经用的很多了,所谓的"重载"就是同一个事物在不同的环境下有不同的解释,我们就说,对这个事物进行了重载
   2. 重载另一个makefile时使用include指示符所引发的问题:
	  1. makefile1中需要使用makefile2中所定义的变量和规则
	  2. 通常的做法是在makefile1中使用include指示符将makefile2包含进来
	  3. 但是,如果makefile1中存在一个目标 test.o: xxx ,而makefile2中也存在一个目标test.o: xxx,即,两个文件中规则的目标相同,命令不同,这是不被make所允许的(可见,include不要滥用,严格按照include给出的两种场合使用,不要自行发挥)
   3. make 提供另外一种方案来处理重载另一个makefile时include所不能处理的情况:
	  1. 在makefile1中定义一个"所有匹配模式"的规则;
	  2. 如果在当前makefile文件中不能找到重建一个目标的规则时,就使用“所有匹配模式”所在的规则来重建这个目标
	  3. 语法:
		 1. # Makefile
	     2. foo:
	     3. ----frobnicate > foo
   	  	 4. %: force
		 5. ----@$(MAKE) -f ../src/Makefile $@
		 6. force: ;
		 7. 备注:
			1. 模式规则的模式只使用了单独的“%”,表示它可以匹配任何一个目标
			2. "所有匹配模式"的依赖是“force”,保证了即使目标文件已经存在也会执行这个规则
			3. “force”规则中使用空命令是为了防止 make 程序试图寻找一个规则去创建目标“force”时,又使用了模式规则“%: force”而陷入无限循环
			4. 拓展: 貌似可以使用双冒号规则化简上面的"所有匹配模式"规则: %::   <RET><TAB>@$(MAKE) -f ../src/Makefile $@
	  4. 语法解析:
		 1. 在Makefile所在的目录执行命令“make foo",则命令: frobnicate > foo会被执行
		 2. 在Makefile所在的目录执行命令“make bar",因为当前目录下的Makefile文件中没有bar目标的规则,因此,会使用"所有匹配模式"规则 %: force,执行到@$(MAKE) -f ../src/Makefile $@
		 3. 如果 ../src/Makefile存在,且里面有bar: xx的规则,则执行该规则下的命令
   4. 使用"所有匹配模式"比使用"include"指示符优越的地方:
	  1. 如果Makefile1中存在指定目标bar,那么,在Makefile1当前目录下执行make bar时,就会使用Makefile1中bar的规则,即便Makefile2中也有bar规则
	  2. 如果Makefile1中不存在指定目标bar的规则,在Makefile2中存在,那么,在Makefile1当前目录下执行make bar时,可以使用"所有匹配模式"下的命令找到Makefile2中的规则
	  3. 这样就避免了使用指示符“include”包含一个 makefile 文件时所带来的目标规则的重复定义问题
5. 双冒号规则
   1. Makefile规则中,如果使用一个没有依赖只有命令行的双冒号规则去更新一个文件,那么每次执行make时,此规则的目标文件将会被无条件的更新(此规则定义的命令会被无条件执行)
   2. 备注: 
6. 通配符规则
   1. 在 Makefile 中这些通配符并不是可以用在任何地方,Makefile 中统配符可以出现在以下两种场合:
	  1. 可以用在规则的目标中,make 在读取 Makefile 时会自动对其进行匹配处理(通配符展开): 一般情况下,使用单目标规则,用在目标中的情况较少
	  2. 可以用在规则的依赖中,make 在读取 Makefile 时会自动对其进行匹配处理(通配符展开): print: *.c <ENT><TAB> CMD
	  3. 可出现在规则的命令中,通配符的通配处理是在 shell 在执行此命令时完成的: clean: <ENT><TAB> rm -f *.o
	  4. 除这两种情况之外的其它上下文中,不能直接使用通配符,而是需要通过函数“wildcard”,如变量定义中,当需要变量“objects”代表所有.o 文件列表示,需要使用函数
	  5. 备注: 在变量定义中不能使用通配符,objects = *.o”。它表示变量“objects”的值是字符串“*.o”(并不是期望的空格分开的.o 文件列表)
   2. Maekfile 中表示文件名时可使用通配符
   3. 可使用的通配符有:“*”、“?”和“[...]”
   4. “*.c”代表了当前工作目录下所有的以“.c”结尾的文件
7. 伪目标规则
   1. 将一个目标声明为伪目标的方法是将它作为特殊目标.PHONY”的依赖,如: .PHONY: clean
   2. 伪目标不代表一个真正的文件名,为了避免和工程中的文件名冲突,务必使用.PHONY进行声明
   3. Makefile会对规则中的所有目标生成文件,但是伪目标却不在此列,即伪目标最终不会被生成为文件
   4. 当一个伪目标没有作为任何目标,的依赖时,我们只能通过 make 的命令行来明确指定它为 make 的终极目标,来执行它所在规则所定义的命令
   5. 伪目标可以有自己的依赖(其依赖可以是一个或者多个文件、一个或者多个伪目标),这样的做的意图完成对它所依赖的文件的重建动作(因为伪目标不会被生成为文件)
   6. 伪目标A可以作为伪目标B的依赖,此时,意味着伪目标A如果想要执行,则必须先执行伪目标B
   7. 伪目标的3种使用场合:
	  1. 构建只执行命令的目标: clean: ; rm *.o
	  2. 用于make的并行和递归执行过程中,同步目录执行顺序
		 1. SUBDIRS = foo bar baz
		 2. .PHONY: sub-make $(SUBDIRS)
		 3. 
		 4. sub-make: $(SUBDIRS)
		 5. 
		 6. $(SUBDIRS):
		 7. ----$(MAKE) -C $@
		 8. 
		 9. foo: baz
		 10. 分析: $(SUBDIRS)既是一个"伪目标",还是一个"强制目标",还是一个"多目标",并且,还作为了sub-make的依赖,因此,在执行make sub-make时,$(SUBDIRS)作为"强制目标",肯定会触发sub-make这条规则,作为依赖,肯定要先被重建,重建时,作为"多目标",foo bar baz会依次使用自己的命令进行重建,但是,由于存在foo: baz,那么,重建foo之前必须向重建baz,如此一来,就起到改变并行目录的处理顺序的作用
		 11. 提醒大家:在书写一个并行执行 make 的 Makefile时,目录的处理顺序是需要特别注意的,因此同步目录的处理顺序就需要用到伪目标的该功能
	  3. 如果需要实现一个不是实际文件的目标,我们只是需要通过使用这个目标来完成对它所依赖的文件的重建动作,首先应该想到伪目标而不是空命令目标
8. 强制目标
   1. 定义:如果一个"规则"没有"命令",或者没有"依赖",或者"命令"和"依赖"均没有,并且它的"目标"不是一个存在的文件名,我们称这样的规则中的"目标"为"强制目标"
   2. 特点: make在处理强制规则时,该强制规则的目标总会被认为是最新的
   3. 意义: 将强制目标用于其他规则的依赖列表中,总是会触发那个规则的命令
   4. 注意: 需要注意没有"命令"的这种情况,别忘记了"隐式规则",比如test.o: test.h defs.h这样一条规则中,test.o可不属于"强制目标",因为该规则有隐式规则
   5. 没有依赖的伪目标也属于强制目标,事实上,我们会把强制目标使用.PHONY声明为伪目标,这样的话就不用担心强制目标会同文件名冲突的问题
   6. 通常,如果需要刻意构造一个强制目标来使用(作为其他规则的依赖,以便强制更新该规则),最好就是只给出目标,有一个很好的选择, FORCE:
   7. FORCE通常放在依赖列表的最后
9. 空命令规则
   1. 原型: target: ;
   2. 仅有 "目标" 或者 只有 "目标"+"依赖" 而没有 "命令"的这样一组规则称为空命令规则
   3. 使用空命令规则唯一的原因是,空命令行可以防止make在执行时试图为重建这个目标去查找隐含命令(包括了使用隐含规则中的命令和“.DEFAULT”指定的命令)
   4. 如果需要实现一个不是实际文件的目标,我们只是需要通过使用这个目标来完成对它所依赖的文件的重建动作,首先应该想到伪目标而不是空命令目标
   5. 对于空命令规则,最好不要给它指定依赖文件,因为一个实际不存在的目标文件的依赖文件,可能不会被正确重建
10. 递归执行规则
	1. make 的递归过程指的是:在 Makefile 中使用“make”作为一个命令来执行本身或者其它 makefile 文件的过程
	2. 语法: subsystem: <ENTER><TAB>$(MAKE) -C subdir
	3. 含义: 进入子目录,然后在子目录下执行make
	4. 递归调用在一个存在有多级子目录的项目中非常有用
11. 多目标规则
	1. 使用场合:
	   1. 场合1: 仅需要一个描述依赖关系的规则,不需要在规则中定义命令,$(head-y) $(init-y) $(core-y) : init usr drivers sound firmware net lib virt
	   2. 场合2: 多个"目标"依赖于相同的一组"依赖",需要针对不同的目标使用不同的命令进行重建:
	      1. init usr drivers sound firmware net lib virt : prepare scripts
          2. ----$(Q)$(MAKE) $(build)=$@
	2. 一个多目标的规则相当于多个单目标规则,多目标规则意味着所有的目标具有相同的依赖文件
	3. 在"命令"中使用自动化变量“$@”后,可以根据不同的目标使用不同的命令,但是,多目标的规则并不能做到根据目标文件自动改变依赖文件,需要实现这个目的是,要用到make的静态模式
	4. 通常,出现多目标的场合,其命令中都会有自动化变量$@,因为多目标的精髓就是实现多个"目标"和不同"命令"的对应
12. 一"目标"多"规则"
	1. 多个"规则"具有相同的"目标"是允许的,所有规则的依赖关系被合并,如果目标比任一个依赖文件旧，命令被执行
	2. 但是,一个"目标"只能有一个"命令"与之对应,如果多个规则对于同一"目标"都给出了命令，make使用最后一个"规则"的"命令"并打印警告信息
13. 静态模式规则
14. 
Blog creation time:[2017-10-27 五 09:04]
** DONE [#D] Theme: 隐式规则								:@Blog:@Makefile:
1. c 的自动推导规则:
   1. 隐式: test.o: test.h defs.h
   2. 显式: test.o: test.c test.h defs.h
      ---------$(CC) -c test.c $(CPPFLAGS) $(CFLAGS) -o test.o
   3. 结论: 在makefile文件中写出1所示的隐式语法,make会自动推导成2所示的显式语法,即“N.o”自动由“N.c” 生成,执行命令为“$(CC) -c $(CPPFLAGS) $(CFLAGS)”
2. c++ 的自动推到规则:
   1. 隐式: test.o: test.h defs.h
   2. 显式: test.o: test.cc test.h defs.h
      ---------$(CXX) -c test.cc $(CPPFLAGS) $(CFLAGS) -o test.o
   3. 结论: 在makefile文件中写出1所示的隐式语法,make会自动推导成2所示的显式语法,即“N.o”自动由“N.cc”或者“N.C” 生成,执行命令为“$(CXX) -c $(CPPFLAGS) $(CFLAGS)”
   4. 备注: 建议使用“.cc”作为C++源文件的后缀,而不是“.C
3. asm 的自动推到规则:
   1. 隐式: test.o: test.h defs.h
   2. 显式: test.o: test.s test.h defs.h
      ---------$(AS) -c test.s $(ASFLAGS) -o test.o
   3. 结论: 在makefile文件中写出1所示的隐式语法,make会自动推导成2所示的显式语法,即“N.o” 可自动由“N.s”生成,执行命令是:“$(AS) $(ASFLAGS)”
   4. 备注: “N.S”是需要预处理的汇编源文件，“N.s”是不需要预处理的汇编源文件,“ N.s ” 可 由 “ N.S ” 生 成 ,汇编器为“as”
4. 备注: 这意味着，我们可以在Makefile中定义一下CPPFLAGS和CFLAGS这两个变量，在书写规则时，可以省略掉依赖文件中的*.c以及命令，因为隐含规则会自动被使用
5. 执行make命令时,在命令行中隐式生成指定目标  (前提: 当前目录下不存在以“GNUmakefile”、“makefile”、“Makefile”命名的任何文件)
   1. 前目录下存在一个源文件foo.c的,我们可以使用“make foo.o”自动生成foo.o(虽然makefile中没有关于foo.o为目标的规则)
	  1. 当执行“make foo.o”时,实质上make隐式执行了命令: $(CC) -c foo.c $(CPPFLAGS) $(CFLAGS) -o foo.o
   2. 如果当前目录下没有foo.c文件时,使用命令“make foo.o”时,将显示到如下提示
	  1. make: *** No rule to make target ‘foo.o’. Stop.
   3. 如果直接使用命令“make”时,得到的提示信息如下:
	  1. make: *** No targets specified and no makefile found. Stop.
** WAITTING [#D] Theme:指示符								:@Blog:@Makefile:
   SCHEDULED:<2017-10-27 五>
1. 作用: 指示符指明在 make 程序读取 makefile 文件过程中所要执行的一个动作
2. makefile的指示符: "文件包含(include)", "条件执行(ifdef)", "多行定义(define)"
3. "文件包含"指示符:include
   1. 语法: include foo *.mk $(bar) <===> include foo a.mk b.mk c.mk bish bash   (备注: 存在三个 .mk 文件 a.mk、b.mk、c.mk,“$(bar)”被扩展为“bish bash”)
   2. 作用: 读取给定文件名的文件,将其内容作为makefile文件的一部分
   3. 读取过程:
	  1. include”指示符告诉 make 暂停读取当前的 Makefile,而转去读取“include”指定的一个或者多个文件
	  2. 完成以后再继续当前 Makefile 的读取
	  3. 具体搜索文件的过程参看下面4路径问题中3的描述
   4. 路径问题(已测试):
	  1. 以当前Makefile所在的目录为根开始搜索指定文件
	  2. 如果 foo 在上层目录(以当前makefile所在的目录为根)下的 src/,则可以这样写: include ../src/foo 找到 foo
	  3. 如果没有使用全路径(src/foo)的形式,仅仅: include foo
		 1. 首先在当前Makefile所在目录下搜索 foo, 找到,则读取其内容
		 2. 如果当前目录下不存在 foo, 则,首先查找使用命令行选项“-I”或者“--include-dir”指定的目录,找到,则读取其内容
		 3. 如果没有找到,则依此搜索以下几个目录(如果其存在):“/usr/gnu/include”、“/usr/local/include”和“/usr/include”,找到,则读取其内容
		 4. 如果上面的目录下都没有找到,make将会提示一个包含文件未找到的告警提示,但是不会立刻退出,而是继续处理Makefile的后续内容
		 5. 当完成读取整个Makefile后,make将试图使用规则来创建通过指示符“include”指定的但未找到的文件(参考makefile文件的重建)
		 6. 当没有创建这个文件的规则时,make将提示致命错误并退出,并输出错误提示:
			1. Makefile: 错误的行数:未找到文件名:提示信息( No such file or directory )
			2. Make : *** No rule to make target ‘<filename>’. Stop
   5. 使用场合:
	  1. 通常每个子目录下都有一个Makefile来描述该子目录下文件的重建规则,它们使用到一组公用的变量定义,模式规则等,此时,可以将这些共同使用的变量或者模式规则定义在一个文件中,在需要使用的Makefile中使用指示符“include”来包含此文件
	  2. 可以将"自动产生的依赖文件"的include进当前Makefile中,此时当前的Makefile就可以使用"自动产生的依赖文件"中的规则
   6. 可使用“-include”来代替“include”,来忽略由于包含文件不存在或者无法创建时的错误提示
      1. -include 的形式只有在终极目标无法创建时,才报错而退出,即,在顶层Makefile执行完毕后才报错退出
	  2. include 的形式在读取完毕当前的Makefile时,即没有找到被include的文件,也没有发现创建这个文件的规则时就退出
   7. 为了和其它的 make 程序进行兼容,也可以使用“sinclude”来代替“-include”(GNU 所支持的方式)
   8. 注意: include 的对象是 Makefile 相关的规则,变量等, 与源文件或者头文件没有关系
4. "条件比较"指示符: ifeq 
   1. 作用: 决定(通常是根据一个变量的值)处理或者忽略Makefile中的某一特定部分
   2. 注意: 条件表达式工作于文本级别,即条件语句只能用于控制 make 实际执行的 makefile 文件部分,它不能控制规则的 shell 命令执行过程
   3. 示例:
	  1. test.o: $(objs)
	  2. ifeq ($(CC),gcc)
	  3. ----$(CC) -o foo $(objects) $(libs_for_gcc)
	  4. else
	  5. ----$(CC) -o foo $(objects) $(normal_libs)
	  6. endif
	  7. 备注: 从该实例中可以体会到,为什么说条件表达式工作于文本级别,不能控制规则的 shell 命令执行过程
   4. ifeq($(CC),gcc)
	  1. 条件语句的开始
	  2. 比较$(CC)和gcc是否相等
	  3. 变量CC在和gcc比较时进行展开$(CC)
   5. else
	  1. 当$(CC)的值同gcc不相等时,执行该语句
	  2. 不是所有的条件语句都需要此部分
   6. endif
	  1. 条件语句的结束,任何一个条件表达式都必须以“endif”结束
5. "条件判断"指示符: ifdef
   1. 作用: 用来判断一个变量是否已经定义,即是否有值
   2. 说明: 如果变量foo的值不为空,则说明该变量已经定义,表达式为真执行ifdef,而如果变量的值为空,则说明没有定义,执行else部分
   3. 注意: ifdef 只是测试一个变量是否有值,不会对变量进行替换展开,当我们需要判断一个变量的值是否为空的情况时需要使用ifeq而不是ifdef
   4. 示例:
	  1. 例1:
	  2. bar =
	  3. foo = $(bar)
	  4. ifdef foo
	  5. frobozz = yes
	  6. else
	  7. frobozz = no
	  8. endif
      9. 
	  10. 例2:
	  12. foo = 
	  13. ifdef foo
	  14. frobozz = yes
	  15. else
	  16. frobozz = no
	  17. endif
	  18. 
	  19. 返回: 例1中返回frobozz = yes,例2返回frobozz = no
   5. ifdef foo
   6. else
   7. endif
   8. 示例:
6. "多行定义"指示符
7. "export"指示符
   1. 命令: export VARIABLE ...
   2. 作用: 当一个变量在上层使用“export”进行声明后,变量和它的值将被加入到当前工作的环境变量中,以后在 make 执行的所有规则的命令都可以使用这个变量
   3. 如果当前makefile中存在与使用过export声明后同名变量的定义,则工作环境变量中的定义不会覆盖当前Makefile中定义的值
   4. 没有使用指示符“export”对任何变量进行声明的情况下,上层 make 只将那些已经初始化的环境变量和使用命令行指定的变量(如命令“makeCFLAGS +=-g”或者“make –e CFLAGS +=-g”)传递给子 make 程序
   5. 特殊的变量“SHELL”和“MAKEFLAGS”总是加入到当前工作环境中,除非使用unexport
   6. 指示符“export”或者“unexport”的参数(变量部分),如果它是对一个变量或者函数的引用,这些变量或者函数将会被立即展开。并赋值给export或者unexport的变量
   7. 在没有使用关键字“export”声明的变量,make 执行时它们不会被自动传递给子 make,因此下层 Makefile 中可以定义和上层同名的变量,不会引起变量定义冲突
   8. EXPORT_ALL_VARIABLES含义是将此 Makefile 中定义的所有变量传递给子 make 过程,如果不需要传递其中的某一个变量,可以单独使用指示符“unexport”来声明
	  Blog creation time:[2017-10-27 五 08:53]
** WAITTING [#D] Theme:变量								:@Blog:@Makefile:
    SCHEDULED:<2017-10-26 四>
1. makefile中变量的特征:
   1. 在make读取makefile文件时才进行展开(规则命令行中的变量除外),包括了使用“=”定义和使用指示符“define”定义的
   2. 可以表征任何事物
   3. 变量名不可包括“:”、“#”、“=”、前置空白,尾空白
2. 在变量定义中不能使用通配符,因为变量定义中使用的通配符不会被统配处理,在某些情况下会出现非预期的结果
3. 特殊变量:
   1. MAKEFILE_LIST:
	  1. 执行make命令时,make会去读取当前目录下的Makefile文件,当前目录下的Makefile文件的文件名路径会记录在MAKEFILE_LIST中
	  2. 当前目录下的makefile文件又会使用指示符 "include" 去包含其他目录下的Makefile文件(或者规则相关文件), 同样, 依次将 include 到的文件名路径记录在MAKEFILE_LIST中
	  3. 其次, 命令行执行make时,可以指定去make哪个路径下的makefile文件,命令行指定的这个文件名路径也会被记录到MAKEFILE_LIST中
	  4. 用途: 可以通过测试此变量的最后一个字来获取当前 make 程序正在处理的makefile 文件名
	  5. 示例:
		 1. name1 := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
		 2. include inc.mk src.mk
		 3. name2 := $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
		 4. all:
         5. ----@echo name1 = $(name1)
         6. ----@echo name2 = $(name2)
		 7. 执行make的结果: name1 = Makefile   name2 = src.mk
		 8. 原理: 在一个 makefile 文件中如果使用指示符“include”包含另外一个文件之后,变量“MAKEFILE_LIST”的最后一个字只可能是指示符“include”指定所要包含的那个文件的名字
   2. .VARIABLES
	  1. 此变量是一个只读变量,即,不能通过任何途经给它赋值
	  2. 它被展开以后是此引用点之前,makefile文件中所定义的所有全局变量列表。包括:空变量(未赋值的变量)和make的内嵌变量(参见"隐含变量"),但不包含"目标指定变量"(参见目标指定变量)
   3. CURDIR
	  1. 此变量代表 make 的工作目录
	  2. 当使用“-C”选项进入一个子目录后,此变量将被重新赋值
	  3. 我们也可以在 Makefile 为这个变量赋一个新的值。此时这变量将不再代表 make 的工作目录
   4. MAKE
	  1. 变量“MAKE”的值是“make”,在 Makefile 规则的命令行中应该使用变量“MAKE”来代替直接使用“make”
	  2. 当我们使用一个其它版本的 make 程序时,可以保证最上层使用的 make 程序和其子目录下执行的 make 程序保持一致
	  3. 使用此变量可以改变make的“-t”(“--touch”),“-n”(“--just-print”)和“-q”(“--question”)命令行选项的效果。它所实现的功能和在规则中命令行首使用字符“+”的效果相同
   5. MAKECMDGOALS
	  1. 执行Makefile时,我们可以使用 make clean, make all等方法将clean,all等目标指定为终极目标
	  2. 此变量记录了从外部命令行执行make时传递进来的终极目标列表
	  3. 注意:此变量仅用在特殊的场合(比如: ifneq ($(MAKECMDGOALS),clean) 判断要生成的哪个终极目标),在 Makeifle 中不要对它进行重新定义!
   6. MAKEFLAGS
	  1. 作用: 记录上层 make 的命令行选项(-k -s)等,这些选项会自动通过该变量传递给子 make 进程
	  2. 可以借助该变量传递我们在主控 make 所使用的命令行选项给子 make 进程
	  3. 在某些特殊的场合,可能需要为所有的make进程指定一个统一的命令行选项(比如-k),为了实现这个目的,可以在上层Makefile中设置 MAKEFLAGS=k
      4. “-C”、“-f”、“-o”和“-W”这些命令行选项是不会被赋值给变量“MAKEFLAGS"
	  5. 执行多级的 make 调用时,当不希望传递“MAKEFLAGS”的给子 make 时,需要在调用子 make 是对这个变量进行赋空
	  6. 该变量的定义中引用了变量MAKEOVRRIDES,因此MAKEOVRRIDES中的变量也会通过该变量传递给子make
	  7. 如果在执行 make 时通过命令行指定了“-k”和“-s”选项,那么“MAKEFLAGS”的值会被自动设置为“ks”
	  8. 建议大家最好不要随便更改“MAKEFLAGS”的值,更不要把它设置为系统的环境变量来使用,如果变量“MAKEFLAGS”中包含选项“t”、“n”、“q”这三个的任何一个,当执行 make 的结果可能就不是你所要的
   7. MAKEOVRRIDES
	  1. 作用: 记录外部命令行中变量的定义(如“make CFLAGS+=-g”),MAKEFLAGS引用了该变量,会将其传递到子make
	  2. 当不希望上层make在命令行中定义的变量传递给子 make 时,可以在上层 Makefile 中把"MAKEOVERRIDES"赋空
   8. 
4. "目标指定变量":
   1. 
5. "隐含变量":
   1. 
6. 变量的展开时机:
7. 自动化变量:
   1. (常用):“$@”代表规则的目标
   2. (常用):“$<”代表规则中通过目录搜索得到的依赖文件列表的第一个依赖文件(备注: 比$^常用,因为自动化变量主要用于"命令",如果规则为test.o: defs.h inc.h,那么"命令"中gcc的对象应该是被隐式了的第一个对象test.c,正是$<所指,而使用$^的话gcc defs.h就不合适了,所以通常使用$<代表依赖是正确的选择,但是还是要依情况而定)
   3. “$^”代表所有通过目录搜索得到的依赖文件的完整路径名
   4. 备注: 当Makefile中使用了VPATH,vpath,GPATH等目录搜索功能时,必须使用自动化变
8. 变量的引用: 在Makefile 中符号“$”有特殊的含义,表示变量或者函数的引用($(FOO), 表示对变量FOO的引用),在规则中需要使用符号“$”的地方,需要书写两个连续的(“$$”)

   另外,在使用指示符“define”定义一个多行的变量或者命令包时,其定义体
(“define”和“endef”之间的内容)会被完整的展开到 Makefile 中引用此变量的地方
(包含定义体中的注释行);make 在引用此变量的地方对所有的定义体进行处理,决
定是注释还是有效内容。Makefile 中变量的引用和 C 语言中的宏类似(但是其实质并
不相同,后续将会详细讨论)。对一个变量引用的地方 make 所做的就是将这个变量根
据定义进行基于文本的展开,展开变量的过程不涉及到任何变量的具体含义和功能分
析。
Blog creation time:[2017-10-26 四 14:04]
** WAITTING [#D] Theme:函数 								:@Blog:@Makefile:
   SCHEDULED:<2017-10-26 四>
1. makefile中函数的特征:
   1. 在make读取makefile文件时才进行展开(规则命令行中的函数除外)
2. 函数的展开时机:
3. $(substr FROM,TO,TEXT):
   1. 作用:将字串"TEXT"中的"FROM字串"替换为"TO"字串
   2. 返回值: fEEt on the strEEt
   3. 示例: $(subst ee,EE,feet on the street)
4. $(patsubst PATTERN,REPLACEMENT,TEXT)
   1. 作用: 搜索“TEXT”中以空格分开的单词,将符合模式“TATTERN”替换为“REPLACEMENT”
   2. 返回值: 返回值:替换后的新字符串
   3. 说明: "PATTERN"和"REPLACEMENT"中可以使用模式通配符"%",参数“TEXT”单词之间的多个空格在处理时被合并为一个空格,并忽略前导和结尾空格
   4. 示例:
	  1. $(patsubst %.c,%.o,x.c.c bar.c)
	  2. 返回值: x.c.o bar.o
5. $(findstring FIND,IN)
   1. 作用: 在子串IN中查找FIND子串
   2. 返回值: 如果找到子串FIND,则返回“FIND”,否则返回空
   3. 注意: 字串“IN”之中可以包含空格、[Tab],搜索需要是严格的文本匹配
6. $(addsuffix SUFFIX,NAME1 NAME2 ...):
   1. 作用: 为NAME1 NAME2 ... 中的每一个名字添加后缀SUFFIX
   2. 返回值: foo.c bar.c fun.c
   3. 示例: $(addsuffix .c,foo bar fun)
7. $(wildcard PATTERN...):
   1. 示例: OBJS = $(wildcard *.o): 获取当前Makefile所在目录下的所有*.o文件,将其组织成使用空格分开的文件列表,赋值给变量OBJS
   2. 返回值: 当存在*.o时,返回使用空格分开的文件列表,当不存在*.o时,返回空
   3. 使用场合: 通配符是不支持变量的定义和函数的引用的,而搭配该函数,便可使得变量的定义和函数支持通配符
   4. 经典用法: OBJS := $(patsubst %.c,%.o,$(wildcard *.c))
8. $(call VARIABLE,PARAM,PARAM,...)
   1. 示例: pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(substr :, ,$(PATH)))))  LS := $(call pathsearch,ls)
   2. 返回值: ba
9. $(if CONDITION,THEN-PART[,ELSE-PART])
   1. 如果“CONDITION”的展开结果非空,则条件为真,就将第二个参数“THEN_PATR”作为函数的计算表达式;
   2. 如果“CONDITION”的展开结果为空,将第三个参数“ELSE-PART”作为函数的表达式
   3. 如果“CONDITION”的展开结果为空,但是不存在第三个参数“ELSE-PART”,函数返回空
   4. 根据条件决定函数的返回值是第一个或者第二个参数表达式的计算结果
   5. 函数的条件表达式“CONDITION”决定了函数的返回值只能是“THEN-PART”或者“ELSE-PART”两个之一的计算结果
10. $(strip STRINT)
	1. 函数功能: 去掉字串“STRINT”开头和结尾的空字符,并将其中多个连续空字符合并为一个空字符
	2. 返回值: 无前导和结尾空字符、使用单一空格分割的多单词字符串
11. $(sort LIST)
	1. 给字串“LIST”中的单词以首字母为准进行排序(升序),并去掉重复的单词
	2. 返回值:空格分割的没有重复单词的字串
	3. 示例: $(sort foo bar lose foo),返回“bar foo lose”
12. $(filter PATTERN...,TEXT)
	1. 作用: 保留所有符合此模式的单词,过滤掉字串“TEXT”中所有不符合模式“PATTERN”的单词
	2. 返回值: 空格分割的“TEXT”字串中所有符合模式“PATTERN”的字串
	3. 说明: 可以使用多个模式。模式中一般需要包含模式字符“%”。存在多个模式时,模式表达式之间使用空格分割
	4. 示例:
	   1. sources := foo.c bar.c baz.s ugh.h
	   2. $(filter %.c %.s,$(sources))
	   3. 返回: foo.c bar.c baz.s
13. $(filter-out PATTERN...,TEXT)
	1. 作用: 保留所有不符合此模式的单词,过滤掉字串“TEXT”中所有符合模式“PATTERN”的单词
	2. 说明: 和“filter”函数实现的功能相反
	3. 示例:
	   1. objects=main1.o foo.o main2.o bar.o
	   2. mains=main1.o main2.o 
	   3. $(filter-out $(mains),$(objects))
	   4. 返回: foo.o bar.o
14. $(words TEXT)
	1. 作用: 计算字串“TEXT”中单词的数目
	2. 返回值: “TEXT”字串中的单词数
	3. 示例: $(words, foo bar)
	4. 返回: 2
15. $(word N,TEXT)
	1. 作用: 取字串“TEXT”中第“N”个单词(“N”的值从 1 开始)
	2. 返回值:返回字串“TEXT”中第“N”个单词
	3. 说明: 如果“N”值大于字串“TEXT”中单词的数目,返回空字符串。如果“N”为 0,出错!
	4. 示例: $(word 2, foo bar baz)
	5. 返回 bar
16. $(firstword NAMES...)
	1. 作用: 取字串“NAMES...”中的第一个单词
	2. 字串“NAMES...”的第一个单词
	3. 说明: 函数“firstword”实现的功能等效于“$(word 1, NAMES...)”
	4. 提示: 取字串“NAMES...”中的最后一个单词: $(word $(words NAMES),NAMES)
	5. 示例: $(firstword foo bar)
	6. 返回: foo
17. $(shell bash-cmd...)
	1. 返回值: bash-cmd命令在bash中的执行结果
	2. make将函数返回结果中的所有换行符“\n”或者一对“\n\r”替换为单空格;并去掉末尾的回车符号(“\n”)或者“\n\r”
	3. 示例:
	   1. KBUILD_OUTPUT := $(shell mkdir -p $(KBUILD_OUTPUT) && cd $(KBUILD_OUTPUT) \
		  && /bin/pwd)
	   2. 返回: 绝对路径
18. $(dir NAMES...)
	1. 从文件名序列“NAMES...”中取出各个文件名的目录部分(文件名的目录部分就是包含在文件名中的最后一个斜线(“/”)(包括斜线)之前的部分)
	2. 返回值: 空格分割的文件名序列“NAMES...”中每一个文件的目录部分
	3. 如果文件名中没有斜线,认为此文件为当前目录(“./”)下的文件,返回./
	4. 示例:
	   1. 
19. $(error TEXT...)
	1. 功能: 产生致命错误,并提示“TEXT...”信息给用户,并退出 make 的执行
	2. 说明: error”函数是在函数展开式(函数被调用时)才提示信息并结束 make 进程,只有包含“error”函数引用的命令被执行, 或者定义中引用此函数的递归变量被展开时,才会提示致命信息“TEXT...”同时退出 make
	3. 返回值: 空
20. 
21. 
22. 
Blog creation time:[2017-10-26 四 13:40]
** WAITTING [#D] Theme:注释								:@Blog:@Makefile:
    SCHEDULED:<2017-10-27 五>
1. Makefile 中“#”字符后的内容被作为是注释内容
2. 如果此行的第一个非空字符为“#”,那么此行为注释行
3. 注释行的结尾如果存在反斜线(\),那么下一行也被作为注释行
4. 推荐将注释作为一个独立的行,而不要和 Makefile 的有效行放在一行中书写
5. 需要使用字符“#”时,可以使用反斜线加“#”(\#)来实现
6. Makefile 中第一个规则之后的所有以[Tab]字符开始的的行, make 程序都会将其交给系统 shell 程序去解释执行,以[Tab]字符开始的注释行也会被交给 shell 来处理
Blog creation time:[2017-10-27 五 09:04]
** WAITTING [#D] Theme:命令行参数							:@Blog:@Makefile:
    SCHEDULED:<2017-10-27 五>
1. “-t”选项用来更新所有目标的时间戳,而不执行任何规则的命令



-B

--always-make

强制重建所有规则的目标，不根据规则的依赖描述决定是否重建目标文件。

-C DIR

--directory=DIR

在读取Makefile之前，进入目录“DIR”，就是切换工作目录到“DIR”之后执行make。存在多个“-C”选项时，make的最终工作目录是第一个目录的相对路径。如：“make –C / -C etc”等价于“make –C /etc”。一般此选项被用在递归地make调用中。

-d

make在执行过程中打印出所有的调试信息。包括：make认为那些文件需要重建；那些文件需要比较它们的最后修改时间、比较的结果；重建目标所要执行的命令；使用的隐含规则等。使用“-d”选项我们可以看到make构造依赖关系链、重建目标过程的所有信息，它等效于“—debug=a”.

—debug[=OPTIONS]

make执行时输出调试信息。可以使用“OPTIONS”控制调试信息级别。默认是“OPTIONS=b”，“OPTIONS”的可能值为以下这些，首字母有效（all 和 aw等效）。

a（all）

输出所有类型的调试信息，等效于“-d”选项。

b（basic）

输出基本调试信息。包括：那些目标过期、是否重建成功过期目标文件。

v（verbose）

“basic”级别之上的输出信息。包括：解析的makefile文件名，不需要重建文件等。此选项目默认打开“basic”级别的调试信息。

i（implicit） 

输出所有使用到的隐含规则描述。此选项目默认打开“basic”级别的调试信息。

j（jobs） 

输出所有执行命令的子进程，包括命令执行的PID等。

m（makefile）

也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。

-e

--environment-overrides

使用系统环境变量的定义覆盖Makefile中的同名变量定义。

-f=FILE

--file= FILE

--makefile= FILE

指定“FILE”为make执行的makefile文件。

-h

--help

打印帮助信息。

-i

--ignore-errors

执行过程中忽略规则命令执行的错误。

-I DIR

--include-dir=DIR

指定被包含makefile文件的搜索目录。在Makefile中出现“include”另外一个文件时，将在“DIR”目录下搜索。多个“-I”指定目录时，搜索目录按照指定顺序进行。

-j  [JOBS]

--jobs[=JOBS]

指定可同时执行的命令数目。在没有指定“-j”参数的情况下，执行的命令数目将是系统允许的最大可能数目。存在多个“-j”参数时，尽最后一个“-j”指定的数目（“JOBS”）有效。

-k

--keep-going

执行命令错误时不终止make的执行，make尽最大可能的执行所有的命令，直到出现致命错误才终止。

-l LOAD

--load-average[=LOAD]

—max-load[=LOAD]

告诉make当存在其它任务在执行时，如果系统负荷超过“LOAD”（浮点数表示的），不再启动新任务。没有指定“LOAD”的“-I”选项将取消之前“-I”指定的限制。

-n

--just-print

--dry-run

--recon

只打印出所要执行的命令，但不执行命令。

-o FILE

--old-file= FILE

--assume-old= FILE

指定文件“FILE”不需要重建，即使相对于它的依赖已经过期；同时也不重建依赖于此文件任何文件（目标文件）。注意：此参数不会通过变量“MAKEFLAGS”传递给子make进程。

-p

--print-data-base

命令执行之前，打印出make读取的Makefile的所有数据（包括规则和变量的值），同时打印出make的版本信息。如果只需要打印这些数据信息（不执行命令）可以使用“make -qp”命令。查看make执行前的预设规则和变量，可使用命令“make –p -f /dev/null”。

-q

--question

称为“询问模式”；不运行任何命令，并且无输出。make只是返回一个查询状态。返回状态为0表示没有目标需要重建，1表示存在需要重建的目标，2表示有错误发生。

-r

--no-builtin-rules

取消所有内嵌的隐含规则，不过你可以在Makefile中使用模式规则来定义规则。同时选项“-r”会取消所有支持后追规则的隐含后缀列表，同样我们也可以在Makefile中使用“.SUFFIXES”定义我们自己的后缀规则。“-r”选项不会取消make内嵌的隐含变量。

-R

--no-builtin-variabes

取消make内嵌的隐含变量，不过我们可以在Makefile中明确定义某些变量。注意，“-R”选项同时打开“-r”选项。因为没有了隐含变量，隐含规则将失去意义（隐含规则是以内嵌的隐含变量为基础的）。

-s

--silent

--quiet

取消命令执行过程的打印。

-S

--no-keep-going

--stop

取消“-k”选项。在递归的make过程中子make通过“MAKEFLAGS”变量继承了上层的命令行选项。我们可以在子make中使用“-S”选项取消上层传递的“-k”选项，或者取消系统环境变量“MAKEFLAGS”中的“-k”选项。

-t

—touch

和Linux的touch命令实现功能相同，更新所有目标文件的时间戳到当前系统时间。防止make对所有过时目标文件的重建。

-v

--version

查看make版本信息。

-w

--print-directory

在make进入一个目录读取Makefile之前打印工作目录。这个选项可以帮助我们调试Makefile，跟踪定位错误。使用“-C”选项时默认打开这个选项。参考本节前半部分“-C”选项的描述。

--no-print-directory

取消“-w”选项。可以是用在递归的make调用过程中，取消“-C”参数的默认打开“-w”功能。

-W FILE

--what-if= FILE

--new-file= FILE

--assume-file= FILE

设定文件“FILE”的时间戳为当前时间，但不改变文件实际的最后修改时间。此选项主要是为实现了对所有依赖于文件“FILE”的目标的强制重建。

--warn-undefined-variables

Blog creation time:[2017-10-27 五 11:28]

** tmp

*** 模式规则
	--Makefile中自己定义了一些隐含规则，但是有时候这些隐含规则不够我们使用，所以我们需要自己定义
	一些隐含的规则，称用户自己定义的隐含规则为模式规则
	
	--模式规则的基本要求：模式规则的目标有且仅有一个%，用于匹配任意非空的字符串
	
	--定义一个自己的隐含规则：
	%.o : %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $^ -o $@
	备注：如此，便定义了一个用户的隐含规则，make会把该规则加入到自己的隐含规则里面，该规则
	表示把任意一个%.c的文件都使用该规则描述的命令编译成%.o文件
	
	--任意模式匹配规则：
	% ： %.c
	touch $@
	备注：该规则表示将任意一个目标都更新一下
	任意模式匹配规则可以匹配任意一个target,但是，这种理解起来需要注意一点，比如:foo:foo.o bar.o,
	由于默认隐含规则中指明foo.o是依赖于foo.c的，但是套用%：%.c得出的结果是foo.o:foo.o.c,这个就有问题，
	在makefile中，有两种机制来解决这种问题的，第一种机制：先使用默认的隐含规则来寻找，找不到才会使用这种任意模式规则，
	由于foo.o的默认隐含规则就匹配到foo.c了，所以，就不会再去理会用户自己定义的隐含规则：任意模式匹配规则，来解析
	出foo.o.c这样的依赖；第二种机制：用户使用双冒号来定义任意模式规则而不是单冒号，称为terminal规则，如：
	% :: %.c
	touch $@
	其中：双冒号对依赖进行了限制，只有依赖确实存在时，才会使用这种规则，比如，foo:foo.o,使用foo.o来套用这种
	规则后是foo.o :: foo.o.c,双冒号规定了会对依赖文件的存在性进行检查，由于foo.o.c在当前目录下是找不到的，
	所以，foo.o是不可以套用该规则的
	
	--取消隐含规则
	有时候，我们会觉得makefile自带的隐含规则用不到，多余，或者对真实的情况造成麻烦，就需要取消这些隐含规则，
	取消的方法就是重新定义来覆盖掉默认的隐含规则，其原理是，当用户自定义的目标和依赖同默认的隐含规则的相同时，
	默认的隐含规则就会被覆盖
	例如：使用%.o:%.s就可以将所有.s文件汇编成机器码.o的默认规则给取消掉
*** 指令(编译+连接+运行)
	情景一:
	--test目录下:src inc两个目录 
	--src目录下:hello thanks两个目录
	--hello目录下:hello.c
	--thanks目录下:thanks.c
	--inc目录下:thanks.h
	备注:hello.c文件中调用到thanks.c文件提供的一个函数thank_you(),所以thanks.h被hello.c文件和thank.c文件所依赖
	
	编译:(在test目录下执行下面指令)
	--gcc -c ./src/hello/hello.c ./src/thanks/thanks.c -Wall -O -I ./inc ./src/
	-->-c:编译
	-->-Wall:编译过程信息
	-->-O:优化
	-->-I:指定头文件路径:./inc
	-->./src:编译后产生的目标文件放置到哪
	语义:在test目录下执行gcc命令,编译./src/hello这个路径下面的hello.c以及./src/thanks这个路径下面的thanks.c,要求实时显示
	编译产生的信息,同时做一个-O1的优化,由于thanks.h被hello.c文件和thank.c文件所依赖,所以将thank.h的路径./inc告知gcc,以便能找到路径
	备注：有一个比较奇怪的写法：gcc -c test.c -o xxx.o 其含义同gcc -c test.c是一样的，只不过gcc -c test.c编译的结果默认是test.o,而
	在gcc -c test.c后面加上-o xxx.o则表示希望编译的结果是xxx.o而不是test.o 
	
	
	链接:
	--gcc -o  test test.o test1.o test2.o
	-->-o:链接
	-->test:链接之后生成的可执行文件
	-->*.o:被链接的目标文件
	
	运行: ./test   -->  thank you very! hello world!
*** 静态库和动态库
**** 函数库:
	 有若干源文件(.c),每个源文件里面都提供了一些独立的工具函数,比如一个好的算法策略,一个常用的数学函数公式的实现(标准偏差)等,
	 如果这些源文件需要经常被使用,或者这些工具函数已经比较成熟了,那么可以考虑将它们编译成一个函数库并统一命名,然后提供出这个函数库中
	 所有工具函数的函数原型如:void *malloc(size_t size),同时附上使用说明,以后如果使用到该函数库中的某一个函数时,只用在该函数库的说明文档
	 中找到该函数,然后参照使用说明,在编译时,将函数库与用户程序建立起联系,即可使用该函数
**** 静态库策略:
	 --策略概述:
	 -->制作出静态链接库文件
	 -->编译用户源代码,生成用户的目标文件
	 -->链接用户目标文件为可执行文件期间,将静态库.a链接进来,生成最终的可执行文件,其链接方式是:整个静态库被连接到了用户代码里面成了用户代码的一部分
	 特点:整个函数库被链接到用户代码中,所以生成的可执行文件比较大,但是执行速度快(不过如今CPU的运算速度高速发展,这点速度的提升已经没有太大的追求价值,而文件的
	 大小可能在嵌入式领域那种内存宝贵的情况下就比较看中,这也是静态连接没有动态连接火爆的原因吧)
	 备注:当同时运行许多运用程序并且他们都使用来自同一个函数库的函数时,内存中就会有同一个函数的多份副本,而且在程序文件自身中也会有很多份副本,这样将会消耗很多宝贵的内存
	 
	 --细节:
	 -->在.c文件中的工具函数实现应该是独立的,不可再引用其他函数库(没有头文件)
	 -->函数库是在链接阶段(gcc -o main main.o -lstatic -L ./mylib)而不是编译阶段,被整合到用户的代码里面的
	 -->静态函数库发生改变时,整个程序必须重新编译
	 -->extern int a 和include "xxx.h"都是用来应付编译器的编译阶段,在编译源文件时,extern关键字告知编译器,a在其他文件定义了,虽然你现在找不到a,但是
	 我跟你保证a是存在的,现在你不要因为找不到a而报错,接着编译即可;到了连接阶段,所有源文件都已经编译成了目标文件,这时所有文件的内容都可见了,编译器就会
	 在所有的目标文件中查找有没有a,如果找到了a,那好,说明在编译阶段extern没有骗编译器,如果没有找到,那就报错;显然,include也有这样的功能,其目的就是解决编译器
	 在编译阶段因为暂时找不到某个编译对象而终止编译的情况,连接阶段就是真正考究编译正确性的时刻
	 --在Windows下,静态链接库文件以.lib为后缀,在Linux下,以.a为后缀,即archive
	 
	 --静态库操作命令:arr
	 -->arr -cr libxxx.a yyy1.o yyy2.o:创建库libxxx.a并插入yyy1.o yyy2.o模块到该库(c,创建,r,c插入,注意,单独使用c是不会创建libxxx.a的,报错没有执行的操作,r就是一个操作)
	 -->arr -pv libxxx.a yyy.o:打印出静态库libxxx.a中的yyy.o的内容(p,打印,v标识各个模块)
	 -->arr -tv libxxx.a:显示库中的模块清单,只显示库名
	 -->arr -rv libxxx.a yyy1.o yyy2.o:在静态库libxxx.a中所有模块的最后插入模块yyy1.o,yyy2.o,如果静态库libxxx.a不存在则创建,并插入模块yyy1.o,yyy2.o,如果存在静态库,并且静态库
	 里面存在待插入的模块,则替换同名模块(r,插入,v显示操作信息:a - xx或者d - xx,即增加还是删除)
	 -->arr -qv libxxx.a yyy4.o:在静态库libxxx.a的结尾处快速追加模块yyy4.o,而不去检查是否需要替换
	 -->arr -dv libxxx.a yyy2.o:从静态库libxxx.a中删除模块yyy2.o(d,删除模块,v提示删除信息d - yyy2.o)
	 -->arr -s libxxx.a:写入符号表索引到库libxxx.a中 
	 备注:arr还有几个指令可以指定插入模块的位置,不过没有测试过,就不列举出来了,有需要时再man ar即可
	 
	 总结:创建静态库常规的指令:arr -crs libxxx.a ${objects}
**** 动态库策略:
	 --策略概述:
	 -->制作出动态链接库文件
	 -->编译用户源代码,生成用户的目标文件
	 -->链接用户目标文件为可执行文件期间,将动态库.so链接进来,生成最终的可执行文件,其链接的方式是:动态链接库的名字以及库内部的所有函数名字被连接到用户代码里面
	 成为用户代码的一部分,而动态库内部函数的实现代码不会被连接进入用户代码,即,用户代码只是引用了动态库,链接的结果形成可执行文件,当可执行文件被执行时,通过该执行文件
	 内部在链接阶段加入的动态库名以及函数名,找到具体的动态库(.so)下面的具体的函数并调用,如果有必要的话才会将动态库加载到内存中去
	 
	 特点:动态库策略在制作的动态库文件体积比较小,同时动态库策略使用的是一种共享的原则,不会在内存中产生库的多份拷贝,另外,动态库的一个好处是动态库的更新可以独立于依赖
	 它的运用程序,这句话有相当的份量,动态库在连接阶段只是将库名和所有函数原型封装到可执行文件中了,在以后调用可执行文件时会实时去动态库里面找具体的实现,这不就意味着,
	 只要我们不改变动态库的名字和函数原型,我们可以随意更改构成动态库的源代码(比如用一个更好的算法来替换某一个函数中一般的算法),该完以后,重新生成一遍动态库,替换掉老的,
	 那么当以前依赖该动态库的一些运用程序(比如test),当执行./test时,还是可以依据动态库名和函数原型去动态库(.so)找具体的实现,只不过现在的实现用了一个更加牛叉的算法来改善
	 了程序的性能而已,所以,针对那些个依赖该动态库的运用来说,是感受不到影响的,当然了,你如果针对动态库的某个函数不是做优化,而是直接改变其功能(比如将gui运用程序所调用的动态库的
	 某个描述颜色的函数的颜色值改变了),那么依赖该动态库的运用如果调用到该函数,则其主题颜色自然就发生改变,还有就是,以后也可以往该动态库中加入函数,由于是新加入的函数,以前依赖
	 该动态库的运用程序肯定没有用到自然也不会受到影响,新加入的函数能可以用于从这一版本的动态库发布后开发其他的运用;显然,删除动态库内的函数就一定得谨慎了,因为如果你删除的
	 这个函数如果恰好被某个运用程序调用过,那么,以后最新版本发布的动态库,如果那个运用进行了更新,那么基本上他的这个运用是不能运行了.
	 
	 总结:综上所述,动态库也叫共享库,该共享库的制作者(发布者)可以修改,添加该共享库的函数的实现,但是删除共享库中的某一函数需要慎重,除非你决定在这一版本中,或者以后将不再
	 维护和支持该功能,明白你要做的事情之后才能进行删除,并且在产品发布的时候并告知用户不再支持某一项功能,基于这一个原因,为了避免程序更新而导致不能使用,当Linux启动运用程序时,
	 会考虑运用程序需要的函数版本,以防止动态库的新版本导致某些旧的运用程序无法使用
	 
	 细节:
	 --可以使用ldd命令查看动态库的使用情况:ldd main 
	 --在Windows下,态链接库文件以.dll为后缀,即Dynamic Link Library,在Linux下以.so为后缀
	 --LD_LIBRARRY_PATH:该环境变量指示动态连接器可以装载动态库的路径
	 --静态库策略以空间换时间,动态库策略是以时间换空间
*** 制作静态链接库文件libstatic.a
	--环境:
	-->工作目录:test,该目录下有一个库目录libstatic,以及两个文件main.c,libstatic.h
	-->libstatic目录下面有add.c,sub.c,mul.c,div.c,Makefile四个文件
	
	--目的:
	-->将libstatic目录下的.c文件生成静态库libstatic.a,在main.c中调用静态库中的工具函数
	-->libstatic.h下面给出了静态库libstatic.a中的所有工具函数的原型
	
	--实现步骤:
	-->在4个文件内里面分别编写add.c,sub.c,mul.c,div.c文件:
	float add(int a,int b)
	{
	return (a+b);
	}
	float sub(int a,int b)
	{
	return (a-b);
	}
	float mul(int a,int b)
	{
	return (a*b);
	}
	float div(int a,int b)
	{
	return (a/b);
	}
	
	-->编写库函数的头文件libstatic.h:
	## libstatic.h
	#ifndef _LIBSTATIC_H 
	#define _LIBSTATIC_H
	float add(int a,int b);
	float sub(int a,int b);
	float mul(int a,int b);
	float div(int a,int b);
	#endif
	
	-->编写Makefile文件
	objects = add.o sub.o mul.o div.o
	
	libstatic.a : ${objects}
	ar -rcs libstatic.a ${objects}    将目标文件(.o)归档入库libstatic.a
	备注:
	--ar:静态库操作命令,参见上面的介绍
	--libstatic.a:linux中默认规定静态库文件需要以lib开头,以.a结尾;
	--${objects}:有很多.c文件,每个.c文件里面都是一些组成库libstatic.a的独立的工具函数,这些.c文件编译后会生成.o文件,${objects}就是这些.o文件的集合
	这种书写方式在makefile文件中称之为宏,定义的格式是:macro = xx xx xx,其中xx可以是命令如gcc,也可以是选项参数如-Wall,也可以是路径./inc;使用的格式是:$(macro)或者${macro}
	
	add.o : add.c
	gcc -c add.c
	
	sub.o : sub.c
	gcc -c sub.c
	
	mul.o : mul.c
	gcc -c mul.c
	
	div.o : div.c
	gcc -c div.c
	
	clean:
	rm libstatic.a $(objects)
	
	-->生成静态库:make -f Makefile 
	
	-->使用静态函数库libstatic.a
	## main.c
	#include <stdio.h>
	#include "libstatic.h"
	
	int main()
	{
	int a,b;
	a = 10;
	b = 3;
	
	printf("a+b = %f\n",add(a,b));
	printf("a-b = %f\n",sub(a,b));
	printf("a*b = %f\n",mul(a,b));
	printf("a/b = %f\n",div(a,b));
	return 0;
	}
	
	-->编译mani.c:gcc -c main.c -I ./
	
	-->链接:gcc -o main main.o -lstatic -L ./libstatic 
	-l:指明静态库的名字,全名应当是libstatic.a,但是由于lib和.a是linux默认识别的,所以只用写static即可,比如在使用到数学库的场合,加入-lm即可,表示加入libm.a这个静态数学库
	-L:指明静态库的路径,GCC在链接时,默认只会链接/usr/lib下面的C函数库,如果没有该参数的话,linux就会到/usr/lib里面查找-l指定的静态库,如果找不到就报错/usr/bin/ld:cancont find -lstatic
	备注:如果自己做了一个静态库libxxx.a,或者要使用第三方提供的静态库libxxx.a,只用将该静态库添加到/usr/lib目录下,链接时加上-lxxx即可,不用再指明路径
	
	-->运行:./main 
	
*** 制作动态链接库文件libdynamic.so
	--环境:
	-->工作目录:test,该目录下有一个库目录libdynamic,以及两个文件main.c,libdynamic.h
	-->libdynamic目录下面有add.c,sub.c,mul.c,div.c,Makefile四个文件
	
	--目的:
	-->将libdynamic目录下的.c文件生成动态库libdynamic.so,在main.c中调用动态库中的工具函数
	-->libdynamic.h下面给出了动态库libdynamic.so中的所有工具函数的原型
	
	--实现步骤:
	-->在4个文件内里面分别编写add.c,sub.c,mul.c,div.c文件: 见静态库制作
	
	-->编写库函数的头文件libstatic.h:见静态库制作
	
	-->编写Makefile文件:
	objects = add.o sub.o mul.o div.o
	
	libdynamic.so: ${objects}
	gcc -fPIC -shared -o libdynamic.so ${objects}
	备注:
	--fPIC:编译为位置独立的代码,即编译后的库可以存放在内存的任何位置
	--shared:指定生成动态链接库
	
	add.o : add.c
	gcc -c add.c
	
	sub.o : sub.c
	gcc -c sub.c
	
	mul.o : mul.c
	gcc -c mul.c
	
	div.o : div.c
	gcc -c div.c
	
	clean:
	rm libdynamic.so $(objects)
	
	-->编写库函数的头文件libdynamic.h:见静态函数制作
	
	-->使用动态函数库:libdynamic.so
	## main.c
	#include <stdio.h>
	#include "libdynamic.h"
	
	int main()
	{
	int a,b;
	a = 10;
	b = 3;
	
	printf("a+b = %f\n",add(a,b));
	printf("a-b = %f\n",sub(a,b));
	printf("a*b = %f\n",mul(a,b));
	printf("a/b = %f\n",div(a,b));
	return 0;
	}
	-->编译mani.c:gcc -c main.c -I ./
	
	-->链接:gcc -o main main.o -L ./libdynamic -ldynamic 
	
	-->环境变量的处理:
	方案一:将动态链接库拷贝到/usr/lib和/lib目录下,执行./main即可
	方案二:在~/.profile下面添加:export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$MY_PATH (其中,MY_PATH为你所生成的libdynamic.so所在的目录的路径),执行. .profile 
	方案三:在/etc/profile下面添加:export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$MY_PATH (其中,MY_PATH为你所生成的libdynamic.so所在的目录的路径),执行 . /etc/profile
	方案四:在/etc/ld.so.conf.d目录下新建一个文件my.conf,打开该文件,并在里面添加你之前制作的动态库libdynamic.so所在目录的路径,保存退出,执行sudo ldconfig即可运行
	
	备注:方案一,方案三,方案四是全局有效的,方案二只针对当前用户有效,其中方案一的做法将自己的库和系统的库混合在一起,我不太喜欢,个人认为方案四是一种比较优雅的方案
	对于linux来说,负责装载共享库并解析用户程序函数引用情况的程序是动态装载器ld.so,该装载器会在/etc/ld.so.conf.d/下面的文件中索引共享库的额外位置(/usr/lib是标准位置),
	所以只用将你的动态库的路径写入到/etc/ld.so.conf.d/下面的某一文件中(通常是新建一个自己的文件mylib.conf),并调用sudo ldconfig,动态装载器ld.so就能找到你的动态库了,
	可以使用运行工具ldd来查看一个运用程序所需要的共享库,如ldd test
	
	-->运行: ./main
	
	Blog creation time:[2017-09-05 二 08:36]	
** 3. 
4. 
5. Linux下面的可执行文件的ELF格式
6. 链接器的工作对象是.o文件，使用ld工具，最终生成elf可执行文件
   
>> 一个简单的Makefile可能只包含规则，但是通常还会包含规则之外的许多东西

>> 

>>规则的触发：规则的触发决定着该规则是否能得到执行
规则触发的基本原则就是任意规则中，依赖的时间戳比目标的时间戳新时，该规则一定被触发，在
Makefile中有很多规则，一个规则的依赖一般都是(伪目标除外)另一个规则的目标，单就某一规则而言，它被触发可以
理解为两种情况，第一：该规则依赖的时间戳比目标的时间戳新；第二：该规则的依赖是其他规则的目标，那该规则有被
触发的“潜质”
Makefile中第一条规则（默认规则）一定会被触发执行，无论其是目标文件，还是伪目标
伪目标（非默认）必须通过外部调用才能触发
小结：Makefile中规则能否被执行的依据是规则是否能被触发，即，不是所有只要写在Makefile中的规则都能被执行的，
那得看其是否有被触发的条件（当然，只要写在Makefile中的变量都会被执行）

>> makefile程序的入口：如同C语言的入口是main函数，在run时，程序从main开始执行，makefile文件中的程序也
有入口，当在终端下执行make命令时，系统会在当前目录下查找名字为Makefile的文件，然后从入口处开始解析规则，满足
规则触发条件的规则，其下面的命令会得到执行，那么，Makefile中的入口是什么呢？应该是该Makefile中，从上到下，
第一个出现的规则，也称其做默认规则，第一个规则无论如何都会被make执行，即使它是一个伪目标
所以，一个Makefile中第一个出现的规则是至关重要的，一般情况下，该规则中的目标应当是终极目标，其他规则的目标
均是从该规则的依赖文件中繁衍出去，一般而言，我们习惯用一个伪目标all来作为第一规则

>>伪目标：只是一个标识，一般没有依赖，一般被外部调用，伪目标规则被执行时，不会生成目标文件

>>可以将一个较长行使用反斜线(\)来分解为多行,但需要注意:反斜线之后不能有空格

>>规则的目标如果是文件：在执行make时，依照规则的触发条件，该文件会被重新生成

>>规则的命令，所完成的工作主要是如何根据依赖文件来更新目标文件，当然了，一些规则是可以没有命令行的，如利用隐式规则，
还有，伪目标规则的命令的作用并非如此

>>make会将所有出现在第一条规则之后，所有以TAB开始的行当做命令行来处理

>> %.o: %.c 我们称这样的写法为“匹配”，既然是匹配，两个%自然要告知一个(niutou.o和mazui.c凑到一起是牛头不对马嘴)，
如果告知了%.o中的%是stm32f7xx,立即就知道%.c应当匹配到stm32f7xx.c,这才对嘛，既然%.c是依赖，那么，就可以根据
vpath到当前目录下找具体的stm32f7xx.c这个文件了，所以呢，目标%.o一般是需要明确在Makefile中使用变量告知的
Blog creation time:[2017-09-02 六 10:12]


** DONE [#D] theme:专题2:linux开发stm32之Makefile			:@Blog:@Makefile:
   - State "DONE"       from "TODO"       [2017-09-04 一 23:00]
*** 声明
>>规则 = 目标： 依赖
         <回车>命令
备注：研究makefile实际就是研究：规则，目标，依赖，命令四者之间的关系

>>$@:目标文件集；$<依赖文件集，这两个变量都是最常用的自动化变量，有它两的地方，基本上
都少不了有模式匹配：%

>>Makefile 中的第一个目标会被作为其默认目标,默认目标的特性是，总是会被执行，即使它是
一个伪目标（大家都知道，伪目标只能外部调用，但是如果伪目标放在Makefile中的第一个位置，
成了默认目标，那么它就会被自动执行）

>>理论上，一个Makefile只会有一个终极目标，该目标会依据依赖关系派生出其他目标，但是，有
all的情况是个特例

>>伪目标的特性：伪目标做为标签，在被执行之后不会生成文件，结合Makefile 中的第一个
目标的特性：总是会被执行。结合这两个特性，能够产生一个十分不错且常规的
功能：一口气生成多个目标
*** 目录搜索：VPATH和vpath：
>>工程由文件组成，文件有不同种类(源代码.c,汇编.S,头文件.h,目标文件.o,二进制
文件.hex),文件还被组织在不同的目录中，这些不同目录中不同种类的文件正是构成Makefile
规则中的基本操作对象

>>Makefile中的规则在执行过程中，会根据依赖文件和目标文件的时间戳的新旧关系来决定是否
要执行当前目标下的命令，然而，这里有一个问题，Makefilez自己是不能知道依赖文件和目标文件
的路径的，需要用户告诉它，它才能自动去推导

>>使用VPATH和vpath正是这么一个告诉Makefile目标文件和依赖文件路径的操作，注意我的措辞，
VPATH和vpath指明的是“目标文件”和“依赖文件”的搜索路径，所以，“命令”中，需要单独使用-I
来指明头文件路径

>>VPATH是一个特殊变量，作为变量，它自然可以有值，VPATH的赋值方式为：VPATH = dir1 dir2 ...
即，VPATH的值是目录，指明该变量的值以后，Makefile在执行时，会首先在该Makefile文件所在的
当前目录下搜索涉及的目标文件和依赖文件，如果找不到，就会到VPATH所指明的dir1下面搜索，如果
找不到，就到dir2目录下找如果始终没找到，就会报错！

>>vpath是一个关键字，它的用法是：vpath %.c dir1 dir2,其工作的步骤是，首先在该Makefile
文件所在的当前目录下搜索符合模式%.c的文件，如果找不到，就会到vpath所指明的dir1下面搜索，
如果找不到，就到dir2目录下找如果始终没找到，就会报错！
*** 伪目标
>>伪目标不是一个文件，而是一个标签，所以伪目标在被执行之后不会生成文件

>>伪目标的取名不能和文件名重名

>>请使用一个特殊的标记“.PHONY”来显式地指明一个目标是“伪目标”

>>伪目标只能通过外部显示的调用

>>伪目标一般没有依赖文件，但是也可以为伪目标指明依赖文件，比较特殊且常用的一个具有
依赖文件的伪目标是all,它有着大作用！

>>伪目标的三大运用：
(1)一口气生成多个目标
.PHONY: all
all: prog1 prog2 prog3

prog1: prog1.o utils.o
	cc -o prog1 prog1.o utils.o
prog2: prog2.o
	cc -o prog2 prog2.o
prog3: prog3.o sort.o utils.o
	cc -o prog3 prog3.o sort.o utils.o
原理：
--伪目标是一个标签而不是一个文件，一般只能由外部调用
--Makefile的第一个目标(默认目标)一定会被执行
--一般情况下，一个Makefile只会有一个终极目标，该目标会依据依赖关系派生出其他目标，所以，
可以称该终极目标为Makefile的“入口”，即，一个Makefile一般有一个“入口”
--过程：伪目标all放在了Makefile的第一个目标出，必然被执行，然而执行的结果却不产生目标文件
所以，其依赖项必然会被决议（prog1 prog2 prog3均被当做“入口”），也就达到了一口气生成多个
目标的目的

(2)install:

(3)清楚目标，以便重新编译
.PHONY: clean
clean:
	rm -f *.o
备注：既然我们生成了许多文件编译文件,那也应该提供一个清除它们的“目标”以备完整地重编译而用

(4)让伪目标带有依赖文件的妙用：
.PHONY: cleanall 
cleanall: cleanobj cleandiff
	rm program
.PHONY: cleanobj 
cleanobj:
	rm *.o
.PHONY: cleandiff
cleandiff:
	rm *.diff
--前面说过，伪目标一般是不带依赖文件的，但是有时候带上依赖文件却时有大作用
--从第一个例子得出结论，目标可以成为依赖，所以，伪目标也可以成为依赖
原理：伪目标不能生成文件，外部调用cleanall时，会引起决议，伪目标后面带的依赖文件均会被
作为入口，并发执行这些“入口”，所以，调用cleanall的结果是执行rm program，然后是rm *.o  
最后是rm *.diff
*** 自动变量
>>$@:在具有模式规则(%.c)的条件下，表示规符合匹配要求的目标文件集合；而在普通情况下，
表示目标文件集合

>>$<:在具有模式规则(%.c)的条件下，表示符合匹配要求的依赖文件集合；而在普通情况下，
表示依赖文件集合中的第一个依赖文件

>>$^:只在普通情况下使用，表示规则中所有的依赖文件的集合，以空格分隔，如果在依赖
文件中有多个重复的,那个这个变量会去除重复的依赖文件,只保留一份

>>$+:只在普通情况下使用，同$^作用相同,区别在于，如果在依赖文件中有多个重复的,
它不去除重复的依赖目标

>>$?:只在普通情况下使用，表示规则中所有比目标文件新的依赖文件的集合，以空格分隔。
当你希望只对更新过的依赖文件进行操作时,“$?”在显式规则中很有用

>>$*:在模式匹配中，$*表示%及其之前的部分，例如，目标的模式匹配为a.%.b,且目标是
dir/a.foo.b,那么$*就是dir/a.foo,这个变量对于构造有关联的文件名是比较有用，
如果目标中没有模式的定义,那么“$*”也就不能被推导出
*** 模型推导
**** 基础版本：
edit: main.o kbd.o command.o display.o insert.o search.o files.o utils.o
	cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit $(objects)
**** 改良版一：使用变量
objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o

edit: $(objects)
	cc -o edit $(objects)
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit $(objects)
**** 改良版二：自动推导
GNU 的 make 很强大,它可以自动推导文件以及文件依赖关系后面的命令，只要 make 看到
一个.o 文件,它就会自动的把.c 文件加在依赖关系中,如果 make 找到一个 whatever.o,
那么 whatever.c,就会是 whatever.o 的依赖文件。并且 cc -c whatever.c也会被推导
出来,于是,我们的 makefile 再也不用写得这么复杂。我们的新 makefile 又出炉了

objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o

edit: $(objects)
	cc -o edit $(objects)
main.o: defs.h
kbd.o: defs.h command.h
command.o: defs.h command.h
display.o: defs.h buffer.h
insert.o: defs.h buffer.h
search.o: defs.h buffer.h
files.o: defs.h buffer.h command.h
utils.o: defs.h
.PHONY : clean
clean:
	rm edit $(objects)
备注：这里的自动推导实际上是利用了make的隐式规则，make 和我们约定好了：
第一：只要 make 看到一个.o 文件,它就会自动的把.c 文件加在依赖关系中
第二：用 C 编译器“cc”编译.c：$(CC) –c $(CPPFLAGS) $(CFLAGS)
总结：隐式规则使得我们可以做出以上简化而实际效果是同基础范式一样的
**** 改良版三：使用多目标规则
objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o

edit: $(objects)
	cc -o edit $(objects)
$(objects): defs.h
kbd.o command.o files.o: command.h
display.o insert.o search.o files.o: buffer.h
.PHONY: clean
clean:
	rm edit $(objects)
备注：该模式的与静态模式有莫大的渊源，应当弄清楚二者的区别与联系
**** 改良版三(终极版)：使用静态模式
objects = foo.o bar.o
all: $(objects)
$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@

通俗理解：从$(objects)中匹配出%.o的文件，然后%.o和%.c互相匹配，从而构造出符合匹配模型
的规则，上面的例子按照其含义可推导如下：
foo.o bar.o： foo.c bar.c
	$(CC) -c $(CFLAGS) $< -o $@
其中：-c和-o同时出现的情况，表示-c(编译)为-o所指出的文件名而不是按照默认方式
上面的规则继续分解：
foo.o: foo.c
	 $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o: bar.c
	 $(CC) -c $(CFLAGS) bar.c -o bar.o

特别地：
%.o: %.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
表示将所有的%.c挨个取出来编译(-c),编译后的目标命名(-o)为%.o
**** 简化终极版：自动生成依赖性
在Makefile中,我们的依赖关系可能会需要包含一系列的头文件，但是,如果是一个比较大型
的工程,你必需清楚哪些 C 文件包含了哪些头文件,并且,你在加入或删除头文件时,也需要小心地修改 
Makefile,这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情,我们可以使用 
C/C++ 编译的一个功能。大多数的 C/C++编译器都支持一个“-M”的选项,即自动找寻源文件中包含
的头文件,并生成一个依赖关系
*** 多目标以及多目标规则
>>一个规则中可以有多个目标,规则所定义的命令对所有的目标有效，多目标规则意味着所有的目标
具有相同的依赖文件
例如：test1.o test2.o test3.o: command.h
分析：根据模型推导中改良版二所述，该规则描述了但command.h的时间戳比test1.o test2.o 
test3.o中任意目标的时间戳新时，就会触发隐式命令$(CC) –c $(CPPFLAGS) $(CFLAGS) $@
所以，该语句的真实身份应该如下：
test1.o test2.o test3.o: test1.c test2.c test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) $@

>>一个具有多目标的规则相当于多个规则
分析：以上面的例子而言，该句的意思相当于：（应该是下面两种中的一种，具体是哪种，需要测试）
test1.o: test1.c test2.c test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test1.c -Ixx
test2.o: test1.c test2.c test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test2.c -Ixx
test3.o: test1.c test2.c test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test3.c -Ixx
---------------------
test1.o: test1.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test1.c -Ixx
test2.o: test2.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test2.c -Ixx
test3.o: test3.c command.h
	$(CC) –c $(CPPFLAGS) $(CFLAGS) test3.c -Ixx

其中：-Ixx是command.h的路径
备注：所有依赖文件将会被合并成此目标一个依赖文件列表,当其中任何一个依赖文件比目标新时，
命令都会被执行，所以，对于test1.o test2.o test3.o: command.h不难得出结论：
当依赖列表(test1.c test2.c test3.c command.h)中任意一个文件的时间戳比目标列表
(test1.o test2.o test3.o)中的某个，某两个，某三个新时，那么，test1.o test2.o test3.o
各自对应的命令就会得到执行

>>规则的命令对不同的目标的执行效果不同,因为在规则的命令中可能使用了自动环变量“$@”，
而且多目标规则确实也少不了$@,但是，多目标的规则并不能做到根据目标文件自动改变依赖文件(像
上边例子中使用自动化变量“$@”改变规则的命令一样)。需要实现这个目的是,要用到make的静态模式
通俗理解：多目标规则依托自动变量$@，能够根据目标，自动改变命令，但是，不能根据目标，自动
改变依赖，后者的实现可通过静态模式

>>一个仅仅描述依赖关系的述规则可用来给出一个或做多个目标文件的依赖文件:
分析：Makefile 中通常存在一个变量,就像以前我们提到的“objects”,它定义为所有的
需要编译生成的.o 文件的列表。当这些.o 文件在其源文件及其所包含的头文件“config.h”
发生变化之后能够自动的被重建,我们可以使用多目标的方式来书写 Makefile:
objects = foo.o bar.o
foo.o: defs.h
bar.o: defs.h test.h
$(objects): config.h
这样做的好处是:我们可以在源文件增加或者删除了包含的头文件以后不用修改已经存
在的Makefile的规则,只需要增加或者删除某一个.o文件依赖的头文件（如bar.o: defs.h test.h）
中的test.h,当然，头文件的依赖描述也可以使用自动生成依赖性章节所描述的方法产生！

>>多目标，很简单也很方便，对于一个大的工程来说,这样做的好处是显而易见的，在一个大的工程中,
对于一个单独目录下的.o文件的依赖规则建议使用此方式。（我感觉，还有更好的方案？？）
规则中头文件的依赖描述规则也可以使用gcc自动产生。可参考 4.14 自动产生依赖 一节
*** 静态模式
>>静态模式的规则:存在多个目标,并且不同的目标可以根据目标文件的名字来自动构造出依赖文件

>>例子：
objects = foo.o bar.o
all: $(objects)
$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@
通俗理解：从$(objects)中匹配出%.o的文件，然后%.o和%.c互相匹配，从而构造出符合匹配模型
的规则，上面的例子按照其含义可推导如下：
foo.o bar.o： foo.c bar.c
	$(CC) -c $(CFLAGS) $< -o $@
其中：-c和-o同时出现的情况，表示-c(编译)为-o所指出的文件名而不是按照默认方式
上面的规则继续分解：
foo.o: foo.c
	 $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o: bar.c
	 $(CC) -c $(CFLAGS) bar.c -o bar.o

静态模式规则比多目标规则更通用,它不需要多个
目标具有相同的依赖。但是静态模式规则中的依赖文件必须是相类似的而不是完全相同
的
*** 自动生成依赖性
>>目的：在Makefile中,我们的依赖关系可能会需要包含一系列的头文件，但是,如果是一个比较大型
的工程,你必需清楚哪些 C 文件包含了哪些头文件,并且,你在加入或删除头文件时,也需要小心地修改 
Makefile,这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情,我们可以使用 
C/C++ 编译的一个功能。大多数的 C/C++编译器都支持一个“-M”的选项,即自动找寻源文件中包含
的头文件,并生成一个依赖关系

>>基本使用：gcc -M main.c,其输出结果是：
main.o: main.c def.h 
备注：GNU 的 C/C++ 编译器,你得用“-MM”参数,不然,“-M”参数会把一些标准库的头文件也包含进来

>>如此一来，由编译器自动生成的依赖关系,这样一来,你就不必再手动书写若干文件的依赖关系,
而由编译器自动生成了

>>那么，编译器的这个功能如何与我们的 Makefile 联系在一起呢？GNU 组织建议,为每一个源文件
产生一个描述其依赖关系的makefile文件,即，编译器为每一个NAME.c的源文件都生成一个
NAME.d的Makefile文件作为中间文件，NAME.d中描述了文件NAME.o所要依赖的所有文件
备注：每一个源文件(xxx.c xxx.S)都对应一个中间文件(xxx.d xxx.d)

>>这样做的目的是：采用这种方式,只有源文件在修改之后才会重新使用命令生成新的依赖关系描述
文件NAME.o,通俗理解:xxx.c的内容发生改变后(去掉yy.h)，使用make命令编译，如果Makefile
中有下面的语句，那么，xxx.d中会重新生成新的依赖(xxx.o: xxx.c),即，去掉yy.h

>>规则：该模式规则用来自动生成每一个NAME.c文件对应的NAME.d 文件:
%.d: %.c
	$(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$
含义：指定所有的.d 文件依赖于同名的.c 文件
理解：第一行，使用 c 编译器自动生成依赖文件($<)的头文件的依赖关系,并输出成为一个临时文件,
“$$$$”表示当前进程号，注意，如果$(CC)为 GNU 的 c 编译工具，-M产生的依赖头文件除了用户
定义的头文件之外还有系统头文件，如果不想包含系统头文件，使用-MM。所以，第一行执行完毕后，
应当产生了NAME.c的临时Makefile文件，NAME.d，并且里面有依赖关系：NAME.o: NAME.c xxx.h 
注意，这个依赖关系存在于NAME.d这个Makefile文件下

第二行，处理NAME.d中的NAME.o: NAME.c xxx.h，生成多规则目标的形式：
NAME.o NAME.d: NAME.c xxx.h,这样就将NAME.d 加入到了规则的目标中,根据多规则目标的知识，
当NAME.c xxx.h的时间戳比NAME.o NAME.d新时，命令会被重新执行，NAME.o NAME.d都会被重新
生成

第三行，删除临时文件NAME.d

>>使用上例的规则就可以建立一个描述目标文件依赖关系的.d文件。我们可以在Makefile中使用
include指示符将描述将这个文件包含进来。在执行make时,Makefile所包含的所有.d文件就会被
自动创建或者更新,具体过程可参考 3.7 makefile文件的重建一节
*** 隐式规则	
Blog creation time:[2017-08-29 二 08:00]
** DONE [#D] theme:makefile中vpath，规则中依赖部分.h，规则中recipe的命令中-I参数三者关系的认识 :@Blog:@Makefile:
	- State "DONE"       from "TODO"       [2017-09-04 一 23:00]
	今天分析Makefile过程中，研究了关于头文件依赖问题，有以下认识：
--vpath是一个关键字，定义了一组规则的依赖部分查找的路径，比如：
vpath %.c CORE/src USER/src
vpath %.h CORE/inc USER/inc
	我们不禁会问，这个vpath给出的路径究竟有什么用，正如其定义的意义所言，用于规则的依赖文件
的查找，当编译器分析到一组规则时，总会拿依赖文件和目标文件的时间戳做比较，来决定是否执行
recip命令，比较的前提自然是先找到依赖文件：
（1）首先会在当前路径下查找，找不到的话
（2）到vpath指定的路径下查找找不到的话
（3）分析Makefile中其他规则是否有生成该依赖，都没有的话就会报错
显然，这个vpath的用途自然在于编译源文件的规则中，因为其他规则如链接，都会走（3）的路线

--规则中依赖文件中.h又该怎样理解呢，它和vpath有什么关系？
	既然它在该规则中依赖文件的位置，说明该规则的目标受到它的制约，这种制约一般是该规则的
目标（源文件）中引入了该头文件，所以该头文件发生变化，该目标会重新编译生成。既然说了该.h
文件是依赖文件，那么，也就可以通过vpath的%.h路径来寻找，所以，在Makefile中如果定义了
vpath %.h，那么在规则的依赖中.h相关的只用写出它的文件名加.h后缀即可，不用标明全路径，
该规则会根据vpath去%.h路径下查找：%o: %c main.h
	注意，有了vpath,我们的依赖中，只用使用%.c来表示依赖文件即可（比如/USER/src/main.c）,
因为程序会到vpath路径下匹配所有.c结尾的文件放到此处。但是，注意了，亲测，%.h,不可以这么干，
好像理论上可以，这么干的朋友应该是这么思考的：“每个.c文件的头文件依赖多个.h,要时刻关注
这个.c文件和其依赖的.h文件，并在适当时候在Makefile中做出增减，这是很烦人的事情，不如让
每个.c都依赖与所有的.h吧，于是写出了%.o: %.c %.h"这样的语法”，这中做法是非常不高效的，
我猜测，现在的编译器不允许这么干了， 一种好的方法是自动生成依赖关系技术（利用-MM）,详情见
Makefile中文手册

--规则中，命令部分的-I又干了什么，这里说的规则自然就是编译生成目标的那条规则啦，-I的
作用的在gcc -c的时候告诉编译器如果.c中出现了#include <xxx.h>,应该去-I指出的路径下
查找。注意了-I指出的头文件路径和vpath以及依赖处的.h是没有太大关系的

结论：
	一个Makefile中，应该使用自动依赖生成技术来解决头文件的依赖关系，所以呢，vpath中
%.h应该是没有什么必要了
Blog creation time:[2017-08-31 四 15:36]
** DONE [#D] theme:makefile语法规则							:@Blog:@Makefile:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:30]
用户自定义的隐含规则称模式规则，这些规则建议放到一个叫做BIN/rule.mk的Makefile文件中去，
其他makefile使用include包含进来，应该是include而不是make -C rule.mk,所以，rule.mk
就相当于各个makefile文件公共文件，有点公共函数的意思，被调用 

重新认识一下makefile中模式规则的原理以及如何被使用，模式规则就是用户定义出来，告诉
make,遇到符合自己定义的模式规则模型的，就套用该模型，并调用其下面的命令

Blog creation time:[2017-09-05 二 08:38]
** DONE [#D] theme:linux-kernel 的makefile架构解析			:@Blog:@Makefile:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:40]
**** 基本框架：
-- 内核makefile.txt中将makefile分为5部分：Kernel Makefile、ARCH Makefile、KBuild Makefile、.config文件以及scripts/Makefile.*

--kbuild将所有与编译过程相关的共用规则和变量都提取到scripts 目录下的Makefile.build中,具体的子目录下的 Makefile 文件则可以编写的非常简单与直接

--用 obj-* 连接的Objects 在指明的文件夹中被用作模块或者综合进built-in.o，也有可能被列出的objects 将会被包含进一个库,lib.a

--所有用lib-y 列出的objects 在那个文件夹中被综合进单独的一个库

--列在obj-y 且 附加列在lib-y 中的Objects 将不会被包含在库中

--对于被连接在lib-m 中，连续的objects 将会被包含在lib.a 中

--kbuild makefile 可能列出文件用作built-in ，并且作为库的一部分。因此，同一个文件夹可能包含一个built-in.o 和lib.a 文件  

--lib-y 的使用方法通常被限制在lib/ 和arc/*/lib 中
**** Makefile
--路径：位于linux kernel源码的顶层目录，该Makefile也就是顶层Makefile

--顶层的Makefile也叫做Kernel Makefile

--顶层Makefile文件负责产生两个主要的程序：vmlinux (内核image)和模块

--主要用于指定编译Linux Kernel 目标文件（vmlinux ）和模块（module ）路径

--顶层Makefile文件根据内核配置，通过递归编译内核代码树子目录建立这两个文件。

--顶层Makefile文件文本一个名为 arch/$(ARCH)/Makefile的机器体系Makefile文件。

--机器体系Makefile文件为顶层Makefile文件提供与机器相关的信息。

--根据.config文件决定了内核根目录下那些文件、子目录被编译进内核
**** ARCH/$(ARCH)/Makefile 
--系统对应平台的Makefile

--Makefile 会包含这个文件来指定平台相关信息

--根据.config文件，决定了ARCH/$(ARCH) 目录下 那些文件、子目录被编译进内核
**** scripts/Makefile.build: 
--被顶层Makefile所调用

--与各级子目录的Makefile合起来构成一个完整的Makefile文件，定义built-in.o、.lib以及目标文件.o的生成规则

--这个Makefile文件生成了子目录的.lib、built-in.o以及目标文件.o

**** scripts/Kbuild.include:
--被Makefile.build所调用

--定义了一些函数，如if_changed、if_changed_rule、echo-cmd
**** scripts/Makefile.clean
--被顶层Makefile所调用

--用来删除目标文件等
**** scripts/Makefile.lib
--被Makefile.build所调用
--主要是对一些变量的处理，比如说在obj-y前边加上obj目录
**** .config
--位于linux内核的根目录下

--产生自来自配置过程

--被顶层的Makefile包含

--配置过程产生.config文件

--.config又产生auto.conf以及autoconf.h文件
**** KBuild Makefile
--从Linux 内核2.6 开始，Linux 内核的编译采用Kbuild 系统 

--大多的Kbuild 文件的名字都是Makefile 。为了与其他Makefile 文件相区别，你也可以指定Kbuild Makefile 的名字为 Kbuild

--如果“Makefile ”和“Kbuild ”文件同时存在，则Kbuild 系统会使用“Kbuild ”文件,linux内核中,Kbuild Makefile 就是各个子目录的Makefile 

--Kbuild 系统使用Kbuild Makefile 来编译内核或模块

--每个子目录下都有一个KBuild Makefile，作用就是 指定当前目录下的文件，哪些被编译进当前目录的built-in.o、那些被编译成模块、那些不编译

--当顶层 Makefile 被解析完成后，Kbuild 会读取相关的Kbuild Makefile 进行内核或模块的编译

--Kbuild Makefile 有特定的语法指定哪些编译进内核中、哪些编译为模块、及对应的源文件是什么

--Kbuild Makefile 的一个最主要功能就是指定编译什么，这个功能是通过下面两个对象指定的obj-? 和xxx-objs  
例1：
     obj-y += foo.o 
     obj-m += abc.o 
实际：obj-$(CONFIG_DM9000) += dm9000.o，CONFIG_DM9000 是y 还是m取决于配置过程

例2：
	如果内核模块是通过几个源文件编译而成的，此时Kbuild需要知道编译模块时是基于哪些目标文件的,因此需要设置一个$(<module_name>-objs)变量来告诉编译器
    obj-$(CONFIG_ISDN) += isdn.o
    isdn-objs := isdn_net_lib.o isdn_v110.o isdn_common.o
由于obj-$(CONFIG_ISDN)是由isdn_net_lib.o isdn_v110.o isdn_common.o这三个目标文件编译而成的，所以，需要定义isdn-objs

**** scripts/kconfig/Makefile
--顶层Makefile调用： include scripts/kconfig/Makefile ，用于指定目标

--顶层Makefile调用： include scripts/kconfig/Makefile ，生成auto.conf autoconf.h auto.conf.cmd
**** .config文件
.config文件在进行内核编译时（make uImage）生成了include/config/auto.conf和include/linux/autoconf.h
Linux的内核配置，就是为了生成.config文件。因为在编译时需要用.config文件生成其他相关配置文件。我们的配置项大多是例如CONFIG_XXXDRIVER，这里的XXXDRIVER指的是各种驱动。我们需要告诉内核，这些驱动是编译进内核，还是编译成模块。通过查找CONFIG_XXXDRIVER，我们可以发现，它出现在四个地方：

　　1>C源代码

　　2>子目录Makefile:drivers/XXX/Makefile

　　3>include/config/auto.conf

　　4>include/linux/autoconf.h
里首先说明：.config文件在进行内核编译时（make uImage）生成了include/config/auto.conf和include/linux/autoconf.h。
通过查看C源代码我们发现CONFIG_XXXDRIVER是一个宏定义，等于一个常量。在include/linux/autoconf.h中宏定义CONFIG_XXXDRIVER为一个常量，可能是0或1。
那么现在有一个问题，就是CONFIG_XXXDRIVER到底被编译进内核还是编译成一个模块呢？这在C语言中是无法进行区分的，这种区分体现在哪里呢？这种区分体现在子目录的Makefile文件中。
在子目录的Makefile中，若有 obj -y += XXX.o则表示XXX.c被编译进内核；obj -m +=XXX.o则表示XXX被编译成模块，为XXX.ko。include/config/auto.conf文件则是对CONFIG_XXXDRIVER进行赋值，
为y时表示编译进内核，为m时表示编译成独立模块

--在Linux内核里，每个子目录都有一个makefile，它被称作Kbuilt-makefile，它将当前目录的文件编译成built-in.o、以及库文件、模块文件。
然后顶层Makefile里指定这些built-in.o的路径，将它们连接在一起

--通过内核配置操作产生.config文件，顶层Makefile文件读取该文件的配置。

Blog creation time:[2017-09-04 一 15:17]

*** 入口：
1.顶层Makefile---- 指定目标-----include scripts/kconfig/Makefile
如在终端中执行配置命令make nitrogen6x_defconfig
%config: scripts_basic outputmakefile FORCE
    $(Q)mkdir -p include/linux include/config
    $(Q)$(MAKE)$(build)=scripts/kconfig $@

2.auto.conf autoconf.h auto.conf.cmd的生成----指定目标-----include scripts/kconfig/Makefile
include/config/%.conf:$(KCONFIG_CONFIG)include/config/auto.conf.cmd
    $(Q)$(MAKE)-f$(srctree)/Makefile silentoldconfig

将在顶层Makefile中递归到上述1中的%config规则，所以，其最终还会包含scripts/kconfig/Makefile

3. 目标编译和链接----不指定目标-----include 各个build目标下的Makefile
$(vmlinux-dirs): prepare scripts
        $(Q)$(MAKE) $(build)=$@

4. 模块----模块建构中单独讨论
$(module-dirs):crmodverdir$(objtree)/Module.symvers
    $(Q)$(MAKE)$(build)=$(patsubst _module_%,%,$@)

modules:$(module-dirs)
    @$(kecho)'  Building modules, stage 2.';
    $(Q)$(MAKE)-f$(srctree)/scripts/Makefile.modpost

5. 单目标----不指定目标
%.o:%.c prepare scripts FORCE
    $(Q)$(MAKE)$(build)=$(build-dir)$(target-dir)$(notdir $@)

6. 子目录递归----不指定目标-----include递归的子目录下Makefile
scripts/Makefile.build
$(subdir-ym):
    $(Q)$(MAKE)$(build)=$@
*** 暂存
--

*** 基本流程
--在scripts/Kbuild.include中有一条规则：build := -f $(srctree)/scripts/Makefile.build obj

--在scripts/Makefile.build中：

*** 内核makefile源码分析
**** 顶层makefile
***** make参数信息:MAKEFLAGS
MAKEFLAGS += -rR --include-dir=$(CURDIR)
****** 分析
(1) MAKEFLAGS：
--该变量是一个系统级别的环境变量，包含了 make 的参数信息;
--这个变量不管你是否export,其总是要传递到下层 Makefile 中;
--如果我们在命令行使用make执行“总控 Makefile”时有 make参数,或是在上层 Makefile 中定义了这个变量,
那么MAKEFILES 变量将会是这些参数,并会传递到下层 Makefile 中
--但是 make 命令中的有几个参数并不往下传递,它们是“-C”,“-f”,“-h”“-o”和“-W”

(2) -r：
--取消所有内嵌的隐含规则
--但是，仍然可以在Makefile中使用模式规则来定义你自己的隐含规则
--同时，还会取消所有支持后追规则的隐含后缀列表
--但是，可以在Makefile中使用“.SUFFIXES”定义我们自己的后缀规则

(3) -R:
--取消 make 内嵌的隐含变量
--不过我们可以在 Makefile 中明确定义某些变量

(4) --include-dir=$(CURDIR)
--该参数指定包含makefile文件的搜索目录(也就是下面的filename的路径)
--include filename: filename 是 shell 所支持的文件名(可以使用通配符),一般是makefile文件，在自动依赖关系技术中，也用来包含.d文件
--如果filename的内容是空的，那么相当于什么事也没有做，继续执行当前Makefile之后的内容（不报错）
--在Makefile中出现“include”另外一个文件时，首先在当前目录下搜索，找不到的话将会在include-dir指定的目录下搜索，
找不到的话去/usr/gnu/include,或者/usr/local/include, /usr/include这几个目录下找，
还是找不到的话make将会提示一个包含文件未找到的告警提示,但是不会立刻退出，而是继续处理Makefile的后续内容，
当完成读取整个Makefile后,make将试图使用规则来创建通过指示符“include”指定的但未找到的文件
--在搜索include-dir指定的目录时，按照指定顺序进行
--include”指示符告诉 make 暂停读取当前的 Makefile,而转去读取“include”指定的一个或者多个文件，完成以后再继续当前 Makefile 的读取
--指示符“include”和文件名之间、多个文件之间使用空格隔开，行尾的空白字符在处理时被忽略

(5) CURDIR
--此变量代表 make 的工作目录
--当使用“-C”选项进入一个子目录后,此变量将被重新赋值
--总之,如果在Makefile 中没有对此变量进行显式的赋值操作,那么它代表 make 的工作目录
--我们也可以在 Makefile 为这个变量赋一个新的值,此时这变量将不再代表 make 的工作目录

总结：该语句为存储make参数的专用系统环境变量MAKEFLAGS，追加了三个参数，不论用户传递任何参数进来，这三个参数都将作为MAKEFLAGS
里面默许的，这三个参数宏观上取消了内嵌的隐含规则和隐含变量，使得编译器不能干涉用户的配置，然后指出Makefile文件的搜索路径，这一点
在make -C $(subdir)时尤其重要，有了--include-dir=$(CURDIR)，用户不用再考虑编译器怎样寻找子目录下的Makefile文件的问题
***** 从命令行传递参数
ifeq ("$(origin V)", "command line")
  KBUILD_VERBOSE = $(V)
endif
****** 分析
(1) V:一个来源尚不明确的变量

(2) $(origin V): 函数，返回这个变量的来源，变量有以下几种来源：
--undefined： 没定义
--default： V是内嵌变量，比如CC,MAKE之类的变量就是内嵌变量，不过一般情况下我们会取消隐含变量
--environment： 变量V是一个系统环境变量,并且make没有使用命令行选项“-e”(Makefile中不存在同名的变量定义,此变量没有被替代)
--environment override： 变量V是一个系统环境变量,并且make使用了命令行选项“-e”(Makefile中存在一个同名的变量定义,使用“make -e”时
环境变量值替代了文件中的变量定义)
--file: 变量V在某一个的makefile文件中定义
--command line：变量V在命令行中定义，比如：make V=1
--override: 变量V在某一个在makefile文件中定义并使用“override”指示符声明
--automatic： 变量V是一个自动化变量

(3) ifeq ("$(origin V)", "command line")
           xxx
    endif
--此关键字用来判断参数是否相等,如果相等，则执行xxx
--通常我们会使用它来判断一个变量的值是否为空(不是任何字符)
--参数值可能是通过引用变量或者函数得到的,因而在展开过程中可能造成参数值中包含空字符(空格等)，
一般在这种情况时我们使用make的“strip”函数来去除空字符
***** 从MAKEFLAGS中找出
ifneq ($(findstring s,$(filter-out --%,$(MAKEFLAGS))),)
  quiet=silent_
  tools_silent=s
endif
****** 分析
--首先过滤掉MAKEFLAGS中所有以--打头的单词(夹在两个空格之间的串称为一个单词，比如--include-dir就是一个单词)
--在剩下的集合中再去查找含有字符s的单词，找到则返回字符s，找不到则返回空字符。(make -s时，-s中有s，所以返回s)
--该语句的意思是，过滤掉MAKEFLAGS中以--打头的参数之后，查找MAKEFLAGS中有没有-s参数
--选项-s解析
1）该选项是--silent和--quiet的组合，其作用是：取消命令执行过程的打印，同时还禁止所有规则的命令的回显
2）说到执行过程的打印，就得聊一下-w参数，见下面
3）说到规则命令的回显，就得聊一下make执行命令之前所做的那些事

make在执行规则的命令之前会做什么？
1）会把要执行的命令行输出到标准输出设备，我们称之为“回显”，注意回显的是规则中的命令的原型
2）如果规则的命令行以字符“@”开始,则 make 在执行这个命令时就不会回显这个将要被执行的命令
3）使用了-s参数，相当于在规则的所有命令前面加上了@
备注：如果使用make的命令行参数“-n”或“--just-print”,那么make执行时只显示所要执行的命令,但不会真正的去执行这些命令，
这个选项对于我们调试Makefile非常有用,使用这个选项我们可以《按执行顺序》打印出Makefile中所有需要执行的所有命令

聊一聊-w:
1）该选项可以让 make 在开始编译一个目录之前和完成此目录的编译之后给出相应的提示信息，如
在目录“/u/gnu/make”目录下执行“make -w”会有：make: Entering directory `/u/gnu/make'以及make: Leaving directory `/u/gnu/make'的提示
2）通常,选项“-w”会被自动打开。在主控Makefile中当如果使用“-C”参数来为make指定一个目录或者使用“cd”进入一个目录时,“-w”选项会被自动打开
3）那么，可以使用 -s 选项来禁止所有关于目录信息的打印
