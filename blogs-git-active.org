* blogs-git-active
** DONE [#D] theme:我的工具网站									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1. git 官方网站：http://git-scm.com
2. 廖雪锋：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
   Blog creation time:[2017-09-05 二 08:01]
** WAITTING [#D] Theme:基本概念								 :@Blog:@Git:
   SCHEDULED:<2017-09-23 六>
1. 工作区：一个等待进行版本控制的目标目录
2. 版本库：当使用git init对一个工作区进行初始化之后，在工作区下产生一个名为.git的文件夹，该文件夹就称为版本库
3. 正确使用版本控制系统的方法是：一次提交只完成一件事
   1. 或是完成一个新功能
   2. 或是修改一个bug
   3. 或是写完一节内容
   4. 或是添加一副图片
   5. 注意：不要在下班才想起进行一次提交，那样的话git就降格成文件备份系统了
4. 环节
   1. 工作区  ----(1)--->  暂存区
   2. 暂存区  ----(2)--->  分支
   3. 工作区  ----(3)--->  分支
   4. 暂存区  ----(4)--->  工作区
   5. 分支    ----(5)--->  暂存区
   6. 分支    ----(6)--->  工作区 　
   7. 研究清楚，标编号上面6个环节中：单个文件的传递，所有文件传递，的相关操作方法，git的知识点就全了
5. 版本库干净： 当工作区 = 暂存区 = 对象库（最新）提交 ===> 版本库干净（使用git status无任何状态）
6. 思维逻辑: 从树形结构看版本库
   1. 错误的思维: 开发从树的根部到枝干进行.你可能会在想创建分支的过程:
	  1. 开发成员1,以master分支上的第1次提交,作为branch1分支的分支起点,在该分支上产生若干提交,形成第一个分支
	  2. 开发成员2,以master分支上的第1次提交,作为branch2分支的分支起点,在该分支上产生若干提交,形成第二个分支
	  3. 开发成员3,以master分支上的第1次提交,作为branch3分支的分支起点,在该分支上产生若干提交,形成第三个分支
	  4. ......
	  5. 开发成员n,以master分支上的第1次提交,作为branchn分支的分支起点,在该分支上产生若干提交,形成第n个分支
	  6. 结论: 版本库是从根到枝干的开发! 但是,不好意思,这个结论是错的
   2. 正确的思维: 开发从树的枝干到根部进行
      1. 根,可以看做系统的输出,即最终版本,枝干可以看成系统的输入,即各个分支的提交,开发的目的是为了得到根
	  2. 其实上面错误思维里面的所谓的根只是一个"假根",通常master分支上的第一次提交只是一个工程项目的基础设施而已,而并非结果
	  3. 项目的发起者在master分支上提交了一次该项目的"基础设施",该提交只包含了一些必备的初始化,驱动等等,相当于kernal
	  4. 项目的参与者以master分支上的第一次提交为分支起点,创建只属于自己的分支,所以一开始,每个参与者获得相同的"原料"
	  5. 项目的发起者自己想要开发,也需要以master创建一个自己的分支,比如master-manager,只有它才有权限在master生成根
	  6. 每个参与者在自己的分支上做属于自己模块的开发,然后不断向master-manager分支合并,master-manger认为开发的差不多了,可以生成第二个版本(根)的 时候,他会向master合并
Blog creation time:[2017-09-23 六 22:36]
** WAITTING [#D] Theme:对象库解析 								 :@Blog:@Git:
   SCHEDULED:<2017-09-26 二>
1. index:
   1. 该文件是一个二进制文件,本质上，是一个包含文件索引的目录树
   2. 使用git add xx-file之后，xx-file这个文件的文件名将会挂接在index这个文件的目录树上
   3. 然而，xx-file这个文件的实际内容并没有存储在index这个文件中，而是存储在.git/objects目录这个对象库中
   4. index中xx-file这个文件的索引和对象库.git/objects中xx-file这个文件的实体建立起对应关系
   5. index的真实面目：所有加入版本库的文件形成目录树；目录树上挂接着接受版本控制的文件（其中，每个挂接的文件主要提供三部分信息：第一，该文件的文件名；第二，该文件的文件大小，第三，最近一次使用扫描工作区改动的命令(如git status,git diff等)时，所扫描到的文件的最新的时间戳）；目录树同对象库中相应的文件形成对应
2. objects/:
   1. 使用git add xx-file将xx-file文件加入到版本库之后，文件名，大小，时间戳等信息登记在index文件的目录树上，xx-file文件内部的真实内容则存储在.git/object/这个对象库中
   2. 对象库.git/object/中的文件同index中的目录树有着对应关系(我猜想，index中的目录树好比一个指针链表，每一个节点下存放指针类型的文件名，指向对象库中的对应文件)
3. branches/
4. HEAD
5. config
6. hooks/
7. info/
8. refs
9. packed-refs
10. description
11. logs/
12. 对象库解析
	1. 对象库.git/obj/ ： 直观图解参看《git权威指南p87》
	   1. 对象库的本质一个双向链表，当前分支(比如master)是该链表的头指针,HEAD则是指向头指针的指针
	   2. 该链表的结点是一个又一个的commit，当前分支(比如master)可以在这些commit结点前后来回移动
	   3. 结点的指针域的值是commit类型的ID，该双向链表的就是通过这些ID值组织起来的
	   4. 结点的数据域由三部分构成：tree类型的ID,parent类型的ID,用户标识
		  1. tree类型是一个结构体类型,其成员是blob类型的指针，blob类型可以理解为文件类型，所以这些blob类型的指针就指向真正的文件
		  2. 每个blob类型的文件均有一个ID
	2. 寻址ID：git cat-file -p ID
	   1. ID值总是一个指针类型，要么指向commit结点，要么指向tree类型的结构体，要么指向blob类型的文件
	   2. 我们总可以使用:git cat-file -p ID,来解析指针ID的值,取得该指针下的值
	   3. 常规步骤是先使用git lg查看commit类型的ID,然后通过该ID就能逐一解析出tree类型的ID以及blobn类型的ID
	3. 查看对象库中文件内容
	   1. 查看当前分支对应的提交内容：git cat-file commit HEAD
	   2. 查看指定分支(比如master)对应的提交: git cat-file commit master
	   3. 查看当前分支下某文件的内容: git cat-file blob HEAD:<TAB补全>
	   4. 查看指定分支(比如master)下某文件的内容： git cat-file blob master:<TAB补全>
	4. 获取ID类型：git cat-file -t ID
	   1. 从上面对象库的分析中可以知道，git提供了如下3种类型的ID，对于给定ID，使用git cat-file -t ID，来了解该ID的类型
	   2. commit: 使用git lg查看到的ID就是commit类型的ID
	   3. tree:  
	   4. blob:
	5. 获取,分支以及HEAD，的ID: git rev-parse master;  git rev_parse HEAD
	6. HEAD,master,^,~的关系
	   1. HEAD指向当前分支，所以，HEAD就理解为当前分支
	   2. 分支是对象库的头指针，所以分支指向对象库的最新提交
	   3. master属于分支，是分支里面比较特殊的一个分支，称为主分支
	   4. 当且仅当存在master分支时，HAED自然就指向master
	   5. HEAD～n,指向当前分支，最新提交的第n个父提交，HEAD~1 等价于 HEAD^
Blog creation time:[2017-09-26 二 08:42]
** DONE [#D] Theme:安装 										 :@Blog:@Git:
1. 检查是否安装：dpkg -s git
2. 安装： sudo apt-get install git
3. 查看版本： git --version
Blog creation time:[2017-09-05 二 08:03]
** DONE [#D] Theme:配置 										 :@Blog:@Git:
1. 本地配置：　git config -e
   1. 配置文件路径：workspace/.git/config
   2. 作用域：该文件下的配置，只在该workspace／中有效
   3. 优先级：最高
2. 全局配置：　git config --global -e
   1. 配置文件路径：　~/.gitconfig　
   2. 作用域：该文件下的配置，对当前用户的所有的版本库均有效
   3. 优先级：高于系统配置，低于全局配置
   4. 用户标识配置：git config --global user.name "linjiajun"
   5. 用户邮件配置：git config --global user.email "ytulinjiajun@163"
   6. 开启颜色显示：git config --global color.ui true
   7. 说明：用户标识和用户邮件必须进行配置，因为git会使用到这两个信息来标识提交者身份
3. 系统配置：　git config --system -e
   1. 配置文件路径：　/etc/gitconfig
   2. 作用域：该文件下的配置，对所有用户的所有版本库均有效
   3. 优先级：最低
   4. 配置别名：git config --system alias.sta status
4. 读取配置：　git config --global user.name 回车
5. 更改配置：　git config --system alias.co checkout
6. 删除配置：　git config --unset core.bare
7. 备注： 建议将配置文件上传到github,用到时直接clone到指定路径即可！
** DONE [#D] Theme:SSH											  :Blog:@Git:
1. 生成SSH秘钥： ssh-keygen -t rsa -C "ytulinjiajun@163.com"
   1. -t  用于指定加密类型，常见的有RSA和DSA加密方式，默认是DSA;
   2. -C 作为批注
   3. 三次回车，按默认路径.ssh以及不需要密码安装即可
2. 在Github上添加密钥： Account Setting -> SSH Key -> Add SSH Key
   复制~/.ssh/ssh-ras 的内容到 key 区域
3. 验证SSH配置是否成功： ssh -T git@github.com
   Hi username! You've successfully authenticated ,but GitHub does not provide shell access
5. 创建一个本地版本库： git init
6. 关联远程库： git rmt git@github.com:ytulinjiajun/GitHub-Lin.git
6. 从github克隆一个版本库验证SSH配置是否成功：git clone git@github.com:ytulinjiajun/GitHub-Lin.git
Blog creation time:[2017-09-05 二 08:04]
** WAITTING [#D] Theme:搭建git服务器							 :@Blog:@Git:
    SCHEDULED:<2017-10-09 一>
1. 必要性: 如果仅仅是自己一个人使用git开发,就不需要git服务器,但是,如果如果需要和他人分享代码,协作开发,或者为个人开发建立一个远程备份,则务必掌握git服务器的搭建
2. git服务器假设方案:
| item               | HTTP    | Git-daemon | SSH     | Gitolite/Gitosis |
|--------------------+---------+------------+---------+------------------|
| server             | simple  | middle     | simple  | compliex         |
| anonymous read     | support | support    | against | against          |
| Authentication     | support | against    | support | suppost          |
| repo write         | support | against    | support | support          |
| Authorization      | against | against    | against | against          |
| remote create repo | against | against    | against | support          |
|--------------------+---------+------------+---------+------------------|
3. 
Blog creation time:[2017-10-09 一 15:13]
** DONE [#D] Theme:创建版本库　									   :Blog:@Git:
1. git init: 其结果是在工作区中生成版本库：.git/
2. git rev-parse --git-dir: 该操作可以在工作区的任何子目录下执行，其结果是显示该工作区的版本库的路径
3. git rev-parse --show-toplevel: 该操作可以在工作区的任何子目录下执行，其结果是显示该版本控制系统的根路径
4. git rev_parse --show-prefix: 该操作可以在工作区的任何子目录下执行，其结果是显示相对于该版本控制系统的根路径的相对目录
5. git rev_parse --show-cdup: 该操作可以在工作区的任何子目录下执行，其结果是显示当前目录回退到版本控制系统根的深度
** DONE [#D] Theme:查看状态										 :@Blog:@Git:
    SCHEDULED:<2017-10-05 四>
	- State "DONE"       from "WAITTING"   [2017-10-05 四 21:45]
1. 常规：git status
2. 精简(推荐)：git status -sb
   1. 红色： 表示该文件需要执行add操作
   2. 绿色： 表示该文件已经执行过add操作，现在可以执行commit操作
   3. 空： 表示工作区干净
   4. ??：表示该文件是一个未被追踪的文件(只可能是红色)
   5. A： 表示该文件还从未进行过commit(只可能是绿色)
   6. M: 表该文件发生了修改(红色和绿色均可能)
   7. D: 表示该文件被删除(红色和绿色均可能)
3. 原则: 使用该操作,只要有输出, 那就表明工作区,暂存区,最新提交三者之间文件内容不一致
Blog creation time:[2017-10-05 四 21:41]
** WAITTING [#D] Theme:引用									 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
1. HEAD: 
2. master: .git/refs/heads/master
3. stash
4. tag-name: .git/refs/tags/tag-name 
Blog creation time:[2017-10-07 六 21:16]
** DONE [#D] Theme:里程碑										 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
1. 创建里程碑: git tag -m "注释" tag-name
   1. 创建里程碑操作会产生一个tag-commit-ID提交,并产生一个tag-name
   2. 创建里程碑后,tag-name指向一个tag-commit-ID对象,该tag-commit-ID指向对象库中的commit-ID
2. 对特定提交创建里程碑: git tag tag-name commit-ID
3. 查看tag的ID: git rev-parse tag-name
4. 显示版本号: git descrbie
   1. 前提: 执行过创建里程碑的操作
   2. 作用: 将最新的提交显示为一个容易记忆的版本号,而不是ID
   3. 版本号格式: (tag-name)-(num)-(ID)
   4. 该命令会去选取离最新提交最近的里程碑的tag-name作为基础版本号,后面加一个数字(标识该提交是里程碑后面的第几个提交),最后就是最新提交的哈希值ID
   5. 该操作的输出可以作为软件版本号,这个功能非常有用,因为这样可以将发布的软件包版本和版本库中的代码对应到一起,当发现软件包中有bug时,查看该软件包的版本,直接在代码中就能找到对应代码并进行修复,然后提交
   6. tag-name的命令: linux-kernel_1.0
5. 说明: 里程碑是个非常好的功能,建议经常使用它
Blog creation time:[2017-10-07 六 21:13]
** DONE [#D] Theme:浏览											 :@Blog:@Git:
   SCHEDULED:<2017-10-05 四>
1. 浏览文件内容
   1. 浏览工作区中的文件内容：　less a.txt
   2. 浏览暂存区中的文件内容：　git diff
   3. 浏览对象库中的文件内容：　git cat-file blob commit-ID:a.txt
2. 浏览目录树
   1. 浏览工作区中的目录树： ls -al
   2. 浏览暂存区中的目录树： git ls-files -s
	  第三列是暂存区编号不是文件大小
   3. 浏览指定提交的目录树： git ls-tree -lrt commit-ID
	  1. 第一列100644是文件的属性：rw-r--r--
	  2. 第二列标识文件还是目录：blob，文件，tree,目录
	  3. 第三列标识该文件在当前分支中的40为SHA1哈希值ID
	  4. 第四列是文件大小(Byte)
	  5. 第五列是文件名
3. 浏览对象库
   1. ID的类型: commit-ID,tree-ID,blob-ID
   2. ID的本质: 指针
   3. 对象库本质: 一个双向链表,其节点是提交, git lg 可以查看到这些节点的ID
   4. 版本库的构成: HEAD指针,分支指针头,对象库
   5. "提交节点"的成分: 前驱指针域(id),数据域(tree,author),后继指针域(parent)
   6. 数据域中的tree: tree是一个tree-ID,因此,是一个指针,这个tree指向一个目录树索引,该目录树索引和暂存区中的目录树索引经常发生交互,它们均指向add进对象库中真正的文件 
   7. 获取指定ID的类型：git cat-file -t ID, 其返回值是: commit,tree,blob
   8. 解引用commit-ID: git cat-file -p commit-ID
	  1. 使用 git lg 可以查看到对象库的所有commit-ID
	  2. 其效果与 git cat-file commit commit-ID一致
	  3. 解引用的结果: 得到"提交节点"的成分,包括tree-ID
   9. 解引用tree-ID: git cat-file -p tree-ID
	  1. 其效果与 git ls-tree -lrt commit-ID 一样
	  2. 解引用的结果: 可以查看对象库中commit-ID下数据域tree-ID指向的目录树下面的所有blob-ID
   10. 解引用blob-ID: git cat-file -p blob-ID
	   1. 其效果与 git cat-file blob commit-ID:<tab补全>一致
	   2. 解引用的结果: 可以查看tree-ID下面所有blob-ID指向的文件的真正内容
Blog creation time:[2017-10-05 四 21:46]
** DONE [#D] Theme:添加至暂存区									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:28]
1. 添加单个文件： git add a.txt
2. 添加所有文件： git add -A
3. 所有文件中，添加已经被跟踪过的文件： git add -u
4. 选择性添加: git add -i (当文件特别多,且需要仔细考虑添加哪些文件时,该操作以交互的方式,给出一个更直观的操作)
Blog creation time:[2017-10-06 五 10:26]
** DONE [#D] Theme:撤销出暂存区									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:30]
1. 撤销单个文件的add： git reset -- a.txt
2. 撤销所有文件的add: git reset -- .
3. 该操作是add的逆,所以，对暂存区和对象库无任何影响
Blog creation time:[2017-10-06 五 10:28]
** DONE [#D] Theme:提交											 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:46]
1. 命令： git commit -m "Initialized"
2. 底层: 事实上执行add操作的时候,工作区中的文件就已经加入到了对象库中,暂存区的目录树索引和对象库tree-ID下的目录树索引同时指向对象库中真实的文件
3. 提交的本质: commit操作执行之后立即产生一个commit-ID节点,使用暂存区下面的目录树索引为该commit-ID节点下面的数据域tree-ID指向的目录树索引赋值
4. 提交到哪里: 提交永远都是HEAD的“跟屁虫”，只会盯着HEAD,HEAD在哪个分支，该提交就挂接在这个分支最新提交的后面成为最新提交
6. 结果:该命令执行之后，暂存区和最新提交就有了相同的目录树索引，均指向版本库的.git/object/下的文件,因此,使用git diff HEAD比价暂存区和最新提交时返回无差异
Blog creation time:[2017-10-06 五 10:32]
** DONE [#D] Theme:撤销提交										 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:49]
1. 命令： git reset --soft HEAD^
2. 说明: 该操作是commit的逆，对暂存区和工作区文件的内容没有任何影响，主要用于想要重新书写提交说明时使用
Blog creation time:[2017-10-06 五 10:46]
** DONE [#D] Theme:修补提交 								 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:51]
1. 命令： git commit --amend -m "重新注释"
2. 该命令本质上相当于这两条命令的组合：
   1. git reset --soft HEAD^
   2. git commit -e -F .git/COMMIT_EDITMSG(保存了上次的提交日志)  
Blog creation time:[2017-10-06 五 10:50]
** DONE [#D] Theme:比较差异										 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
1. 暂存区与工作区
   1. 比较暂存区与工作区的差异：git diff (原始对象是暂存区)
   2. 比较暂存区与工作区指定文件的差异：git diff -- a.txt
2. 提交与暂存区
   1. 比较最新提交与暂存区：git diff HEAD --cached
   2. 比较最新提交与暂存区中指定文件：git diff HEAD --cached -- a.txt
   3. 比较指定提交与暂存区: git diff commit-ID --cached 
   4. 比较指定提交与暂存区中指定文件: git diff commit-ID --cached -- a.txt
   5. 比较里程碑A与暂存区: git diff A --cached
   6. 比较里程碑A与暂存区中指定文件: git diff A --cached -- a.txt
3. 提交与工作区
   1. 比较最新提交与工作区: git diff HEAD
   2. 比较最新提交与工作区中指定文件: git diff HEAD -- a.txt
   3. 比较指定提交与工作区：git diff commit-ID
   4. 比较指定提交与工作区中指定文件：git diff commit-ID -- a.txt
   5. 比较里程碑A与工作区的差异: git diff A
   6. 比较里程碑A与工作区中,指定文件的差异: git diff A -- a.txt
4. 提交与提交
   1. 比较指定提交与指定提交: git diff commit1-ID commit2-ID 
   2. 比较指定提交与指定提交中指定文件:git diff commit1-ID commit2-ID -- a.txt
   3. 比较里程碑A与里程碑B: git diff A B
   4. 比较里程碑A与里程碑B中指定文件: git diff A B -- a.txt
Blog creation time:[2017-10-06 五 10:52]
** DONE [#D] Theme:回滚											 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
1. 从暂存区回滚至工作区
   1. 回滚单个文件： git checkout -- a.txt
   2. 回滚所有文件： git checkout .
   3. 说明：该操作会用暂存区的指定文件或者全部文件替换工作区的文件
   4. 结果： 工作区中的文件内容，同暂存区中目录树索引下的文件内容保持一致
   5. 后果： 这意味着会丢失工作区中未添加到暂存区中的修改 
2. 从对象库回滚至暂存区
   1. 回滚单个文件： 
	  1. 命令： git reset commit-ID a.txt
	  2. 说明： 回滚单个文件不会丢失对象库中的最新提交到commit-ID这一段之间的commit，因为只回滚个别文件，说明用户有意要和对象库中的commit-ID存在差异，所以，回滚后的a.txt和暂存区的其他文件构成另一个commit
	  3. 结果： 该操作用对象库commit-ID下的a.txt替换掉暂存区中的a.txt
	  4. 后果： 会丢失在执行该操作之前，使用命令git add a.txt到暂存区的修改
	  5. 备注： 该操作同3-1中回滚单个文件最大的区别在于，该操作不会更改工作区文件的内容 
   2. 回滚所有文件： 
	  1. 命令： git reset --mixed commit-ID
	  2. 说明： 该操作让对象库中的commit-ID提交同暂存区保持一致,但是,对象库比commit-ID还新的提交有可能存在，鉴于保持一致的理念，对象库只能将最新版本重置到commit-ID
	  3. 结果： 该操作用对象库commit-ID，替换整个暂存区，即，暂存区中的索引与commit-ID中tree指针下的索引，完全一致
	  4. 后果： 丢失最近一次add到暂存区的修改以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
3. 从对象库回滚至(暂存区+工作区)
   1. 回滚单个文件： git checkout commit-ID -- a.txt
   2. 回滚所有文件： git checkout commit-ID -- .
   3. 回滚所有文件(常用): git checkout tag-name -- .
   4. 说明：
	  1. 如果commit-ID不是最新提交(HEAD->master)而是之前的提交，那么，在回滚后，暂存区会与对象库的最新提交不一致而不干净，要求再次提交
	  2. 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换暂存区下（当前存在的文件）的索引，用索引下的全部文件替换工作区下（对应）的文件
	  3. 注意：2中用小括号括起来的两个关键字非常重要：在进行替换时，如果暂存区或者工作区中新增加了对象库提交中没有的文件，此时的替换只会替换对象库，工作区，暂存区中公共的文件，差异的文件内容以及文件状态不变
      4. 回滚操作与重置(git reset --hard commit-ID)的区别在于,回滚操作只用commit-ID中文件覆盖暂存区以及工作区中的同名文件,暂存区和工作区特有的,commit-ID中没有的这些文件保持原样,而重置则是使得工作区暂存区中有且仅有commit-ID中的文件(版本库干净)
   5. 结果：
      1. 工作区中的文件内容，暂存区目录树索引下的文件的内容，同commit-ID节点中tree元素指向的目录树索引下的blob文件内容一致
      2. 那些只在工作区下或者暂存区下才有的而commit-ID这个提交中没有的文件，依旧保持其该有的状态以及内容
   6. 后果：工作区中未add的改动以及暂存区中未commit的改动，如果发生改动的文件在commit-ID这个提交下存在，那么，这些改动会被commit-ID下的文件内容覆盖
Blog creation time:[2017-10-06 五 10:58]
** DONE [#D] Theme:重置											 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
1. 软重置
   1. 基础命令: git reset --soft commit-ID
   2. 常用命令: git reset --soft tag-name (里程碑真的很好用,建议多用!)
   3. “软”的意义：只改变对象库中HEAD->master对commit-ID的指向，不改变暂存区和工作区文件的内容
   4. 功能昵称: 多步悔棋,穿梭过去
   5. 使用场合： 开发过程中,对某一个特性功能进行一系列测试,修补,再测试之后终于得到了正确的版本,但是,却在版本库中遗留了多个提交,这些提交都是中间过程提交,遗留在版本库中意义不大,此时,可以使用该重置命令,将版本库中的最新提交重置到特性功能测试之前的那个提交上,然后再将这个最终得到的正确版本提交到版本库,这样就更改剔除了那些个不必要的版本,还可以重设提交说明,这样做使得版本库更加简洁
2. 混合重置
   1. 命令： git reset --mixed commit-ID(默认缺省--mixed)
   2. “混合”的意义： 不改变工作区文件的内容，但是会改变暂存区的内容
   3. 说明： 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换整个暂存区，即，暂存区中的索引与commit-ID中tree指针下的索引，完全一致
   4. 结果： 暂存区与commit-ID的文件内容一致，工作区的文件的内容还是重置前的内容，但是状态变为待add的状态
   5. 后果：丢失最近一次add到暂存区的修改以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
3. 强制重置
   1. 命令： git reset --hard commit-ID
   2. “强制”的意义： 工作区和暂存区的文件内容都会被commit-ID下的文件内容覆盖
   3. 结果：工作区，暂存区，与commit-ID的文件内容一致
   4. 后果： 会丢失工作区中尚未add的改动以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
   5. 备注： 可以使用git reset --hard HEAD来彻底恢复到上一次提交的那个干净的版本
4. 挽救错误的重置
   1. 重置最显著的特点就是，最新的commit-ID到待重置的commit-ID这一段之间的commit会丢失，因此，重置行为是版本库中最危险的行为，因为会丢失提交
   2. 使用reflog来挽救错误的重置
	  1. 从日志中获取最新ID：git reflog show | head -5
	  2. 找到eb3bcab master@{0}: reset: moving to HEAD^所在行
	  3. 由于该日志是将最新的改变放在前面，因此，这一行的下面一行就是重置前的commit，假设为master@{2}所在行
	  4. 再次重置：git reset --hard master@{2}
Blog creation time:[2017-10-06 五 11:12]
** DONE [#D] Theme:删除											 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 15:41]
1. 删除工作区尚未追踪的文件 
   1. 删除尚未追踪的指定文件: git clean -fd a.txt
   2. 删除尚未追踪的所有文件: git clean -fd
   3. 说明: 尚未追踪的文件,其删除操作与暂存区和对象库没有任何联系
2. 删除暂存区中的文件
   1. 删除指定文件： git rm -rf --cached a.txt
   2. 删除所有文件:  git rm -rf --cached *
   3. 说明： 该操作只删除暂存区中的文件,工作区中的文件依旧是删除操作之前的最新内容
3. 删除 工作区+暂存区 中的文件
   1. 删除指定文件: git rm -rf a.txt
   2. 删除所有文件: git rm -rf *
   3. 结果: 该操作使得在工作区和暂存区的指定文件都会被删除,因此,暂存区与对象库的最新提交不一致,会要求提交新版本
4. 删除对象库提交
   1. 命令: git reset --soft commit-ID
   2. 说明: 对象库中的提交是版本库这个大链表上的一些个节点,删除某个节点破坏了版本控制系统连续记录的原则,因此,该操作会将最新提交到该commit-ID之间的提交都删除掉
Blog creation time:[2017-10-06 五 14:17]
** DONE [#D] Theme:恢复删除										 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 15:41]
1. 命令: git checkout HEAD~1 -- a.txt
2. 说明: 如果a.txt使用git rm -rf a.txt删除了工作区和暂存区中的a.txt并进行了提交,如果想要找回a.txt,可以在HEAD^这个提交下面找回 
Blog creation time:[2017-10-06 五 15:27]
** DONE [#D] Theme:更改文件名字									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 22:25]
1. 命令: git mv a.txt aa.txt
2. 说明: 该操作可以同时更改工作区和暂存区中的中的a.txt的名字为aa.txt
Blog creation time:[2017-10-06 五 15:42]
** DONE [#D] Theme:保存工作进度									 :@Blog:@Git:
   SCHEDULED:<2017-10-06 五>
   - State "DONE"       from "WAITTING"   [2017-10-06 五 22:25]
1. 保存进度的原理:
   1. 调用进度保存指令git stash save "注释",触发下面的步骤
   2. 从当前分支的最新提交节点处,开创建一个特殊(stash分支)的新分支,这个最新的提交节点就是特殊新分支的起点,让进度指针头refs/stash指向这个起点,如此便创建了一个进度分支
   3. 将暂存区提交到进度分支上,保存好暂存区的进度
   4. 将该进度分支的起点节点与进度分支的暂存区进度进行合并,生成工作区进度
2. 保存进度: git stash save "gMrM--a.txt gM--b.txt gM--subdir/dir/c.txt"
   1. 该命令使用了git reset --hard HEAD,工作区,暂存区,最新提交,三者内容一致,版本库干净
   2. 当存在未追踪的文件时,进度保存操作无法进行,需要先追踪才可以
   3. 该命令执行之后,会产生一条进度保存记录,使用git stash list查看
   4. 我的注释格式: g:green ; r:red 用于描述大写字母的颜色
   5. 进度保存的实质: 将进度保存在引用refs/stash所指向的提交中
   6. 进度保存操作会将,暂存区提交后产生的stash-commit-ID,与进度保存前,对象库的最新进行合并,产生一个stash-commit-ID,refs/stash指向会指向它
   7. 可以使用-k参数,在保存进度后不会将暂存区重置
3. 查看进度保存记录: git stash list
   1. 该命令显示之前保存过的众多进度
   2. 恢复进度时,可以查看该记录来选择恢复那个进度
4. 恢复进度: git stash pop --index stash@{n}
   1. --index: 指明恢复进度时,除了恢复工作区之外,还会尝试恢复暂存区.如果不指定该参数则只恢复工作区的文件内容
   2. 恢复后删除进度保存列表中的记录
5. 运用进度: git stash apply --index stash@{n}
   1. --index: 指明恢复进度时,除了恢复工作区之外,还会尝试恢复暂存区.如果不指定该参数则只恢复工作区的文件内容
   2. 只是运用该进度而不会将其从进度保存列表中删除
   3. 该操作和恢复进度的功能是一样的,区别就是恢复后不删除,该命令的优点在于可以多次运用该进度
6. 删除进度: git stash drop stash@{n}
7. 删除所有进度: git stash clear
8. 查看进度保存日志: git log --graph --pretty=raw refs/stash -2
Blog creation time:[2017-10-06 五 14:17]
** DONE [#D] Theme:文件追溯										 :@Blog:@Git:
    SCHEDULED:<2017-10-09 一>
	- State "DONE"       from "WAITTING"   [2017-10-09 一 10:08]
1. 追溯a.txt中的所有行: git blame a.txt
2. 追溯a.txt中第2行开始的3行内容: git blame -L 2,+3 a.txt
3. 要求: blame的对象必须一个文件,且该文件必须commit到对象库中
4. 作用: 以行为单位,显示该行最早在哪个commit中引入,以及由谁在什么时候引入
5. 使用场合: 在开发过程中发现bug时,定位到具体的源文件之后,可以使用该命令追溯该bug是由谁在什么时候的哪个commit中引入
6. 使用前提: 该操作是建立在bug已经定位到源代码的基础之上,然后才能定位到bug行的提交者,进行打板子教育
Blog creation time:[2017-10-09 一 09:29]
** WAITTING [#D] Theme:拣选 									 :@Blog:@Git:
    SCHEDULED:<2017-10-09 一>
1. 开发还在进行中......
2. 在历史提交 commit-ID4 中发现一个严重的bug,需要去fixed这个提交的bug
3. 
4. 回滚版本库中 commit-ID3 至暂存区和工作区
5. 挑拣过程中出现冲突:http://blog.csdn.net/wh_19910525/article/details/7554430
Blog creation time:[2017-10-09 一 10:30]
** DONE [#D] Theme:忽略文件										 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
	- State "DONE"       from "WAITTING"   [2017-10-07 六 22:23]
1. 共享式忽略
   1. 一个文件的文件名如果被添加进workspace/.gitignore,则该文件不会被版本库管理
   2. 注意: 如果一个文件在被添加进.gitignore之前就已经add进了版本控制系统,则忽略无效
   3. 共享的含义: 当其他人clone,pull该版本库时,这个忽略文件仍然有效
2. 独享式忽略
   1. 局部独享: .git/info/exclude,只针对某一个版本库
   2. 全局独享: ~/.gitconfig,下面的core.excludesfile指定的文件,针对该用户相关的所有版本库
   3. 设置全局独享忽略: git config --global core.excludesfile /home/ljj/.gitconfig
   4. 独享的含义: 当其他人clone,pull该版本库时,该忽略文件不会被传递给该用户
Blog creation time:[2017-10-07 六 22:01]
** DONE [#D] Theme:文件归档										 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
	- State "DONE"       from "WAITTING"   [2017-10-07 六 22:45]
1. 基于提交创建归档: git archive -o lastest.zip commit-ID
2. 基于提交中的指定目录创建归档: git archive -o lastest.tar commit-ID -- subdir1 subdir2
3. 基于里程碑linux_1.0创建归档,并将归档中的所有文件都添加kernal/n前缀: git archive --format=tar --prefix=kernel/ linux_1.0 | gzip > linux_1.0-3-g5ea60ef.tar.gz
Blog creation time:[2017-10-07 六 22:27]
** DONE [#D] Theme:gitg											 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
	- State "DONE"       from "WAITTING"   [2017-10-08 日 08:53]
1. gitg 是使用GTK+图形库实现的一个git版本库浏览器软件
2. gitg不仅可以实现gitk的全部功能(浏览历史和文件),还能帮助执行提交
3. 安装gitg: sudo aptitude install gitg
Blog creation time:[2017-10-07 六 22:52]
** WAITTING [#D] Theme:底层命令								 :@Blog:@Git:
    SCHEDULED:<2017-10-08 日>
1. git 的命令中,一部分是使用ID作为参数,一部分则使用范围作为参数,下面的两个底层命令中rev-parse就是负责ID相关,rev-list负责范围相关
2. git rev-parse
   1. 该底层命令功能非常丰富和杂乱,很多的git脚本或者工具都会用到这条命令
   2. 显示分支: git rev-parse --symbolic --branches
   3. 显示所有里程碑: git rev-parse --symbolic --tags
   4. 显示定义的所有引用: git rev-parse --symbolic --glob=refs/*
   5. 显示HEAD对应的的commit-ID: git rev-parse HEAD
   6. 显示tag对应的tag-commit-ID: git rev-parse linux_1.0
   7. 显示tag对应的tag-commit-ID指向的提交的父提交的commit-ID: git rev-parse linux_1.0~2
   8. 显示tag对应的tag-commit-ID指向的提交下的tree-ID: git rev-parse linux_1.0:
   9. 显示tag对应的tag-commit-ID指向的提交下的tree-ID下子目录的tree-ID或者文件的blob-ID
   10. 同时显示多个对应的SHA1哈希值: git rev-parse master refs/heads/master
   11. 给定一个简写的SHA1哈希值,给出完整的SHA1哈希值: git rev-parse 5ea60ef
3. git rev-list
   1. 显示,所有与版本A关联的历史提交: git rev-list --oneline A
   2. 显示,所有与版本A关联的历史提交(A自身除外): git rev-list --oneline A^@
   3. 显示,A自身: git rev-list --oneline A^!
   4. 显示,所有与版本A关联 and 与版本B关联的历史提交: git rev-list --oneline A B
   5. 显示,所有与版本A关联的历史提交中排除掉与D,F关联的历史提交之后剩下的提交: git rev-list --oneline B ^D ^F
   6. 显示,所有B,C的历史提交 中,排除B,C的交集之后,剩余的所有历史提交: git rev-list --oneline B...C
Blog creation time:[2017-10-08 日 08:54]
** WAITTING [#D] Theme:分支									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
1. 分支的构成
   1. 分支的祖先起点：主分支上的第一次提交，是任意分支的祖先起点
   2. 分支的起点： 每个分支，都有一个分支起点。任意分支上的任意提交，都可以是某指定分支的起点
   3. 分支指针头： 每个新建的分支，都有一个分支指针。分支指针头总是指向该分支的最新提交
   4. 空分支：只有分支起点和分支指针构成的分支称为一个空分支
   5. 分支指针头的生命周期：分支指针在该分支被创建的时候产生，在该分支合并到其起点所在的分支时，分支指针死亡
   6. 分支的构成：任意一个新创建的分支，由：分支起点 + 分支提交结点 + 指向分支最新提交的分支指针头 构成
2. 分支的背景知识
   1. HEAD，总是指向当前分支的分支指针头
   2. 分支指针头，总是指向自己分支所有提交中的最新提交
   3. 提交： 提交永远都是HEAD的“跟屁虫”，只会盯着HEAD,HEAD在哪个分支，该提交就挂接在这个分支最新提交的后面成为最新提交
   4. 切换到新分支的本质是让HEAD指向新分支的分支指针头 
3. 查看版本库的分支：git branch -v
4. 创建分支：git branch new-br
5. 切换到新分支：git checkout new-br
6. 创建分支并切换到新分支:git checkout -b new-br
7. 切换到“分离头指针状态”
   1. 命令： git checkout commit-ID
   2. 通常，HEAD总是指向分支指针头，表示该分支指针头指向的分支是当前分支，而让HEAD指向提交，表示版本库处于“分离头指针状态” 即，'detached HEAD'		 
   3. ”分离头指针状态“的特点：
	  1. 可以检查，测试，提交而不影响任何分支
	  2. 切换会分支之后，在分离头指针状态下的提交在log中不再显示，提交也消失了，但是，依然存在版本库中，但是，当reflog中的该提交日志过期之后，这个提交随时会彻底删除
	  4. 合并“分离头指针状态”的提交至主分支master
		 1. 命令：git merge new-commit-ID
		 2. 由于在“分离头指针状态”所做出的提交除了能被new-commit-ID所访问到之外，就无法通过分支访问。另外，该提交随时会在版本库中彻底消失，如果这个提交对master很重要的话，可以通过该操作将这个提交合并到master上即可
Blog creation time:[2017-10-06 五 14:21]
** WAITTING [#D] Theme:开发模型 								 :@Blog:@Git:
*** 金字塔式协同模型
1. linux社区就是使用的金字塔协同模型
2. 特点:
   1. 只有核心开发者develop才具备向master推送的权限,任何开发者都具备读master的权限(这意味着需要搭建一个只读的Git服务器)
*** Android式多版本协同模型(重点)


1. 单人工作模型
2. 团队工作模型
2-1 金字塔版本控制模型：发布Linux
--最终版本库；  ---> Fedora 25发行版
--有一个权威贡献者的版本库（linus）
--有几个核心贡献者的版本库（Kernel、Samba、KDE、Gnome）
--有若干开发者（37人）的版本库（10个人负责开发Kernel、6个人负责开发Samba、
  12个人负责开发KDE、9个人负责开发Gnome）

特点：
--每个贡献者的版本库都是平等的；
--用于版本控制的模型；

2-2金字塔版开发模型：开发Samba
2-2-1服务器端，主分支master;   ---> Samba 3.4.1
1.不允许在master分支上干活，所以该分支不属于某一个成员，应当找一个牛来管理
（合并分支）master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有slaver分支对它有写权限，即，只有slaver分支才能向它合并代码；
3.所有分支对它都有读权限；
4.这个分支是非常稳定的，可以作为产品的。

2-2-2服务器端，开发分支（slaver）
1.这个开发分支用于干活，但是该分支也不属于某一个成员，应当找一个牛来管理（合并分支）
  master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有核心开发分支（A、B、C、D）才对它有写权限，即，只有核心开发者才能向
  slaver分支合并代码；
3.只有核心开发分支（A、B、C、D）才对它有读权限
4.这个分支是不稳定的，找来管理它的牛在充分测试后时不时把它作为版本合并
  到master分支上即可。

2-2-3服务器端，核心开发者的开发分支（A、B、C、D）
1.这四个分支的所有者可以在属于自己的分支上干活，并且时不时向slaver分支合并代码
  并且，接受
2.向slaver合并代码，
  
--有若干开发者（37人）的开发分支（其中10个人只能）

特点：
-每个开发者的版本库都是平等的；
--用于版本开发的模型；

个人也必须有一个master分支和slaver分支，其中，slaver分支用于自己干活，master
分支主要用于三个方面：向上级分支推送代码，接受别人代码的合并，接受自己在slaver分支
上的代码的合并
Blog creation time:[2017-09-05 二 08:07]
** WAITTING [#D] Theme:克隆									 :@Blog:@Git:
    SCHEDULED:<2017-10-09 一>
1. 必要性: 再健壮的版本库设计,也抵挡不了存储介质的崩溃,因此,不要将鸡蛋装在同一个篮子里
2. 
Blog creation time:[2017-10-09 一 14:50]
** WAITTING [#D] Theme:日志									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
3. 日志
   1. 在执行commit命令之后，就会在log中产生一条提交信息
   2. git log --stat
      commit ccbbaeae9b9444ad21caa6d8216f7b8a4d22f59a (HEAD -> master, origin/master)
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Mon Oct 2 10:34:04 2017 +0800
	  
	  -----
	  
	  blogs-git-active.org       | 227 +++------------------------------------
	  blogs-linux-active.org     | 262 ++++++++++++++++++++++++++++++++++++++++++---
	  blogs-linux-arch-part2.org |   2 +-
	  3 files changed, 264 insertions(+), 227 deletions(-)
	  
	  commit e3f5fc176a40c3d889aecb4e051bfaec4101c4d5
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Sat Sep 30 20:55:18 2017 +0800
	  
	  -----
	  
      blogs-emacs-active.org | 144 +++++++++---------
      blogs-git-active.org   | 395 ++++++++++++++++++++++++++++++++++++++++++++++---
	  2 files changed, 449 insertions(+), 90 deletions(-) 
   3. git log --pretty=fuller
	  commit ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD)
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 20:17:49 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 20:17:49 2017 +0800
	  
	  -----
	  
	  commit 8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 19:35:59 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 19:35:59 2017 +0800
   4. git log --pretty=online
      ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD) -----
	  8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345 -----
	  228e998f2b5b1936fbd90f2441bf610d689caee1 -----
	  58c9b9ed50b28b4e47302dbc4248686d9e835f27 evil-mode
	  f9f1d307bb08c94f78e0714998759c1515e0f027 -----
	  34b45e97083e705d98900aaa8ec9692bc27e89eb -----
	  21c290a0cdebe3bebaff7148a5f69e4399a5ecc3 -----
	  915cd2a2564a5b8a942301de31b993d0f6ec2636 -----
   5. git log -l --pretty=raw
Blog creation time:[2017-10-06 五 14:21]
