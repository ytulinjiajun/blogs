* blogs-git-active
** DONE [#D] theme:我的工具网站									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
--git 官方网站：http://git-scm.com
--廖雪锋：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
Blog creation time:[2017-09-05 二 08:01]
** WAITTING [#D] Theme:基本概念								 :@Blog:@Git:
    SCHEDULED:<2017-09-23 六>
1. 工作区：一个等待进行版本控制的文件夹
2. 版本库：当使用git init对一个工作区进行初始化之后，在工作区下产生一个名为.git的文件夹，该文件夹称为该工作区的版本库
4. 原理：
   
   1. 待管理的文件位于工作区下面
   2. 使用git add .将工作区内的所有文件添加至版本库里面的暂存区中，接受版本控制
   3. 
5. 正确使用版本控制系统的方法是：一次提交只完成一件事
   1. 或是完成一个新功能
   2. 或是修改一个bug
   3. 或是写完一节内容
   4. 或是添加一副图片
   5. 注意：不要在下班才想起进行一次提交，那样的话git就降格成文件备份系统了
Blog creation time:[2017-09-23 六 22:36]
** WAITTING [#D] Theme:版本库workspace/.git/里面有什么？		 :@Blog:@Git:
    SCHEDULED:<2017-09-26 二>
1. index:
   1. 该文件是一个二进制文件,本质上，是一个包含文件索引的目录树
   2. 使用git add xx-file之后，xx-file这个文件的文件名将会挂接在index这个文件的目录树上
   3. 然而，xx-file这个文件的实际内容并没有存储在index这个文件中，而是存储在.git/objects目录这个对象库中
   4. index中xx-file这个文件的索引和对象库.git/objects中xx-file这个文件的实体建立起对应关系
   5. index的真实面目：所有加入版本库的文件形成目录树；目录树上挂接着接受版本控制的文件（其中，每个挂接的文件主要提供三部分信息：第一，该文件的文件名；第二，该文件的文件大小，第三，最近一次使用扫描工作区改动的命令(如git status,git diff等)时，所扫描到的文件的最新的时间戳）；目录树同对象库中相应的文件形成对应
2. objects/:
   1. 使用git add xx-file将xx-file文件加入到版本库之后，文件名，大小，时间戳等信息登记在index文件的目录树上，xx-file文件内部的真实内容则存储在.git/object/这个对象库中
   2. 对象库.git/object/中的文件同index中的目录树有着对应关系(我猜想，index中的目录树好比一个指针链表，每一个节点下存放指针类型的文件名，指向对象库中的对应文件)
3. branches/
4. HEAD
5. config
6. hooks/
7. info/
8. refs
9. packed-refs
10. description
11. logs/

Blog creation time:[2017-09-26 二 08:42]
** WAITTING [#D] Theme:版本库的基本原理						   :@Blog:@Emacs:
    SCHEDULED:<2017-09-25 一>
1. 扫描工作区的改动
   1. 执行git status 或者 git diff 命令时，将触发扫描工作区改动这一行为
   2. 取版本库.git/index中记录的文件名和时间戳，以及文件的长度，依据文件名，找到工作区内与之对应的文件，对比时间戳
   3. 若，发现，该文件在工作区中的当前时间戳与该文件在版本库中记录的时间戳不一致，则，判定为文件内容可能发生了改变，注意了，是可能改变而并非一定发生了改变，例如，你打开了一个文件，删除了一个字符，又重新输入该字符，此时，该文件的时间戳一定会更新的，因为你操作了文件，可是呢，内容却没有发生改变
   4. 此时，会打开该文件名对应的，在工作区中和在版本库中的该文件，两者进行比较(注意了，git管理的是修改而不是文件，所以该文件在版本库中不是同在工作区中一样的格式，这里暂且这么理解也没什么问题，因为更细致且复杂的工作由git这个系统的代码所承担了)，从而进一步进行判断该文件的内容是否真的发生了改变
   5. 如果该文件的内容没有发生改变，则将该文件的当前时间戳替换.git/index中该文件较老的那个时间戳
2. 将工作区中的文件添加至版本库
   1. 执行git add xx-file命令时，发生了两件事，第一，xx-file文件名被挂接到index文件的目录树上面；第二，xx-file文件内容被写入到对象库.git/objects/中
Blog creation time:[2017-09-25 一 16:57]

** DONE [#D] theme:命令 										 :@Blog:@Git:
1. 安装
   - 检查是否安装：dpkg -s git
   - 安装： sudo apt-get install git
   - 查看版本： git --version
2. 配置
   1. 单一版本库的配置：workspace/.git/config
	  1. 打开并编辑：git config -e
	  2. ...
   2. 全局配置：～/.gitconfig
	  1. 打开并编辑：git config -e --global
	  2. 配置标识
		 - 用户标识：git config --global user.name "linjiajun"
		 - 用户邮件：git congih --global user.email "ytulinjiajun@163"
		 - 标识的意义：指出 提交者 的身份， 标识是非常重要的，没有标识，git便没法识别提交者的身份
		 - 标识适合设置在全局文件中，因为全局文件存在于用户家目录下面，这样便同linux的多用户属性一致，当然了，也可以配置在版本库文件中
      3. 开启颜色显示：
	     - git config --global color.ui true
   3. 系统级配置：/etc/gitconfig
	  1. 打开并编辑：git config -e --system
	  2. 配置别名
	     - git config --system alias.sta status
	     - git config --system alias.ci commit
	  	 - git config --system alias.co checkout
	  	 - git config --system alias.br branch
   4. 读取某一配置项的值
	  1. git config core.bare
	  2. git config --global user.name
	  3. git config --system alias.sta
   5. 更改某一配置项的值
	  1. git config core.bare true
	  2. git config --global user.name ljj
	  3. git config --system alias.sta status
   6. 删除某一配置项：
	  1. git config --unset core.bare
	  2. git config --unset --global user.name
	  3. git config --unset --system alias.sta
   7. 直接使用配置文件
      - git完毕后立即可以使用的一个指令是:clone
      - 将自己保存在github上的配置文件clone到～目录下面:git clone git@github.com:xxx/.gitconfig
   8. 配置文件的格式：INI文件格式
   9. 优先级:版本库 > 全局 > 系统，高优先级的文件中的配置可以覆盖低优先级文件中的配置
   10. git config命令可以操作任何其他的INI文件
	   1. 读取配置文件test.ini中的配置：$ GIT_CONFIG=test.ini  git config a.b.c.d
	   2. 向配置文件test.ini中写配置：$ GIT_CONFIG=test.ini  git config a.b.c.d "hello world"
3. 对象库解析
   1. 对象库.git/obj/ ： 直观图解参看《git权威指南p87》
	  1. 对象库的本质一个双向链表，当前分支(比如master)是该链表的头指针,HEAD则是指向头指针的指针
	  2. 该链表的结点是一个又一个的commit，当前分支(比如master)可以在这些commit结点前后来回移动
	  3. 结点的指针域的值是commit类型的ID，该双向链表的就是通过这些ID值组织起来的
	  4. 结点的数据域由三部分构成：tree类型的ID,parent类型的ID,用户标识
		 1. tree类型是一个结构体类型,其成员是blob类型的指针，blob类型可以理解为文件类型，所以这些blob类型的指针就指向真正的文件
		 2. 每个blob类型的文件均有一个ID
   2. 寻址ID：git cat-file -p ID
      1. ID值总是一个指针类型，要么指向commit结点，要么指向tree类型的结构体，要么指向blob类型的文件
	  2. 我们总可以使用:git cat-file -p ID,来解析指针ID的值,取得该指针下的值
	  3. 常规步骤是先使用git lg查看commit类型的ID,然后通过该ID就能逐一解析出tree类型的ID以及blobn类型的ID
   3. 查看对象库中文件内容
	  1. 查看当前分支对应的提交内容：git cat-file commit HEAD
	  2. 查看指定分支(比如master)对应的提交: git cat-file commit master
	  3. 查看当前分支下某文件的内容: git cat-file blob HEAD:<TAB补全>
	  4. 查看指定分支(比如master)下某文件的内容： git cat-file blob master:<TAB补全>
   4. 获取ID类型：git cat-file -t ID
      1. 从上面对象库的分析中可以知道，git提供了如下3种类型的ID，对于给定ID，使用git cat-file -t ID，来了解该ID的类型
      2. commit: 使用git lg查看到的ID就是commit类型的ID
      3. tree:  
      4. blob:
   5. 获取,分支以及HEAD，的ID: git rev-parse master;  git rev_parse HEAD   
   6. HEAD,master,^,~的关系
	  1. HEAD指向当前分支，所以，HEAD就理解为当前分支
	  2. 分支是对象库的头指针，所以分支指向对象库的最新提交
	  3. master属于分支，是分支里面比较特殊的一个分支，称为主分支
	  4. 当且仅当存在master分支时，HAED自然就指向master
	  5. HEAD～n,指向当前分支，最新提交的第n个父提交，HEAD~1 等价于 HEAD^
4. 操作
   1. 概念
      1. 环节 
	     1. 工作区  ----(1)--->  暂存区
	     2. 暂存区  ----(2)--->  分支
	     3. 工作区  ----(3)--->  分支
	     4. 暂存区  ----(4)--->  工作区
	     5. 分支    ----(5)--->  暂存区
	     6. 分支    ----(6)--->  工作区
	  2. 研究清楚，标编号上面6个环节中：单个文件的传递，所有文件传递，的相关操作方法，git的知识点就全了
	  3. 版本库干净： 当工作区 = 暂存区 = 对象库（最新）提交 ===> 版本库干净（使用git status无任何状态）
   2. 创建版本库
      1. git init: 其结果是在工作区中生成版本库：.git/
	  2. git rev-parse --git-dir: 该操作可以在工作区的任何子目录下执行，其结果是显示该工作区的版本库的路径
	  3. git rev-parse --show-toplevel: 该操作可以在工作区的任何子目录下执行，其结果是显示该版本控制系统的根路径
	  4. git rev_parse --show-prefix: 该操作可以在工作区的任何子目录下执行，其结果是显示相对于该版本控制系统的根路径的相对目录
	  5. git rev_parse --show-cdup: 该操作可以在工作区的任何子目录下执行，其结果是显示当前目录回退到版本控制系统根的深度
   3. 查看状态
	  1. 常规：git status
	  2. 精简(推荐)：git status -s -b
	     1. 红色： 表示该文件需要执行add操作
		 2. 绿色： 表示该文件已经执行过add操作，现在可以执行commit操作
		 3. 空： 表示工作区干净
		 4. ??：表示该文件是一个未被追踪的文件(只可能是红色)
		 5. A： 表示该文件还从未进行过commit(只可能是绿色)
		 6. M: 表该文件发生了修改(红色和绿色均可能)
		 7. D: 表示该文件被删除(红色和绿色均可能)
   4. 浏览目录树
	  1. 浏览工作区中的目录树： ls -al
	  2. 浏览暂存区中的目录树： git ls-files -s
		 1. 第三列是暂存区编号不是文件大小
	  3. 浏览当前分支中的目录树： git ls-tree -l -rt HEAD
		 1. 第一列100644是文件的属性：rw-r--r--
		 2. 第二列标识文件还是目录：blob，文件，tree,目录
		 3. 第三列标识该文件在当前分支中的40为SHA1哈希值ID
		 4. 第四列是文件大小(Byte)
		 5. 第五列是文件名
   5. 添加至暂存区
      1. 添加单个文件： git add a.txt
	  2. 添加所有文件： git add -A
	  3. 所有文件中，添加已经被跟踪过的文件： git add -u
   6. 撤销出暂存区
	  1. 撤销单个文件的add： git reset -- a.txt
	  2. 撤销所有文件的add: git reset -- .
	  3. 该操作是add的逆,所以，对暂存区和对象库无任何影响
   7. 提交
	  1. 命令： git commit -m "Initialized"
	  2. 提交操作发生在暂存区到分支这个环节上，所以，只会将存在暂存区内的记录进行提交
	  3. 该命令将暂存区下的所有目录树索引，全部复制，黏贴到当前分支的目录树索引上,构成一个commit记录
	  4. 该命令执行之后，暂存区和当前分支就有了相同的目录树索引，均指向版本库的.git/object/下的文件
   8. 撤销提交
	  1. 命令： git reset --soft HEAD^
	  2. 该操作是commit的逆，对暂存区和工作区文件的内容没有任何影响，主要用于想要重新书写提交说明时使用
   9. 修补提交
	  1. 命令： git commit --amend
	  2. 该命令本质上相当于这两条命令的组合：git reset --soft HEAD^ ; git commit -e -F .git/COMMIT_EDITMSG(保存了上次的提交日志)  
   10. 比较差异
	   1. 比较暂存区与工作区的差异：git diff (原始对象是暂存区)
	   2. 比较当前分支与暂存区的差异：git diff --cached (原始对象是对象库最新提交)
	   3. 比较当前分支与工作区的差异：git diff commit-ID (原始对象是对象库commit-ID)
   11. 回滚
	   1. 从暂存区回滚至工作区
		  1. 回滚单个文件： git checkout -- a.txt
		  2. 回滚所有文件： git checkout .
		  3. 说明：该操作会用暂存区的指定文件或者全部文件替换工作区的文件
		  4. 结果： 工作区中的文件内容，同暂存区中目录树索引下的文件内容保持一致
		  5. 后果： 这意味着会丢失工作区中未添加到暂存区中的修改 
	   2. 从对象库回滚至暂存区
		  1. 命令： git reset commit-ID a.txt
		  2. 说明：
			 1. 该操作不会重置对象库中的提交，更不会更改工作区文件的内容
			 2. 只能回滚某个文件，而不能回滚所有(回滚所有，相当于在暂存区重新产生一个对象库已经存在的提交，对象库已经存在了，所以回滚所有的本质就是重置到对象库的某一版本)
		  3. 结果： 该操作用对象库commit-ID下的a.txt替换掉暂存区中的a.txt
		  4. 后果： 会丢失在执行该操作之前，使用命令git add a.txt到暂存区的修改
		  5. 备注： 该操作同3-1中回滚单个文件最大的区别在于，该操作不会更改工作区文件的内容
	   3. 从对象库回滚至(暂存区+工作区)
		  1. 回滚单个文件： git checkout commit-ID a.txt
		  2. 回滚所有文件： git checkout commit-ID .
		  3. 说明：
			 1. 如果commit-ID不是最新提交(HEAD->master)而是之前的提交，那么，在回滚后，暂存区会与对象库的最新提交不一致而不干净，要求再次提交
			 2. 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换暂存区下（当前存在的文件）的索引，用索引下的全部文件替换工作区下（对应）的文件
			 3. 注意：2中用小括号括起来的两个关键字非常重要：在进行替换时，如果暂存区或者工作区中新增加了对象库提交中没有的文件，此时的替换只会替换对象库，工作区，暂存区中公共的文件，差异的文件内容以及文件状态不变
		  4. 结果：工作区中的文件内容，暂存区目录树索引下的文件的内容，同commit-ID节点中tree元素指向的目录树索引下的blob文件内容一致，而那些只在工作区下或者暂存区下才有的而commit-ID这个提交中没有的文件，依旧保持其该有的状态以及内容
		  5. 后果：工作区中未add的改动以及暂存区中未commit的改动，如果发生改动的文件在commit-ID这个提交下存在，那么，这些改动会被commit-ID下的文件内容覆盖
   12. 重置
	   1. 软重置
		  1. 命令： git reset --soft commit-ID
		  2. “软”的意义：只改变对象库中HEAD->master对commit-ID的指向，不改变暂存区和工作区文件的内容
		  3. 使用场合：当对最新提交的提交说明或者提交的更改不满意时，撤销最新提交以便重新提交
	   2. 混合重置
		  1. 命令： git reset --mixed commit-ID(默认缺省--mixed)
		  2. “混合”的意义： 不改变工作区文件的内容，但是会改变暂存区的内容
		  3. 说明： 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换整个暂存区，即，暂存区中的索引与commit-ID中tree指针下的索引，完全一致
		  4. 结果： 暂存区与commit-ID的文件内容一致，工作区的文件的内容还是重置前的内容，但是状态变为待add的状态
		  5. 后果：丢失最近一次add到暂存区的修改以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
	   3. 强制重置
		  1. 命令： git reset --hard commit-ID
		  2. “强制”的意义： 工作区和暂存区的文件内容都会被commit-ID下的文件内容覆盖
		  3. 结果：工作区，暂存区，与commit-ID的文件内容一致
		  4. 后果： 会丢失工作区中尚未add的改动以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
		  5. 备注： 可以使用git reset --hard HEAD来彻底恢复到上一次提交的那个干净的版本
	   4. 挽救错误的重置
		  1. 重置最显著的特点就是，最新的commit-ID到待重置的commit-ID这一段之间的commit会丢失，因此，重置行为是版本库中最危险的行为，因为会丢失提交
		  2. 使用reflog来挽救错误的重置
			 1. 从日志中获取最新ID：git reflog show | head -5
			 2. 找到eb3bcab master@{0}: reset: moving to HEAD^所在行
			 3. 由于该日志是将最新的改变放在前面，因此，这一行的下面一行就是重置前的commit，假设为master@{2}所在行
			 4. 再次重置：git reset --hard master@{2}
   13. 保存工作进度
	   1. 背景：
		  1. 正在当前分支作业，工作区的修改尚未完成，突然出现一个紧急任务，需要重新创建一个分支，然后切换到该分支处理这个紧急任务
		  2. 但是，由于之前分支的任务未完成导致工作区不干净，切换到该分支之后，工作区的修改是之前分支的，所以，这个紧急任务和之前的任务混杂在一起了，这是非常糟糕的
		  3. git的处理方案是：在切换到处理紧急任务的分支之前，先保存一下工作进度，然后切换到分支，此时在新分支内工作区就是干净的了
		  4. 立即在新分支里面处理紧急任务，处理完毕之后，切换回之前的分支，然后恢复任务进度
		  5. 继续之前的任务进度完成任务
	   2. 实现：
		  1. 保存当前分支的任务进度：git stash
		  2. 切换到新分支：git checkout <new_branch>
		  3. 在新分支中完成紧急任务
		  4. 切换回之前的分支：git checkout <orignal_branch>
		  5. 恢复之前保存的任务进度：git stash pop
   14. 删除
	   1. 删除工作区
		  1. 删除工作区单个文件
		  2. 删除工作区全部文件
		  3. 删除工作区中所有未跟踪的文件： git clean -fd
		  4. 说明：
	   2. 剔除暂存区索引
		  1. 剔除暂存区单个个文件的索引： git rm -rf --cached a.txt
		  2. 剔除暂存区所有文件索引: git rm -rf --cached *
		  3. 说明：
			 1. 该操作仅仅是将某文件从暂存区的索引树里面剔除出去，但是该文件的内容依旧是当前工作区下文件的最新内容
			 2. 如果该文件之前从未被commit到主分支过，则该操作使得文件变成一个未被跟踪的文件；
			 3. 如果该文件之前被commit到主分支过，则该操作使得文件变成一个未被跟踪的文件的同时，会要求commit暂存区的剔除操作到分支，以使得暂存区的索引和分支的索引保持一致
			 4. 如3所述，当然，你也可以选择不提交这个剔除操作到分支，重新编辑该文件然后add进暂存区，会将剔除状态覆盖为修改状态
	   3. 删除分支索引
   15. 修补最新提交的提交说明
	   1. 命令：git commit --amend
   16. 修补历史提交的提交说明  
	   1. 变基操作： git rebase -i <commit-id>^
   17. 文件差异性比较
	   1. 命令：git diff
	   2. 该命令查看的是修改后的文件，与暂存区中该文件之间的差异
	   3. 标准的diff和patch存在一个局限：无法对二进制文件进行处理
	   4. git对二进制文件的比较提供了支持：git diff
	   5. git diff命令使用的是标准diff中的合并模式(unified mode)的语法格式，相当于diff -u
5. 日志
   1. 在执行commit命令之后，就会在log中产生一条提交信息
   2. git log --stat
      commit ccbbaeae9b9444ad21caa6d8216f7b8a4d22f59a (HEAD -> master, origin/master)
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Mon Oct 2 10:34:04 2017 +0800
	  
	  -----
	  
	  blogs-git-active.org       | 227 +++------------------------------------
	  blogs-linux-active.org     | 262 ++++++++++++++++++++++++++++++++++++++++++---
	  blogs-linux-arch-part2.org |   2 +-
	  3 files changed, 264 insertions(+), 227 deletions(-)
	  
	  commit e3f5fc176a40c3d889aecb4e051bfaec4101c4d5
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Sat Sep 30 20:55:18 2017 +0800
	  
	  -----
	  
      blogs-emacs-active.org | 144 +++++++++---------
      blogs-git-active.org   | 395 ++++++++++++++++++++++++++++++++++++++++++++++---
	  2 files changed, 449 insertions(+), 90 deletions(-) 
   3. git log --pretty=fuller
	  commit ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD)
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 20:17:49 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 20:17:49 2017 +0800
	  
	  -----
	  
	  commit 8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 19:35:59 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 19:35:59 2017 +0800
   4. git log --pretty=online
      ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD) -----
	  8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345 -----
	  228e998f2b5b1936fbd90f2441bf610d689caee1 -----
	  58c9b9ed50b28b4e47302dbc4248686d9e835f27 evil-mode
	  f9f1d307bb08c94f78e0714998759c1515e0f027 -----
	  34b45e97083e705d98900aaa8ec9692bc27e89eb -----
	  21c290a0cdebe3bebaff7148a5f69e4399a5ecc3 -----
	  915cd2a2564a5b8a942301de31b993d0f6ec2636 -----
   5. git log -l --pretty=raw
6. 创建.gitignore文件：该文件里面记录着该仓库里面不想接受版本控制的文件及目录
   Blog creation time:[2017-09-05 二 08:02]
** DONE [#D] theme:安装git										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
	Blog creation time:[2017-09-05 二 08:03]
** DONE [#D] theme:配置git										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1.设置 git 的user . name 和 user . email:
    git config --global user.name "linjiajun" ;
    git config --global  user.email "ytulinjiajun@163.com" ;
备注：这两个配置项会出现在git的配置文件中，当提交一个版本时，会从配置文件中取出这个信息，
若不配置这两个选项，则版本信息中会出现错误的提交者信息;

2.生成SSH秘钥：
生成：ssh-keygen -t rsa -C "ytulinjiajun@163.com"
其中：-t  用于指定加密类型，常见的有RSA和DSA加密方式，默认是DSA;
-C 作为批注
三次回车，按默认路径.ssh以及不需要密码安装即可

3.在GitHub上添加密钥：
Account Setting -> SSH Key -> Add SSH Key ;
复制~/.ssh/ssh-ras 的内容到 key 区域

4.验证SSH配置是否成功：
ssh -T git@github.com
Hi username! You've successfully authenticated ,but GitHub does not # provide shell access 

5.创建一个本地版本库：
git init

6.关联远程库：
git rmt git@github.com:ytulinjiajun/GitHub-Lin.git

6.从github克隆一个版本库验证SSH配置是否成功：

git clone git@github.com:ytulinjiajun/GitHub-Lin.git@github

7.配置别名：
方法一：使用命令
git config --global alias.sta status
方法二：修改配置文件
配置文件路径：～/.gitconfig
[alias]
	sta = status
	ci = commit
	rmt = remote add origin
	ps = push origin 
	co = checkout
	br = branch
	mg = merge --no-ff 
	unstage = reset HEAD
	rmt =  remote add origin 
	cl =  clone 
	lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
Blog creation time:[2017-09-05 二 08:04]
** DONE [#D] theme:创建版本库									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
--在指定位置新建一个目录：mkdir git-learn
--进入该目录：cd git-learn
--执行：git init
备注：也可以不进入该目录，直接输入：git init git-learn

--执行ls -al 可以发现：.git,这就是我们创建的版本库
--称git-learn为工作区，.git为版本库
Blog creation time:[2017-09-05 二 08:05]
** DONE [#D] theme:操作版本库									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1.原则
--正确使用版本控制系统的方法是，一次提交只完成一件事
--只有git commit才会产生版本，这意味着可以多次使用add文件到暂存区，提交版本时
  只会commit最新版？
--使用git push只会将本地众多版本中HEAD指向的版本推送到服务器？这意味着可以多
  次commit文件到本地版本库

2.查询操作
--查询当前git的版本：git --version
--查看某个版本号下面的文件内容：
--查询版本库的分支数：
--查询该仓库对应的远程仓库：
--查询日志：

3.基本操作
3-1 git status：
--包含三块信息：当前位于哪个分支、文件发生了哪些行为、目前可以执行哪些指令处理问题
-当前位于哪个分支：默认 on branch master
-文件发生了哪些行为：
1.Nothing to commit(working directory clean):干净的工作区
2.Untracked files:工作区内未被git管理的文件
3.Change not staged for commit:工作区内已经被git管理的文件发生了某些行为
4.Change to be commited:暂存区内有待提交的文件
-目前可以执行哪些指令处理问题：
1.Untracked files：可以add到暂存区给git管理，也可以放到.gitignore中告诉git不用管理它
2.

3-2 git add： 
--该操作的结果是：将工作区内的发生的行为同步到暂存区（unstage）
--注意：

4.未解决的疑惑
--在本地执行commit后，git status操作给出下面提示：
Your branch is based on 'origin/master', but the upstream is gone.
  (use "git branch --unset-upstream" to fixup)
Blog creation time:[2017-09-05 二 08:06]
** DONE [#D] theme:分支管理										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1.查看分支
--git br 
2.创建分支：
--git br slaver
3.切换分支：
--git co slaver
4.合并分支：
--git mg slaver
5.删除分支：
--git br -d slaver
Blog creation time:[2017-09-05 二 08:06]
** DONE [#D] theme:开发模型										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1. 单人工作模型
2. 团队工作模型
2-1 金字塔版本控制模型：发布Linux
--最终版本库；  ---> Fedora 25发行版
--有一个权威贡献者的版本库（linus）
--有几个核心贡献者的版本库（Kernel、Samba、KDE、Gnome）
--有若干开发者（37人）的版本库（10个人负责开发Kernel、6个人负责开发Samba、
  12个人负责开发KDE、9个人负责开发Gnome）

特点：
--每个贡献者的版本库都是平等的；
--用于版本控制的模型；

2-2金字塔版开发模型：开发Samba
2-2-1服务器端，主分支master;   ---> Samba 3.4.1
1.不允许在master分支上干活，所以该分支不属于某一个成员，应当找一个牛来管理
（合并分支）master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有slaver分支对它有写权限，即，只有slaver分支才能向它合并代码；
3.所有分支对它都有读权限；
4.这个分支是非常稳定的，可以作为产品的。

2-2-2服务器端，开发分支（slaver）
1.这个开发分支用于干活，但是该分支也不属于某一个成员，应当找一个牛来管理（合并分支）
  master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有核心开发分支（A、B、C、D）才对它有写权限，即，只有核心开发者才能向
  slaver分支合并代码；
3.只有核心开发分支（A、B、C、D）才对它有读权限
4.这个分支是不稳定的，找来管理它的牛在充分测试后时不时把它作为版本合并
  到master分支上即可。

2-2-3服务器端，核心开发者的开发分支（A、B、C、D）
1.这四个分支的所有者可以在属于自己的分支上干活，并且时不时向slaver分支合并代码
  并且，接受
2.向slaver合并代码，
  
--有若干开发者（37人）的开发分支（其中10个人只能）

特点：
-每个开发者的版本库都是平等的；
--用于版本开发的模型；

个人也必须有一个master分支和slaver分支，其中，slaver分支用于自己干活，master
分支主要用于三个方面：向上级分支推送代码，接受别人代码的合并，接受自己在slaver分支
上的代码的合并
Blog creation time:[2017-09-05 二 08:07]
** DONE [#D] theme:场景分析										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
*** 场景分析
	场景一：工作备份
	Blog creation time:[2017-09-05 二 08:08]
