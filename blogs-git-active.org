* blogs-git-active
** DONE [#D] theme:我的工具网站									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1. git 官方网站：http://git-scm.com
2. 廖雪锋：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
   Blog creation time:[2017-09-05 二 08:01]
** WAITTING [#D] Theme:基本概念								 :@Blog:@Git:
   SCHEDULED:<2017-09-23 六>
1. 工作区：一个等待进行版本控制的目标目录
2. 版本库：当使用git init对一个工作区进行初始化之后，在工作区下产生一个名为.git的文件夹，该文件夹就称为版本库
3. 正确使用版本控制系统的方法是：一次提交只完成一件事
   1. 或是完成一个新功能
   2. 或是修改一个bug
   3. 或是写完一节内容
   4. 或是添加一副图片
   5. 注意：不要在下班才想起进行一次提交，那样的话git就降格成文件备份系统了
4.  　
Blog creation time:[2017-09-23 六 22:36]
** WAITTING [#D] Theme:对象库解析 								 :@Blog:@Git:
   SCHEDULED:<2017-09-26 二>
1. index:
   1. 该文件是一个二进制文件,本质上，是一个包含文件索引的目录树
   2. 使用git add xx-file之后，xx-file这个文件的文件名将会挂接在index这个文件的目录树上
   3. 然而，xx-file这个文件的实际内容并没有存储在index这个文件中，而是存储在.git/objects目录这个对象库中
   4. index中xx-file这个文件的索引和对象库.git/objects中xx-file这个文件的实体建立起对应关系
   5. index的真实面目：所有加入版本库的文件形成目录树；目录树上挂接着接受版本控制的文件（其中，每个挂接的文件主要提供三部分信息：第一，该文件的文件名；第二，该文件的文件大小，第三，最近一次使用扫描工作区改动的命令(如git status,git diff等)时，所扫描到的文件的最新的时间戳）；目录树同对象库中相应的文件形成对应
2. objects/:
   1. 使用git add xx-file将xx-file文件加入到版本库之后，文件名，大小，时间戳等信息登记在index文件的目录树上，xx-file文件内部的真实内容则存储在.git/object/这个对象库中
   2. 对象库.git/object/中的文件同index中的目录树有着对应关系(我猜想，index中的目录树好比一个指针链表，每一个节点下存放指针类型的文件名，指向对象库中的对应文件)
3. branches/
4. HEAD
5. config
6. hooks/
7. info/
8. refs
9. packed-refs
10. description
11. logs/
12. 对象库解析
	1. 对象库.git/obj/ ： 直观图解参看《git权威指南p87》
	   1. 对象库的本质一个双向链表，当前分支(比如master)是该链表的头指针,HEAD则是指向头指针的指针
	   2. 该链表的结点是一个又一个的commit，当前分支(比如master)可以在这些commit结点前后来回移动
	   3. 结点的指针域的值是commit类型的ID，该双向链表的就是通过这些ID值组织起来的
	   4. 结点的数据域由三部分构成：tree类型的ID,parent类型的ID,用户标识
		  1. tree类型是一个结构体类型,其成员是blob类型的指针，blob类型可以理解为文件类型，所以这些blob类型的指针就指向真正的文件
		  2. 每个blob类型的文件均有一个ID
	2. 寻址ID：git cat-file -p ID
	   1. ID值总是一个指针类型，要么指向commit结点，要么指向tree类型的结构体，要么指向blob类型的文件
	   2. 我们总可以使用:git cat-file -p ID,来解析指针ID的值,取得该指针下的值
	   3. 常规步骤是先使用git lg查看commit类型的ID,然后通过该ID就能逐一解析出tree类型的ID以及blobn类型的ID
	3. 查看对象库中文件内容
	   1. 查看当前分支对应的提交内容：git cat-file commit HEAD
	   2. 查看指定分支(比如master)对应的提交: git cat-file commit master
	   3. 查看当前分支下某文件的内容: git cat-file blob HEAD:<TAB补全>
	   4. 查看指定分支(比如master)下某文件的内容： git cat-file blob master:<TAB补全>
	4. 获取ID类型：git cat-file -t ID
	   1. 从上面对象库的分析中可以知道，git提供了如下3种类型的ID，对于给定ID，使用git cat-file -t ID，来了解该ID的类型
	   2. commit: 使用git lg查看到的ID就是commit类型的ID
	   3. tree:  
	   4. blob:
	5. 获取,分支以及HEAD，的ID: git rev-parse master;  git rev_parse HEAD
	6. HEAD,master,^,~的关系
	   1. HEAD指向当前分支，所以，HEAD就理解为当前分支
	   2. 分支是对象库的头指针，所以分支指向对象库的最新提交
	   3. master属于分支，是分支里面比较特殊的一个分支，称为主分支
	   4. 当且仅当存在master分支时，HAED自然就指向master
	   5. HEAD～n,指向当前分支，最新提交的第n个父提交，HEAD~1 等价于 HEAD^
Blog creation time:[2017-09-26 二 08:42]
** DONE [#D] Theme:配置 										 :@Blog:@Git:
1. 本地配置：　git config -e
   1. 配置文件路径：workspace/.git/config
   2. 作用域：该文件下的配置，只在该workspace／中有效
   3. 优先级：最高
2. 全局配置：　git config --global -e
   1. 配置文件路径：　~/.gitconfig　
   2. 作用域：该文件下的配置，对当前用户的所有的版本库均有效
   3. 优先级：高于系统配置，低于全局配置
   4. 用户标识配置：git config --global user.name "linjiajun"
   5. 用户邮件配置：git config --global user.email "ytulinjiajun@163"
   6. 开启颜色显示：git config --global color.ui true
   7. 说明：用户标识和用户邮件必须进行配置，因为git会使用到这两个信息来标识提交者身份
3. 系统配置：　git config --system -e
   1. 配置文件路径：　/etc/gitconfig
   2. 作用域：该文件下的配置，对所有用户的所有版本库均有效
   3. 优先级：最低
   4. 配置别名：git config --system alias.sta status
4. 读取配置：　git config --global user.name 回车
5. 更改配置：　git config --system alias.co checkout
6. 删除配置：　git config --unset core.bare
7. 备注： 建议将配置文件上传到github,用到时直接clone到指定路径即可！
** DONE [#D] Theme:SSH											  :Blog:@Git:
1. 生成SSH秘钥： ssh-keygen -t rsa -C "ytulinjiajun@163.com"
   1. -t  用于指定加密类型，常见的有RSA和DSA加密方式，默认是DSA;
   2. -C 作为批注
   3. 三次回车，按默认路径.ssh以及不需要密码安装即可
2. 在Github上添加密钥： Account Setting -> SSH Key -> Add SSH Key
   复制~/.ssh/ssh-ras 的内容到 key 区域
3. 验证SSH配置是否成功： ssh -T git@github.com
   Hi username! You've successfully authenticated ,but GitHub does not provide shell access
5. 创建一个本地版本库： git init
6. 关联远程库： git rmt git@github.com:ytulinjiajun/GitHub-Lin.git
6. 从github克隆一个版本库验证SSH配置是否成功：git clone git@github.com:ytulinjiajun/GitHub-Lin.git
Blog creation time:[2017-09-05 二 08:04]
** DONE [#D] Theme:创建版本库　									   :Blog:@Git:
1. git init: 其结果是在工作区中生成版本库：.git/
2. git rev-parse --git-dir: 该操作可以在工作区的任何子目录下执行，其结果是显示该工作区的版本库的路径
3. git rev-parse --show-toplevel: 该操作可以在工作区的任何子目录下执行，其结果是显示该版本控制系统的根路径
4. git rev_parse --show-prefix: 该操作可以在工作区的任何子目录下执行，其结果是显示相对于该版本控制系统的根路径的相对目录
5. git rev_parse --show-cdup: 该操作可以在工作区的任何子目录下执行，其结果是显示当前目录回退到版本控制系统根的深度
** DONE [#D] Theme:查看状态										 :@Blog:@Git:
    SCHEDULED:<2017-10-05 四>
	- State "DONE"       from "WAITTING"   [2017-10-05 四 21:45]
1. 常规：git status
2. 精简(推荐)：git status -sb
   1. 红色： 表示该文件需要执行add操作
   2. 绿色： 表示该文件已经执行过add操作，现在可以执行commit操作
   3. 空： 表示工作区干净
   4. ??：表示该文件是一个未被追踪的文件(只可能是红色)
   5. A： 表示该文件还从未进行过commit(只可能是绿色)
   6. M: 表该文件发生了修改(红色和绿色均可能)
   7. D: 表示该文件被删除(红色和绿色均可能)
Blog creation time:[2017-10-05 四 21:41]
** DONE [#D] Theme:浏览											 :@Blog:@Git:
   SCHEDULED:<2017-10-05 四>
1. 浏览文件内容
   1. 浏览工作区中的文件内容：　less a.txt
   2. 浏览暂存区中的文件内容：　git diff
   3. 浏览对象库中的文件内容：　git cat-file blob commit-ID:a.txt
2. 浏览目录树
   1. 浏览工作区中的目录树： ls -al
   2. 浏览暂存区中的目录树： git ls-files -s
	  第三列是暂存区编号不是文件大小
   3. 浏览指定提交的目录树： git ls-tree -lrt commit-ID
	  1. 第一列100644是文件的属性：rw-r--r--
	  2. 第二列标识文件还是目录：blob，文件，tree,目录
	  3. 第三列标识该文件在当前分支中的40为SHA1哈希值ID
	  4. 第四列是文件大小(Byte)
	  5. 第五列是文件名
3. 浏览对象库
   1. ID的类型: commit-ID,tree-ID,blob-ID
   2. ID的本质: 指针
   3. 对象库本质: 一个双向链表,其节点是提交, git lg 可以查看到这些节点的ID
   4. 版本库的构成: HEAD指针,分支指针头,对象库
   5. "提交节点"的成分: 前驱指针域(id),数据域(tree,author),后继指针域(parent)
   6. 数据域中的tree: tree是一个tree-ID,因此,是一个指针,这个tree指向一个目录树索引,该目录树索引和暂存区中的目录树索引经常发生交互,它们均指向add进对象库中真正的文件 
   7. 获取指定ID的类型：git cat-file -t ID, 其返回值是: commit,tree,blob
   8. 解引用commit-ID: git cat-file -p commit-ID
	  1. 使用 git lg 可以查看到对象库的所有commit-ID
	  2. 其效果与 git cat-file commit commit-ID一致
	  3. 解引用的结果: 得到"提交节点"的成分,包括tree-ID
   9. 解引用tree-ID: git cat-file -p tree-ID
	  1. 其效果与 git ls-tree -lrt commit-ID 一样
	  2. 解引用的结果: 可以查看对象库中commit-ID下数据域tree-ID指向的目录树下面的所有blob-ID
   10. 解引用blob-ID: git cat-file -p blob-ID
	   1. 其效果与 git cat-file blob commit-ID:<tab补全>一致
	   2. 解引用的结果: 可以查看tree-ID下面所有blob-ID指向的文件的真正内容
Blog creation time:[2017-10-05 四 21:46]






** DONE [#D] theme:命令 										 :@Blog:@Git:
3. 基础操作
   1. 概念
      1. 环节 
	     1. 工作区  ----(1)--->  暂存区
	     2. 暂存区  ----(2)--->  分支
	     3. 工作区  ----(3)--->  分支
	     4. 暂存区  ----(4)--->  工作区
	     5. 分支    ----(5)--->  暂存区
	     6. 分支    ----(6)--->  工作区
	  2. 研究清楚，标编号上面6个环节中：单个文件的传递，所有文件传递，的相关操作方法，git的知识点就全了
	  3. 版本库干净： 当工作区 = 暂存区 = 对象库（最新）提交 ===> 版本库干净（使用git status无任何状态）
   4. 浏览目录树
	  1. 浏览工作区中的目录树： ls -al
	  2. 浏览暂存区中的目录树： git ls-files -s
		 1. 第三列是暂存区编号不是文件大小
	  3. 浏览当前分支中的目录树： git ls-tree -l -rt HEAD
		 1. 第一列100644是文件的属性：rw-r--r--
		 2. 第二列标识文件还是目录：blob，文件，tree,目录
		 3. 第三列标识该文件在当前分支中的40为SHA1哈希值ID
		 4. 第四列是文件大小(Byte)
		 5. 第五列是文件名
   5. 添加至暂存区
      1. 添加单个文件： git add a.txt
	  2. 添加所有文件： git add -A
	  3. 所有文件中，添加已经被跟踪过的文件： git add -u
   6. 撤销出暂存区
	  1. 撤销单个文件的add： git reset -- a.txt
	  2. 撤销所有文件的add: git reset -- .
	  3. 该操作是add的逆,所以，对暂存区和对象库无任何影响
   7. 提交
	  1. 命令： git commit -m "Initialized"
	  2. 提交操作发生在暂存区到分支这个环节上，所以，只会将存在暂存区内的记录进行提交
	  3. 该命令将暂存区下的所有目录树索引，全部复制，黏贴到当前分支的目录树索引上,构成一个commit记录
	  4. 该命令执行之后，暂存区和当前分支就有了相同的目录树索引，均指向版本库的.git/object/下的文件
   8. 撤销提交
	  1. 命令： git reset --soft HEAD^
	  2. 该操作是commit的逆，对暂存区和工作区文件的内容没有任何影响，主要用于想要重新书写提交说明时使用
   9. 修补提交
	  1. 命令： git commit --amend
	  2. 该命令本质上相当于这两条命令的组合：git reset --soft HEAD^ ; git commit -e -F .git/COMMIT_EDITMSG(保存了上次的提交日志)  
   10. 比较差异
	   1. 比较暂存区与工作区的差异：git diff (原始对象是暂存区)
	   2. 比较当前分支与暂存区的差异：git diff --cached (原始对象是对象库最新提交)
	   3. 比较当前分支与工作区的差异：git diff commit-ID (原始对象是对象库commit-ID)
   11. 回滚
	   1. 从暂存区回滚至工作区
		  1. 回滚单个文件： git checkout -- a.txt
		  2. 回滚所有文件： git checkout .
		  3. 说明：该操作会用暂存区的指定文件或者全部文件替换工作区的文件
		  4. 结果： 工作区中的文件内容，同暂存区中目录树索引下的文件内容保持一致
		  5. 后果： 这意味着会丢失工作区中未添加到暂存区中的修改 
	   2. 从对象库回滚至暂存区
		  1. 回滚单个文件： 
			 1. 命令： git reset commit-ID a.txt
			 2. 说明： 回滚单个文件不会丢失对象库中的最新提交到commit-ID这一段之间的commit，因为只回滚个别文件，说明用户有意要和对象库中的commit-ID存在差异，所以，回滚后的a.txt和暂存区的其他文件构成另一个commit
			 3. 结果： 该操作用对象库commit-ID下的a.txt替换掉暂存区中的a.txt
			 4. 后果： 会丢失在执行该操作之前，使用命令git add a.txt到暂存区的修改
			 5. 备注： 该操作同3-1中回滚单个文件最大的区别在于，该操作不会更改工作区文件的内容 
		  2. 回滚所有文件： 
			 1. 命令： git reset commit-ID
			 2. 说明： 该操作让对象库中的commit-ID提交同暂存区保持一致,但是,对象库比commit-ID还新的提交有可能存在，鉴于保持一致的理念，对象库只能将最新版本重置到commit-ID
		     3. 结果： 该操作用对象库commit-ID，替换整个暂存区，即，暂存区中的索引与commit-ID中tree指针下的索引，完全一致
		     4. 后果： 丢失最近一次add到暂存区的修改以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
	   3. 从对象库回滚至(暂存区+工作区)
		  1. 回滚单个文件： git checkout commit-ID a.txt
		  2. 回滚所有文件： git checkout commit-ID .
		  3. 说明：
			 1. 如果commit-ID不是最新提交(HEAD->master)而是之前的提交，那么，在回滚后，暂存区会与对象库的最新提交不一致而不干净，要求再次提交
			 2. 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换暂存区下（当前存在的文件）的索引，用索引下的全部文件替换工作区下（对应）的文件
			 3. 注意：2中用小括号括起来的两个关键字非常重要：在进行替换时，如果暂存区或者工作区中新增加了对象库提交中没有的文件，此时的替换只会替换对象库，工作区，暂存区中公共的文件，差异的文件内容以及文件状态不变
		  4. 结果：工作区中的文件内容，暂存区目录树索引下的文件的内容，同commit-ID节点中tree元素指向的目录树索引下的blob文件内容一致，而那些只在工作区下或者暂存区下才有的而commit-ID这个提交中没有的文件，依旧保持其该有的状态以及内容
		  5. 后果：工作区中未add的改动以及暂存区中未commit的改动，如果发生改动的文件在commit-ID这个提交下存在，那么，这些改动会被commit-ID下的文件内容覆盖
   12. 重置
	   1. 软重置
		  1. 命令： git reset --soft commit-ID
		  2. “软”的意义：只改变对象库中HEAD->master对commit-ID的指向，不改变暂存区和工作区文件的内容
		  3. 使用场合：当对最新提交的提交说明或者提交的更改不满意时，撤销最新提交以便重新提交
	   2. 混合重置
		  1. 命令： git reset --mixed commit-ID(默认缺省--mixed)
		  2. “混合”的意义： 不改变工作区文件的内容，但是会改变暂存区的内容
		  3. 说明： 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换整个暂存区，即，暂存区中的索引与commit-ID中tree指针下的索引，完全一致
		  4. 结果： 暂存区与commit-ID的文件内容一致，工作区的文件的内容还是重置前的内容，但是状态变为待add的状态
		  5. 后果：丢失最近一次add到暂存区的修改以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
	   3. 强制重置
		  1. 命令： git reset --hard commit-ID
		  2. “强制”的意义： 工作区和暂存区的文件内容都会被commit-ID下的文件内容覆盖
		  3. 结果：工作区，暂存区，与commit-ID的文件内容一致
		  4. 后果： 会丢失工作区中尚未add的改动以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
		  5. 备注： 可以使用git reset --hard HEAD来彻底恢复到上一次提交的那个干净的版本
	   4. 挽救错误的重置
		  1. 重置最显著的特点就是，最新的commit-ID到待重置的commit-ID这一段之间的commit会丢失，因此，重置行为是版本库中最危险的行为，因为会丢失提交
		  2. 使用reflog来挽救错误的重置
			 1. 从日志中获取最新ID：git reflog show | head -5
			 2. 找到eb3bcab master@{0}: reset: moving to HEAD^所在行
			 3. 由于该日志是将最新的改变放在前面，因此，这一行的下面一行就是重置前的commit，假设为master@{2}所在行
			 4. 再次重置：git reset --hard master@{2}
   13. 保存工作进度
	   1. 背景：
		  1. 正在当前分支作业，工作区的修改尚未完成，突然出现一个紧急任务，需要重新创建一个分支，然后切换到该分支处理这个紧急任务
		  2. 但是，由于之前分支的任务未完成导致工作区不干净，切换到该分支之后，工作区的修改是之前分支的，所以，这个紧急任务和之前的任务混杂在一起了，这是非常糟糕的
		  3. git的处理方案是：在切换到处理紧急任务的分支之前，先保存一下工作进度，然后切换到分支，此时在新分支内工作区就是干净的了
		  4. 立即在新分支里面处理紧急任务，处理完毕之后，切换回之前的分支，然后恢复任务进度
		  5. 继续之前的任务进度完成任务
	   2. 实现：
		  1. 保存当前分支的任务进度：git stash
		  2. 切换到新分支：git checkout <new_branch>
		  3. 在新分支中完成紧急任务
		  4. 切换回之前的分支：git checkout <orignal_branch>
		  5. 恢复之前保存的任务进度：git stash pop
   14. 删除
	   1. 删除工作区
		  1. 删除工作区单个文件
		  2. 删除工作区全部文件
		  3. 删除工作区中所有未跟踪的文件： git clean -fd
		  4. 说明：
	   2. 剔除暂存区索引
		  1. 剔除暂存区单个个文件的索引： git rm -rf --cached a.txt
		  2. 剔除暂存区所有文件索引: git rm -rf --cached *
		  3. 说明：
			 1. 该操作仅仅是将某文件从暂存区的索引树里面剔除出去，但是该文件的内容依旧是当前工作区下文件的最新内容
			 2. 如果该文件之前从未被commit到主分支过，则该操作使得文件变成一个未被跟踪的文件；
			 3. 如果该文件之前被commit到主分支过，则该操作使得文件变成一个未被跟踪的文件的同时，会要求commit暂存区的剔除操作到分支，以使得暂存区的索引和分支的索引保持一致
			 4. 如3所述，当然，你也可以选择不提交这个剔除操作到分支，重新编辑该文件然后add进暂存区，会将剔除状态覆盖为修改状态
	   3. 删除分支索引
   15. 修补最新提交的提交说明
	   1. 命令：git commit --amend
   16. 修补历史提交的提交说明  
	   1. 变基操作： git rebase -i <commit-id>^
   17. 文件差异性比较
	   1. 命令：git diff
	   2. 该命令查看的是修改后的文件，与暂存区中该文件之间的差异
	   3. 标准的diff和patch存在一个局限：无法对二进制文件进行处理
	   4. git对二进制文件的比较提供了支持：git diff
	   5. git diff命令使用的是标准diff中的合并模式(unified mode)的语法格式，相当于diff -u
4. 分支
   1. 分支的构成
      1. 分支的祖先起点：主分支上的第一次提交，是任意分支的祖先起点
	  2. 分支的起点： 每个分支，都有一个分支起点。任意分支上的任意提交，都可以是某指定分支的起点
	  3. 分支指针头： 每个新建的分支，都有一个分支指针。分支指针头总是指向该分支的最新提交
	  4. 空分支：只有分支起点和分支指针构成的分支称为一个空分支
	  5. 分支指针头的生命周期：分支指针在该分支被创建的时候产生，在该分支合并到其起点所在的分支时，分支指针死亡
	  6. 分支的构成：任意一个新创建的分支，由：分支起点 + 分支提交结点 + 指向分支最新提交的分支指针头 构成
   2. 分支的背景知识
	  1. HEAD，总是指向当前分支的分支指针头
	  2. 分支指针头，总是指向自己分支所有提交中的最新提交
	  3. 提交： 提交永远都是HEAD的“跟屁虫”，只会盯着HEAD,HEAD在哪个分支，该提交就挂接在这个分支最新提交的后面成为最新提交
      4. 切换到新分支的本质是让HEAD指向新分支的分支指针头 
   3. 查看版本库的分支：git branch -v
   4. 创建分支：git branch new-br
   5. 切换到新分支：git checkout new-br
   6. 创建分支并切换到新分支:git checkout -b new-br
   7. 切换到“分离头指针状态”
      1. 命令： git checkout commit-ID
      2. 通常，HEAD总是指向分支指针头，表示该分支指针头指向的分支是当前分支，而让HEAD指向提交，表示版本库处于“分离头指针状态” 即，'detached HEAD'		 
      3. ”分离头指针状态“的特点：
	     1. 可以检查，测试，提交而不影响任何分支
	     2. 切换会分支之后，在分离头指针状态下的提交在log中不再显示，提交也消失了，但是，依然存在版本库中，但是，当reflog中的该提交日志过期之后，这个提交随时会彻底删除
	  4. 合并“分离头指针状态”的提交至主分支master
		 1. 命令：git merge new-commit-ID
		 2. 由于在“分离头指针状态”所做出的提交除了能被new-commit-ID所访问到之外，就无法通过分支访问。另外，该提交随时会在版本库中彻底消失，如果这个提交对master很重要的话，可以通过该操作将这个提交合并到master上即可
5. 日志
   1. 在执行commit命令之后，就会在log中产生一条提交信息
   2. git log --stat
      commit ccbbaeae9b9444ad21caa6d8216f7b8a4d22f59a (HEAD -> master, origin/master)
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Mon Oct 2 10:34:04 2017 +0800
	  
	  -----
	  
	  blogs-git-active.org       | 227 +++------------------------------------
	  blogs-linux-active.org     | 262 ++++++++++++++++++++++++++++++++++++++++++---
	  blogs-linux-arch-part2.org |   2 +-
	  3 files changed, 264 insertions(+), 227 deletions(-)
	  
	  commit e3f5fc176a40c3d889aecb4e051bfaec4101c4d5
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Sat Sep 30 20:55:18 2017 +0800
	  
	  -----
	  
      blogs-emacs-active.org | 144 +++++++++---------
      blogs-git-active.org   | 395 ++++++++++++++++++++++++++++++++++++++++++++++---
	  2 files changed, 449 insertions(+), 90 deletions(-) 
   3. git log --pretty=fuller
	  commit ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD)
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 20:17:49 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 20:17:49 2017 +0800
	  
	  -----
	  
	  commit 8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 19:35:59 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 19:35:59 2017 +0800
   4. git log --pretty=online
      ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD) -----
	  8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345 -----
	  228e998f2b5b1936fbd90f2441bf610d689caee1 -----
	  58c9b9ed50b28b4e47302dbc4248686d9e835f27 evil-mode
	  f9f1d307bb08c94f78e0714998759c1515e0f027 -----
	  34b45e97083e705d98900aaa8ec9692bc27e89eb -----
	  21c290a0cdebe3bebaff7148a5f69e4399a5ecc3 -----
	  915cd2a2564a5b8a942301de31b993d0f6ec2636 -----
   5. git log -l --pretty=raw
6. 创建.gitignore文件：该文件里面记录着该仓库里面不想接受版本控制的文件及目录
   Blog creation time:[2017-09-05 二 08:02]
** DONE [#D] theme:安装										 :@Blog:@Git:
1. 检查是否安装：dpkg -s git
2. 安装： sudo apt-get install git
3. 查看版本： git --version
Blog creation time:[2017-09-05 二 08:03]
** DONE [#D] theme:创建版本库									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
--在指定位置新建一个目录：mkdir git-learn
--进入该目录：cd git-learn
--执行：git init
备注：也可以不进入该目录，直接输入：git init git-learn

--执行ls -al 可以发现：.git,这就是我们创建的版本库
--称git-learn为工作区，.git为版本库
Blog creation time:[2017-09-05 二 08:05]
** DONE [#D] theme:操作版本库									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1.原则
--正确使用版本控制系统的方法是，一次提交只完成一件事
--只有git commit才会产生版本，这意味着可以多次使用add文件到暂存区，提交版本时
  只会commit最新版？
--使用git push只会将本地众多版本中HEAD指向的版本推送到服务器？这意味着可以多
  次commit文件到本地版本库

2.查询操作
--查询当前git的版本：git --version
--查看某个版本号下面的文件内容：
--查询版本库的分支数：
--查询该仓库对应的远程仓库：
--查询日志：

3.基本操作
3-1 git status：
--包含三块信息：当前位于哪个分支、文件发生了哪些行为、目前可以执行哪些指令处理问题
-当前位于哪个分支：默认 on branch master
-文件发生了哪些行为：
1.Nothing to commit(working directory clean):干净的工作区
2.Untracked files:工作区内未被git管理的文件
3.Change not staged for commit:工作区内已经被git管理的文件发生了某些行为
4.Change to be commited:暂存区内有待提交的文件
-目前可以执行哪些指令处理问题：
1.Untracked files：可以add到暂存区给git管理，也可以放到.gitignore中告诉git不用管理它
2.

3-2 git add： 
--该操作的结果是：将工作区内的发生的行为同步到暂存区（unstage）
--注意：

4.未解决的疑惑
--在本地执行commit后，git status操作给出下面提示：
Your branch is based on 'origin/master', but the upstream is gone.
  (use "git branch --unset-upstream" to fixup)
Blog creation time:[2017-09-05 二 08:06]
** DONE [#D] theme:分支管理										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1.查看分支
--git br 
2.创建分支：
--git br slaver
3.切换分支：
--git co slaver
4.合并分支：
--git mg slaver
5.删除分支：
--git br -d slaver
Blog creation time:[2017-09-05 二 08:06]
** DONE [#D] theme:开发模型										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1. 单人工作模型
2. 团队工作模型
2-1 金字塔版本控制模型：发布Linux
--最终版本库；  ---> Fedora 25发行版
--有一个权威贡献者的版本库（linus）
--有几个核心贡献者的版本库（Kernel、Samba、KDE、Gnome）
--有若干开发者（37人）的版本库（10个人负责开发Kernel、6个人负责开发Samba、
  12个人负责开发KDE、9个人负责开发Gnome）

特点：
--每个贡献者的版本库都是平等的；
--用于版本控制的模型；

2-2金字塔版开发模型：开发Samba
2-2-1服务器端，主分支master;   ---> Samba 3.4.1
1.不允许在master分支上干活，所以该分支不属于某一个成员，应当找一个牛来管理
（合并分支）master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有slaver分支对它有写权限，即，只有slaver分支才能向它合并代码；
3.所有分支对它都有读权限；
4.这个分支是非常稳定的，可以作为产品的。

2-2-2服务器端，开发分支（slaver）
1.这个开发分支用于干活，但是该分支也不属于某一个成员，应当找一个牛来管理（合并分支）
  master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有核心开发分支（A、B、C、D）才对它有写权限，即，只有核心开发者才能向
  slaver分支合并代码；
3.只有核心开发分支（A、B、C、D）才对它有读权限
4.这个分支是不稳定的，找来管理它的牛在充分测试后时不时把它作为版本合并
  到master分支上即可。

2-2-3服务器端，核心开发者的开发分支（A、B、C、D）
1.这四个分支的所有者可以在属于自己的分支上干活，并且时不时向slaver分支合并代码
  并且，接受
2.向slaver合并代码，
  
--有若干开发者（37人）的开发分支（其中10个人只能）

特点：
-每个开发者的版本库都是平等的；
--用于版本开发的模型；

个人也必须有一个master分支和slaver分支，其中，slaver分支用于自己干活，master
分支主要用于三个方面：向上级分支推送代码，接受别人代码的合并，接受自己在slaver分支
上的代码的合并
Blog creation time:[2017-09-05 二 08:07]
** DONE [#D] theme:场景分析										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
*** 场景分析
	场景一：工作备份
	Blog creation time:[2017-09-05 二 08:08]
