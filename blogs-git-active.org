* blogs-git-active
** DONE [#D] theme:我的工具网站									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
--git 官方网站：http://git-scm.com
--廖雪锋：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
Blog creation time:[2017-09-05 二 08:01]
** WAITTING [#D] Theme:基本概念								 :@Blog:@Git:
    SCHEDULED:<2017-09-23 六>
1. 工作区：一个等待进行版本控制的文件夹
2. 版本库：当使用git init对一个工作区进行初始化之后，在工作区下产生一个名为.git的文件夹，该文件夹称为该工作区的版本库
4. 原理：
   
   1. 待管理的文件位于工作区下面
   2. 使用git add .将工作区内的所有文件添加至版本库里面的暂存区中，接受版本控制
   3. 
5. 正确使用版本控制系统的方法是：一次提交只完成一件事
   1. 或是完成一个新功能
   2. 或是修改一个bug
   3. 或是写完一节内容
   4. 或是添加一副图片
   5. 注意：不要在下班才想起进行一次提交，那样的话git就降格成文件备份系统了
Blog creation time:[2017-09-23 六 22:36]
** WAITTING [#D] Theme:版本库workspace/.git/里面有什么？		 :@Blog:@Git:
    SCHEDULED:<2017-09-26 二>
1. index:
   1. 该文件是一个二进制文件,本质上，是一个包含文件索引的目录树
   2. 使用git add xx-file之后，xx-file这个文件的文件名将会挂接在index这个文件的目录树上
   3. 然而，xx-file这个文件的实际内容并没有存储在index这个文件中，而是存储在.git/objects目录这个对象库中
   4. index中xx-file这个文件的索引和对象库.git/objects中xx-file这个文件的实体建立起对应关系
   5. index的真实面目：所有加入版本库的文件形成目录树；目录树上挂接着接受版本控制的文件（其中，每个挂接的文件主要提供三部分信息：第一，该文件的文件名；第二，该文件的文件大小，第三，最近一次使用扫描工作区改动的命令(如git status,git diff等)时，所扫描到的文件的最新的时间戳）；目录树同对象库中相应的文件形成对应
2. objects/:
   1. 使用git add xx-file将xx-file文件加入到版本库之后，文件名，大小，时间戳等信息登记在index文件的目录树上，xx-file文件内部的真实内容则存储在.git/object/这个对象库中
   2. 对象库.git/object/中的文件同index中的目录树有着对应关系(我猜想，index中的目录树好比一个指针链表，每一个节点下存放指针类型的文件名，指向对象库中的对应文件)
3. branches/
4. HEAD
5. config
6. hooks/
7. info/
8. refs
9. packed-refs
10. description
11. logs/

Blog creation time:[2017-09-26 二 08:42]
** WAITTING [#D] Theme:版本库的基本原理						   :@Blog:@Emacs:
    SCHEDULED:<2017-09-25 一>
1. 扫描工作区的改动
   1. 执行git status 或者 git diff 命令时，将触发扫描工作区改动这一行为
   2. 取版本库.git/index中记录的文件名和时间戳，以及文件的长度，依据文件名，找到工作区内与之对应的文件，对比时间戳
   3. 若，发现，该文件在工作区中的当前时间戳与该文件在版本库中记录的时间戳不一致，则，判定为文件内容可能发生了改变，注意了，是可能改变而并非一定发生了改变，例如，你打开了一个文件，删除了一个字符，又重新输入该字符，此时，该文件的时间戳一定会更新的，因为你操作了文件，可是呢，内容却没有发生改变
   4. 此时，会打开该文件名对应的，在工作区中和在版本库中的该文件，两者进行比较(注意了，git管理的是修改而不是文件，所以该文件在版本库中不是同在工作区中一样的格式，这里暂且这么理解也没什么问题，因为更细致且复杂的工作由git这个系统的代码所承担了)，从而进一步进行判断该文件的内容是否真的发生了改变
   5. 如果该文件的内容没有发生改变，则将该文件的当前时间戳替换.git/index中该文件较老的那个时间戳
2. 将工作区中的文件添加至版本库
   1. 执行git add xx-file命令时，发生了两件事，第一，xx-file文件名被挂接到index文件的目录树上面；第二，xx-file文件内容被写入到对象库.git/objects/中
Blog creation time:[2017-09-25 一 16:57]

** DONE [#D] theme:命令 										 :@Blog:@Git:
1. 安装
   - 检查是否安装：dpkg -s git
   - 安装： sudo apt-get install git
   - 查看版本： git --version
2. 配置
   1. 单一版本库的配置：workspace/.git/config
	  1. 打开并编辑：git config -e
	  2. ...
   2. 全局配置：～/.gitconfig
	  1. 打开并编辑：git config -e --global
	  2. 配置标识
		 - 用户标识：git config --global user.name "linjiajun"
		 - 用户邮件：git congih --global user.email "ytulinjiajun@163"
		 - 标识的意义：指出 提交者 的身份， 标识是非常重要的，没有标识，git便没法识别提交者的身份
		 - 标识适合设置在全局文件中，因为全局文件存在于用户家目录下面，这样便同linux的多用户属性一致，当然了，也可以配置在版本库文件中
      3. 开启颜色显示：
	     - git config --global color.ui true
   3. 系统级配置：/etc/gitconfig
	  1. 打开并编辑：git config -e --system
	  2. 配置别名
	     - git config --system alias.sta status
	     - git config --system alias.ci commit
	  	 - git config --system alias.co checkout
	  	 - git config --system alias.br branch
   4. 读取某一配置项的值
	  1. git config core.bare
	  2. git config --global user.name
	  3. git config --system alias.sta
   5. 更改某一配置项的值
	  1. git config core.bare true
	  2. git config --global user.name ljj
	  3. git config --system alias.sta status
   6. 删除某一配置项：
	  1. git config --unset core.bare
	  2. git config --unset --global user.name
	  3. git config --unset --system alias.sta
   7. 直接使用配置文件
      - git完毕后立即可以使用的一个指令是:clone
      - 将自己保存在github上的配置文件clone到～目录下面:git clone git@github.com:xxx/.gitconfig
   8. 配置文件的格式：INI文件格式
   9. 优先级:版本库 > 全局 > 系统，高优先级的文件中的配置可以覆盖低优先级文件中的配置
   10. git config命令可以操作任何其他的INI文件
	   1. 读取配置文件test.ini中的配置：$ GIT_CONFIG=test.ini  git config a.b.c.d
	   2. 向配置文件test.ini中写配置：$ GIT_CONFIG=test.ini  git config a.b.c.d "hello world"
3. 操作
   1. 创建版本库
      1. git init: 其结果是在工作区中生成版本库：.git/
	  2. git rev-parse --git-dir: 该操作可以在工作区的任何子目录下执行，其结果是显示该工作区的版本库的路径
	  3. git rev-parse --show-toplevel: 该操作可以在工作区的任何子目录下执行，其结果是显示该版本控制系统的根路径
	  4. git rev_parse --show-prefix: 该操作可以在工作区的任何子目录下执行，其结果是显示相对于该版本控制系统的根路径的相对目录
	  5. git rev_parse --show-cdup: 该操作可以在工作区的任何子目录下执行，其结果是显示当前目录回退到版本控制系统根的深度
   2. 删除版本库
   3. 查看工作区内的文件状态
   4. 添加工作区文件至版本库的暂存区
	  1. 工作区和暂存区中文件的状态
		 1. 工作区性质的文件： 从未使用git add xx-file登记过的文件，又称 未跟踪的文件
		 2. 暂存区性质的文件： 曾使用过git add xx-file登记过的文件
			1. 自从使用git add xx-file登记过以后就再没对xx-file进行过：修改，删除，
		 3. 工作区性质的文件的状态：未被跟踪的文件(Untracted files)
		 4. 版本库文件
	  2. git add .:
		 1. 
	  3. git add -u
	     1. 工作区中的所有文件中，那些文件状态为tracked的文件，即，已经加入到.git这个版本库中管理的文件，当其文件状态发生改变时，该指令会处理这类文件的改变
		 2. 该指令不会去处理工作区中，那些untracked的文件，比如，新建的文件
	  4. git add -A: 将本地对文件的删除的新增登记到暂存区
   5. 回滚版本库暂存区的文件至工作区
   6. 提交暂存区的文件至本地分支
   7. 回滚本地分支文件至暂存区
   8. 回滚本地分支文件至工作区
   9. 修补最新提交的提交说明
	  1. 命令：git commit --amend
   10. 修补历史提交的提交说明
	   1. 变基操作： git rebase -i <commit-id>^
   11. 文件差异性比较
	   1. 标准的diff和patch存在一个局限：无法对二进制文件进行处理
	   2. git对二进制文件的比较提供了支持：git diff
	   3. git diff命令使用的是标准diff中的合并模式(unified mode)的语法格式，相当于diff -u
	   4. 
4. 日志
   1. git log --pretty=fuller
	  commit ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD)
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 20:17:49 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 20:17:49 2017 +0800
	  
	  -----
	  
	  commit 8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 19:35:59 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 19:35:59 2017 +0800
   2. git log --pretty=online
      ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD) -----
	  8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345 -----
	  228e998f2b5b1936fbd90f2441bf610d689caee1 -----
	  58c9b9ed50b28b4e47302dbc4248686d9e835f27 evil-mode
	  f9f1d307bb08c94f78e0714998759c1515e0f027 -----
	  34b45e97083e705d98900aaa8ec9692bc27e89eb -----
	  21c290a0cdebe3bebaff7148a5f69e4399a5ecc3 -----
	  915cd2a2564a5b8a942301de31b993d0f6ec2636 -----
   3. git log --stat
	  commit ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD)
	  Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Fri Sep 22 20:17:49 2017 +0800
	  
      -----
	  
      evil/config-evil-mode.el | 14 ++++++++++++++
      1 file changed, 14 insertions(+)
	  
	  commit 8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345
	  Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Fri Sep 22 19:35:59 2017 +0800
	  
	  -----
	  
	  evil/config-evil-nerd-commenter.el  |  4 ++++
	  evil/config-evil-surround-plugin.el | 10 ++++++++++
	  2 files changed, 14 insertions(+)
5. 创建.gitignore文件：该文件里面记录着该仓库里面不想接受版本控制的文件及目录
   Blog creation time:[2017-09-05 二 08:02]
** DONE [#D] theme:安装git										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
	Blog creation time:[2017-09-05 二 08:03]
** DONE [#D] theme:配置git										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1.设置 git 的user . name 和 user . email:
    git config --global user.name "linjiajun" ;
    git config --global  user.email "ytulinjiajun@163.com" ;
备注：这两个配置项会出现在git的配置文件中，当提交一个版本时，会从配置文件中取出这个信息，
若不配置这两个选项，则版本信息中会出现错误的提交者信息;

2.生成SSH秘钥：
生成：ssh-keygen -t rsa -C "ytulinjiajun@163.com"
其中：-t  用于指定加密类型，常见的有RSA和DSA加密方式，默认是DSA;
-C 作为批注
三次回车，按默认路径.ssh以及不需要密码安装即可

3.在GitHub上添加密钥：
Account Setting -> SSH Key -> Add SSH Key ;
复制~/.ssh/ssh-ras 的内容到 key 区域

4.验证SSH配置是否成功：
ssh -T git@github.com
Hi username! You've successfully authenticated ,but GitHub does not # provide shell access 

5.创建一个本地版本库：
git init

6.关联远程库：
git rmt git@github.com:ytulinjiajun/GitHub-Lin.git

6.从github克隆一个版本库验证SSH配置是否成功：

git clone git@github.com:ytulinjiajun/GitHub-Lin.git@github

7.配置别名：
方法一：使用命令
git config --global alias.sta status
方法二：修改配置文件
配置文件路径：～/.gitconfig
[alias]
	sta = status
	ci = commit
	rmt = remote add origin
	ps = push origin 
	co = checkout
	br = branch
	mg = merge --no-ff 
	unstage = reset HEAD
	rmt =  remote add origin 
	cl =  clone 
	lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
Blog creation time:[2017-09-05 二 08:04]
** DONE [#D] theme:创建版本库									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
--在指定位置新建一个目录：mkdir git-learn
--进入该目录：cd git-learn
--执行：git init
备注：也可以不进入该目录，直接输入：git init git-learn

--执行ls -al 可以发现：.git,这就是我们创建的版本库
--称git-learn为工作区，.git为版本库
Blog creation time:[2017-09-05 二 08:05]
** DONE [#D] theme:操作版本库									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1.原则
--正确使用版本控制系统的方法是，一次提交只完成一件事
--只有git commit才会产生版本，这意味着可以多次使用add文件到暂存区，提交版本时
  只会commit最新版？
--使用git push只会将本地众多版本中HEAD指向的版本推送到服务器？这意味着可以多
  次commit文件到本地版本库

2.查询操作
--查询当前git的版本：git --version
--查看某个版本号下面的文件内容：
--查询版本库的分支数：
--查询该仓库对应的远程仓库：
--查询日志：

3.基本操作
3-1 git status：
--包含三块信息：当前位于哪个分支、文件发生了哪些行为、目前可以执行哪些指令处理问题
-当前位于哪个分支：默认 on branch master
-文件发生了哪些行为：
1.Nothing to commit(working directory clean):干净的工作区
2.Untracked files:工作区内未被git管理的文件
3.Change not staged for commit:工作区内已经被git管理的文件发生了某些行为
4.Change to be commited:暂存区内有待提交的文件
-目前可以执行哪些指令处理问题：
1.Untracked files：可以add到暂存区给git管理，也可以放到.gitignore中告诉git不用管理它
2.

3-2 git add： 
--该操作的结果是：将工作区内的发生的行为同步到暂存区（unstage）
--注意：

4.未解决的疑惑
--在本地执行commit后，git status操作给出下面提示：
Your branch is based on 'origin/master', but the upstream is gone.
  (use "git branch --unset-upstream" to fixup)
Blog creation time:[2017-09-05 二 08:06]
** DONE [#D] theme:分支管理										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1.查看分支
--git br 
2.创建分支：
--git br slaver
3.切换分支：
--git co slaver
4.合并分支：
--git mg slaver
5.删除分支：
--git br -d slaver
Blog creation time:[2017-09-05 二 08:06]
** DONE [#D] theme:开发模型										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1. 单人工作模型
2. 团队工作模型
2-1 金字塔版本控制模型：发布Linux
--最终版本库；  ---> Fedora 25发行版
--有一个权威贡献者的版本库（linus）
--有几个核心贡献者的版本库（Kernel、Samba、KDE、Gnome）
--有若干开发者（37人）的版本库（10个人负责开发Kernel、6个人负责开发Samba、
  12个人负责开发KDE、9个人负责开发Gnome）

特点：
--每个贡献者的版本库都是平等的；
--用于版本控制的模型；

2-2金字塔版开发模型：开发Samba
2-2-1服务器端，主分支master;   ---> Samba 3.4.1
1.不允许在master分支上干活，所以该分支不属于某一个成员，应当找一个牛来管理
（合并分支）master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有slaver分支对它有写权限，即，只有slaver分支才能向它合并代码；
3.所有分支对它都有读权限；
4.这个分支是非常稳定的，可以作为产品的。

2-2-2服务器端，开发分支（slaver）
1.这个开发分支用于干活，但是该分支也不属于某一个成员，应当找一个牛来管理（合并分支）
  master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有核心开发分支（A、B、C、D）才对它有写权限，即，只有核心开发者才能向
  slaver分支合并代码；
3.只有核心开发分支（A、B、C、D）才对它有读权限
4.这个分支是不稳定的，找来管理它的牛在充分测试后时不时把它作为版本合并
  到master分支上即可。

2-2-3服务器端，核心开发者的开发分支（A、B、C、D）
1.这四个分支的所有者可以在属于自己的分支上干活，并且时不时向slaver分支合并代码
  并且，接受
2.向slaver合并代码，
  
--有若干开发者（37人）的开发分支（其中10个人只能）

特点：
-每个开发者的版本库都是平等的；
--用于版本开发的模型；

个人也必须有一个master分支和slaver分支，其中，slaver分支用于自己干活，master
分支主要用于三个方面：向上级分支推送代码，接受别人代码的合并，接受自己在slaver分支
上的代码的合并
Blog creation time:[2017-09-05 二 08:07]
** DONE [#D] theme:场景分析										 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
*** 场景分析
	场景一：工作备份
	Blog creation time:[2017-09-05 二 08:08]
