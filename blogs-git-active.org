* blogs-git-active
** DONE [#D] theme:我的工具网站									 :@Blog:@Git:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
1. git 官方网站：http://git-scm.com
2. 廖雪锋：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000
   Blog creation time:[2017-09-05 二 08:01]
** WAITTING [#D] Theme:基本概念								 :@Blog:@Git:
   SCHEDULED:<2017-09-23 六>
1. 工作区：一个等待进行版本控制的目标目录
2. 版本库：当使用git init对一个工作区进行初始化之后，在工作区下产生一个名为.git的文件夹，该文件夹就称为版本库
3. 正确使用版本控制系统的方法是：一次提交只完成一件事
   1. 或是完成一个新功能
   2. 或是修改一个bug
   3. 或是写完一节内容
   4. 或是添加一副图片
   5. 注意：不要在下班才想起进行一次提交，那样的话git就降格成文件备份系统了
4. 环节
   1. 工作区  ----(1)--->  暂存区
   2. 暂存区  ----(2)--->  分支
   3. 工作区  ----(3)--->  分支
   4. 暂存区  ----(4)--->  工作区
   5. 分支    ----(5)--->  暂存区
   6. 分支    ----(6)--->  工作区 　
   7. 研究清楚，标编号上面6个环节中：单个文件的传递，所有文件传递，的相关操作方法，git的知识点就全了
5. 版本库干净： 当工作区 = 暂存区 = 对象库（最新）提交 ===> 版本库干净（使用git status无任何状态）
6. 思维逻辑: 从树形结构看版本库
   1. 错误的思维: 开发从树的根部到枝干进行.你可能会在想创建分支的过程:
	  1. 开发成员1,以master分支上的第1次提交,作为branch1分支的分支起点,在该分支上产生若干提交,形成第一个分支
	  2. 开发成员2,以master分支上的第1次提交,作为branch2分支的分支起点,在该分支上产生若干提交,形成第二个分支
	  3. 开发成员3,以master分支上的第1次提交,作为branch3分支的分支起点,在该分支上产生若干提交,形成第三个分支
	  4. ......
	  5. 开发成员n,以master分支上的第1次提交,作为branchn分支的分支起点,在该分支上产生若干提交,形成第n个分支
	  6. 结论: 版本库是从根到枝干的开发! 但是,不好意思,这个结论是错的
   2. 正确的思维: 开发从树的枝干到根部进行
      1. 根,可以看做系统的输出,即最终版本,枝干可以看成系统的输入,即各个分支的提交,开发的目的是为了得到根
	  2. 其实上面错误思维里面的所谓的根只是一个"假根",通常master分支上的第一次提交只是一个工程项目的基础设施而已,而并非结果
	  3. 项目的发起者在master分支上提交了一次该项目的"基础设施",该提交只包含了一些必备的初始化,驱动等等,相当于kernal
	  4. 项目的参与者以master分支上的第一次提交为分支起点,创建只属于自己的分支,所以一开始,每个参与者获得相同的"原料"
	  5. 项目的发起者自己想要开发,也需要以master创建一个自己的分支,比如master-manager,只有它才有权限在master生成根
	  6. 每个参与者在自己的分支上做属于自己模块的开发,然后不断向master-manager分支合并,master-manger认为开发的差不多了,可以生成第二个版本(根)的 时候,他会向master合并
Blog creation time:[2017-09-23 六 22:36]
** WAITTING [#D] Theme:对象库解析 								 :@Blog:@Git:
   SCHEDULED:<2017-09-26 二>
1. index:
   1. 该文件是一个二进制文件,本质上，是一个包含文件索引的目录树
   2. 使用git add xx-file之后，xx-file这个文件的文件名将会挂接在index这个文件的目录树上
   3. 然而，xx-file这个文件的实际内容并没有存储在index这个文件中，而是存储在.git/objects目录这个对象库中
   4. index中xx-file这个文件的索引和对象库.git/objects中xx-file这个文件的实体建立起对应关系
   5. index的真实面目：所有加入版本库的文件形成目录树；目录树上挂接着接受版本控制的文件（其中，每个挂接的文件主要提供三部分信息：第一，该文件的文件名；第二，该文件的文件大小，第三，最近一次使用扫描工作区改动的命令(如git status,git diff等)时，所扫描到的文件的最新的时间戳）；目录树同对象库中相应的文件形成对应
2. objects/:
   1. 使用git add xx-file将xx-file文件加入到版本库之后，文件名，大小，时间戳等信息登记在index文件的目录树上，xx-file文件内部的真实内容则存储在.git/object/这个对象库中
   2. 对象库.git/object/中的文件同index中的目录树有着对应关系(我猜想，index中的目录树好比一个指针链表，每一个节点下存放指针类型的文件名，指向对象库中的对应文件)
3. branches/
4. HEAD
5. config
6. hooks/
7. info/
8. refs
9. packed-refs
10. description
11. logs/
12. 对象库解析
	1. 对象库.git/obj/ ： 直观图解参看《git权威指南p87》
	   1. 对象库的本质一个双向链表，当前分支(比如master)是该链表的头指针,HEAD则是指向头指针的指针
	   2. 该链表的结点是一个又一个的commit，当前分支(比如master)可以在这些commit结点前后来回移动
	   3. 结点的指针域的值是commit类型的ID，该双向链表的就是通过这些ID值组织起来的
	   4. 结点的数据域由三部分构成：tree类型的ID,parent类型的ID,用户标识
		  1. tree类型是一个结构体类型,其成员是blob类型的指针，blob类型可以理解为文件类型，所以这些blob类型的指针就指向真正的文件
		  2. 每个blob类型的文件均有一个ID
	2. 寻址ID：git cat-file -p ID
	   1. ID值总是一个指针类型，要么指向commit结点，要么指向tree类型的结构体，要么指向blob类型的文件
	   2. 我们总可以使用:git cat-file -p ID,来解析指针ID的值,取得该指针下的值
	   3. 常规步骤是先使用git lg查看commit类型的ID,然后通过该ID就能逐一解析出tree类型的ID以及blobn类型的ID
	3. 查看对象库中文件内容
	   1. 查看当前分支对应的提交内容：git cat-file commit HEAD
	   2. 查看指定分支(比如master)对应的提交: git cat-file commit master
	   3. 查看当前分支下某文件的内容: git cat-file blob HEAD:<TAB补全>
	   4. 查看指定分支(比如master)下某文件的内容： git cat-file blob master:<TAB补全>
	4. 获取ID类型：git cat-file -t ID
	   1. 从上面对象库的分析中可以知道，git提供了如下3种类型的ID，对于给定ID，使用git cat-file -t ID，来了解该ID的类型
	   2. commit: 使用git lg查看到的ID就是commit类型的ID
	   3. tree:  
	   4. blob:
	5. 获取,分支以及HEAD，的ID: git rev-parse master;  git rev_parse HEAD
	6. HEAD,master,^,~的关系
	   1. HEAD指向当前分支，所以，HEAD就理解为当前分支
	   2. 分支是对象库的头指针，所以分支指向对象库的最新提交
	   3. master属于分支，是分支里面比较特殊的一个分支，称为主分支
	   4. 当且仅当存在master分支时，HAED自然就指向master
	   5. HEAD～n,指向当前分支，最新提交的第n个父提交，HEAD~1 等价于 HEAD^
Blog creation time:[2017-09-26 二 08:42]
** DONE [#D] Theme:安装 										 :@Blog:@Git:
1. 检查是否安装：dpkg -s git
2. 安装： sudo apt-get install git
3. 查看版本： git --version
Blog creation time:[2017-09-05 二 08:03]
** DONE [#D] Theme:配置 										 :@Blog:@Git:
1. 本地配置：　git config -e
   1. 配置文件路径：workspace/.git/config
   2. 作用域：该文件下的配置，只在该workspace／中有效
   3. 优先级：最高
2. 全局配置：　git config --global -e
   1. 配置文件路径：　~/.gitconfig　
   2. 作用域：该文件下的配置，对当前用户的所有的版本库均有效
   3. 优先级：高于系统配置，低于全局配置
   4. 用户标识配置：git config --global user.name "linjiajun"
   5. 用户邮件配置：git config --global user.email "ytulinjiajun@163"
   6. 开启颜色显示：git config --global color.ui true
   7. 说明：用户标识和用户邮件必须进行配置，因为git会使用到这两个信息来标识提交者身份
3. 系统配置：　git config --system -e
   1. 配置文件路径：　/etc/gitconfig
   2. 作用域：该文件下的配置，对所有用户的所有版本库均有效
   3. 优先级：最低
   4. 配置别名：git config --system alias.sta status
4. 读取配置：　git config --global user.name 回车
5. 更改配置：　git config --system alias.co checkout
6. 删除配置：　git config --unset core.bare
7. 备注： 建议将配置文件上传到github,用到时直接clone到指定路径即可！
** DONE [#D] Theme:SSH											  :Blog:@Git:
1. 生成SSH秘钥： ssh-keygen -t rsa -C "ytulinjiajun@163.com"
   1. -t  用于指定加密类型，常见的有RSA和DSA加密方式，默认是DSA;
   2. -C 作为批注
   3. 三次回车，按默认路径.ssh以及不需要密码安装即可
2. 在Github上添加密钥： Account Setting -> SSH Key -> Add SSH Key
   复制~/.ssh/ssh-ras 的内容到 key 区域
3. 验证SSH配置是否成功： ssh -T git@github.com
   Hi username! You've successfully authenticated ,but GitHub does not provide shell access
5. 创建一个本地版本库： git init
6. 关联远程库： git rmt git@github.com:ytulinjiajun/GitHub-Lin.git
6. 从github克隆一个版本库验证SSH配置是否成功：git clone git@github.com:ytulinjiajun/GitHub-Lin.git
Blog creation time:[2017-09-05 二 08:04]
** WAITTING [#D] Theme:搭建git服务器							 :@Blog:@Git:
   SCHEDULED:<2017-10-09 一>
1. 基于标准的SSH搭建git服务器
   1. 服务器管理员在服务器上创建一个账号:git-server,专门用于git开发
   2. 客户端用户自己生成公钥和私钥: ssh-keygen -t rsa -C "ytulinjiajun@163.com" -f ~/.ssh/github
	  1. 在实际运用中,一个客户端用户可能需要使用多套秘钥对,如github使用一套,自己搭建的ssh-server需要一套
	  2. -f用于定制生成的秘钥的名字为一个有意义的名,如github.pub,而不是简单的id_ras.pub之类的
   3. 服务器管理员收集各个客户端用户的公钥,放在key/下面
   4. 将这些客户端的公钥/key/*依次添加进服务器/home/git-server/.ssh/authorized_keys文件内部
	  1. 方法一:直接在服务器上使用git-server账号操作: cat key/user1.pub >> ~/.ssh/authorized_keys
	  2. 方法二:远程操作: ssh-copy-id -i user1.pub@192.168.19.10 (效果同方法一样)
	  3. 备注: 这意味着任何人只要只要被服务器管理员执行过上面的免密码登录的操作后,这个人也可以让别人免密码,这意味着git-server是一个公开的服务器
   5. 测试4是否成功: ssh git-server@192.168.19.10,如果不需要密码即可登录表示配置成功
   6. 客户端新建配置文件:~/.ssh/config
	  1. 作用: 上面的2给出,客户端可以生成多套秘钥对,那么,执行登录指令时,计算机如何知道要使用哪个公钥呢?该配置主要就解决该问题
	  2. 新建~/.ssh/config,并写入配置
		 #+BEGIN_SRC 
		 host git-lin-server     # 相当于一个代号,登录时使用该代号即可加载该代号下面的配置
		   user git-server  # 远程服务器上专门用于git的用户
           hostname 192.168.19.10 # 远程服务的ip地址
           port 22  # 远程服务器ssh服务使用的端口号
           identityfile ~/.ssh/git-server-key  # git-lin使用哪个公钥
		 #+END_SRC
   7. ssh登录: ssh git-lin-server
   8. 执行git命令
	  1. git clone git-lin-github:ytulinjiajun/emacs.d.git
2. 基于Gitlite搭建git服务器
   1. 相关网址:
	  1. gitolite官方源代码:  http://github.com/sitaramc/gitolite
	  2. 官方学习文档(英文): http://gitolite.com/gitolite/
	  3. gitolite官方推荐资料(中文):https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-Gitolite
   2. Gitolite介绍:
	  1. gitolit是一款Perl语言开发的Git服务管理工具
	  2. gitolite的设计灵感来源于Gitosis,目前其功能已经超过Gitosis
	  3. gitolite提供两个功能: 身份认证; 权限控制
	  4. git本身不提供权限控制,当搭建完毕标准SSH服务器之后,而在团队开发中就会出现,任何人能对任何版本库执行任何操作,在团队开发中,这样的情况是非常糟糕的
	  5. git没有提供身份认证和权限控制的功能,而基于SSH的gitolite正是针对这一需求而设计,从某种意义上弥补了git的不足
	  6. gitolite在安装过程中,会指定一个gitolite管理员(提供该用户在客户端的秘钥),之后在git账号的家目录下的repositories/下生成一个名为gitolite-admin.git的版本库
	  7. gitolite-admin.git版本库只能被gitolite管理员所clone和push
	  8. gitolite管理员在客户端执行: git clone git@server:gitolite-admin.git,在本地得到一个名为gitolite-admin的仓库(和服务器上的gitolite-admin.git内容不同)
	  9. gitolite管理员clone到本地的gitolite-admin仓库里面有一个config/和keydir/,前者用于实现权限控制,后者用于实现身份认证
	  10. gitolite-admin/config/gitolite.conf,就是用于实现权限限制的配置文件,而gitolite-admin/keydir/下面则保存参与项目开发的程序员自己客户端上的公钥
	  11. gitolite针对config/gitolite.conf专门提供一套配置语法用于限制参与项目开发的所有程序员对repositories/下面的各个版本库中的分支,里程碑,文件,目录等的读,写权限
	  12. gitolite管理员将参与项目开发的所有程序员的公钥收集过来,重命令,然后放在gitolite-admin/keydir/下面,在该目录下面的程序员就能参与项目的开发中来
	  13. gitolite管理员在本地版本库gitolite-admin中执行: git push,将11,12中做的配置推送到服务器的gitolite-admin.git中,配置生效后,就能实现身份认证和权限限制的目的
	  14. 备注: 服务器git账号的密码只有gitolite管理员才知道, 在keydir/下面提交过公钥的程序员,无法直接使用ssh git@server的形式登录服务器的git账号来取得shell,但是却可以使用如push,pull等命令,至于reset或者git checkout等命令则需要依据config/gitolite.conf中的权限而定;不在keydir/下面提交过公钥的程序员,可以使用ssh git@server的形式登录服务器的git账号来取得shell,但是前提是,你得知道git账号的密码(只有gitolite管理员才有),这正是我们希望的结果
   3. Gitolite安装
      1. 建议参照源代码下面的README.markdown来进行操作 
	  2. 前提: 
         1. 事先安装了Git,且版本必须在1.6.6以上,且服务器要提供SSH服务
		 2. 事先安装了perl
		 3. 事先搭建好了SSH服务器,且该服务器的账号命名为git
	  3. 安装步骤: 由gitolite管理员来操作
	     1. 在服务器上创建一个用户账号: git
		 2. 在该账号的家目录下新建目录和文件: .ssh/authorized_keys
		 3. gitolite预备管理员在自己的客户端生成SSH秘钥对,然后使用sftp将生成的公钥gitolite-admin.pub 给 put 到服务器上
		 4. 登录到服务器(非远程),在家目录下面下载gitolite的源代码: git clone git@github.com:sitaramc/gitolite.git
		 5. 创建gitolite的安装路径: mkdir -p $HOME/bin
		 6. 安装: gitolite/install -to $HOME/bin
		 7. 指定gitolite的管理员: gitolite setup -pk $HOME/gitolite-admin.pub
		    1. 该操作之后 gitolite-admin.pub 这个公钥的所有者正式设置为 gitolite 的管理员
			2. 该操作会将 gitolite-admin.pub 添加至~/.ssh/authorized-keys中,这在标准SSH中意味着,该用户可以使用 ssh git@server 免密码直接远程登录服务器git账号
			3. 在这里,意味着: 第一,gitolite管理员再也无法使用ssh git@server 登录服务器的git账号取得shell了;
			4. 第二,gitolite是唯一一个可以使用git clone 将gitolite-admin.git 这个配置相关的版本库克隆到本地,修改,然后push上去使配置生效的人
			5. 当然了只有gitolite管理员才有gitolite-admin.git的读写和强制更新的权限是在gitolite-admin.git/config/gitolite.conf中配置的,也可以让其他人拥有此权限
		 8. 客户端登录配置: ~/.ssh/config
			1. 该配置在客户端完成,将ssh连接的参数配置在该文件中是一种非常好的习惯
			2. 该文件的identityfile特别重要,它指定了本次ssh连接使用哪个秘钥文件来进行认证,当.ssh/下面有多个*.pub存在时,该参数必须进行配置
			3. 配置说明:
			   #+BEGIN_SRC 
		       host gitolite-admin     # 相当于一个代号,登录时使用该代号即可加载该代号下面的配置
		       	 user git  # 远程服务器上专门用于git的用户账户
                 hostname 192.168.19.10 # 远程服务的ip地址
                 port 22  # 远程服务器ssh服务使用的端口号
                 identityfile ~/.ssh/gitolite-admin  # git-lin使用哪个公钥
		       #+END_SRC	 
		 9. 克隆gitolite-admin.git到本地: git clone git-server:gitolite-admin.git
		 10. 备注: 到此为止,gitolite已经在服务器上安装完毕,并且,还将服务器假设员的客户端账号设置为服务器上gitolite唯一的管理员
   4. Gitolite管理员的那些事: (本地完成)
	  1. 配置文件管理
		 1. 默认配置文件: gitolite-admin/conf/gitolite.conf
		 2. 扩展配置文件:
			1. 在gitolite.conf中加入语句: include "*.conf"
			2. 在gitolite-admin/conf/中新建配置文件repo-stm32.conf
			3. 在gitolite-admin/conf/中新建配置文件repo-qt.conf
			4. 在repo-stm32.conf中编写stm32这个仓库的配置
			5. 在repo-qt.conf中编写qt这个仓库的配置
			6. 将配置push服务器使之生效
		 3. 编写配置的原则: 宏观的配置(如组,管理员等)应当在gitolite.conf中完成,而仓库的配置应当扩展出来,在自己的配置文件中配置
		 4. 约定:
			1. 注释: #
			2. 组标识:
			   1. 管理员组: @admin = admin1 admin2 
			   2. 开发成员组: @developers = user1  user2  @team1
			   3. 仓库组: @repo-groups1 = repo1 repo2  ---  repo  @repo-groups1
			   4. all组:  指代所有成员,或者所有仓库(用在3时)
			   5. 对路径授权: RW NAME/ = user1
			   6. 对正则表达式引用授权: RW refs/... = user
			3. 仓库标识: repo repo-stm32
			4. 扩展配置文件: include "foo/bar.conf" 或者 include "*.conf"
		 5. 配置文件模板
            #+BEGIN_SRC
            @who-can-create-shared-repo = gitolite-admin ljj-test
         
            repo shared-repo/CREATOR/[a-z]..*
                 C       =   @who-can-create-shared-repo
                 RW+CD   =   CREATOR

            repo personal-repo/CREATOR/[a-z]..*
	             C       =   @all 
	        RW+CD   = CREATOR
            #+END_SRC            
	  2. 权限控制
		 1. 管理员组:
			1. 管理员组语法: @admin = admin1 admin2
			2. 管理员组的必要性: 一个人管理gitolite的所有仓库,可能会忙不过来,此时,可以设置多个gitolite管理员
			3. @admin: gitolite系统内建标识,代表管理员组,加入管理员组的用户具有gitolite管理员的权限
			4. @all: gitolite系统内建标识,代表所有用户
		 2. 用户组:
			1. 用户组语法: @team1 = devlp1 devlp2 @team3
			2. 用户组的必要性: gitolite是版本控制系统的权限管理工具,因此实际情况很可能是这样的:
			   1. 版本控制系统中有很多个独立的仓库A,B,C,D...
			   2. 项目的参与者均通过上面3介绍的新增用户的方法加入到 gitolite 体系中,项目参与者的除了gitolite-admin这个管理员之外,还有很多人,按编号为1,2,3,4...
			   3. 成员1既在仓库A中有任务分工,又在仓库B中有任务分工
			   4. 成员2只在仓库B中有任务
			   5. 成员3既在仓库A中有任务分工,又在仓库C中有任务分工
			   6. 成员4比较厉害,在仓库B,C,D中都有任务分工
			   7. 当仓库的数量趋向无穷多,项目参与者的数量趋向无穷多,则,仓库,项目参与者之间的关系就会变得非常复杂,因此,gitolite权限控制语法中提供分组的概念
			   8. (仓库A : 成员1 成员3), (仓库B : 成员2 成员4), (仓库C : 成员3 成员4), (仓库D : 成员4)
			3. 备注: 组可以嵌套,表示@team3中的所有用户都加入到用户组@team1中去
			4. 用户组的意义: 给出了仓库可研发人员的对应,为仓库里面的分支,里程碑,目录,文件和研发人员的对应做出宏观的铺垫
         3. 通配符仓库模块格式: repo subdir-repo-name/.+$ <回车+缩进> 授权指令 
			1. repo: gitolite系统内建关键字,用来标识仓库
			2. subdir-repo-name/:位于服务器git账号家目录~/repositories/下的一个子目录
			3. .+$: 正则表达式,表示所有仓库
			4. <回车+缩进>: 配置文件格式所要求
			5. 授权指令: 稍后再叙
			6. 备注: 想要使用通配符仓库模块,需要在服务器git账户家目录下面的.gitolite.rc中添加语句: $GL_WILDREPOS = 1;
			7. 说明: 通配符仓库语法定义了一组仓库的规则,该语法使用正则表达式匹配一组仓库而不是特指某个具体的仓库
			8. 作用: 通配符仓库模块主要用于配置多个仓库的共性配置,个性配置则通过单个仓库配置模块的语法来实现
         4. 单个仓库模块格式: repo repo-name <回车+缩进> 授权指令
			1. repo: gitolite系统内建关键字,用来标识仓库
			2. repo-name: 服务器git账户家目录中(~/repositories/*.git)的一个具体的仓库,以服务器的~/repositories/作为根
			3. <回车+缩进>: 配置文件格式所要求
			4. 授权指令: 稍后再叙
			5. 9. 仓库的意义: 用户组的配置给出了仓库和研发人员对应关系,而仓库的配置给出了仓库和研发人员对应关系的具体实现
			6. 仓库是gitolite系统进行权限控制的基本对象
			7. 2. 注意: 在配置某个用户在该仓库中的权限之前,应当先配置该用户的用户组
		 5. 仓库的授权指令格式: <权限> [零个或多个正则表达式的匹配,或者引用] = <user> [<user> ...]
			1. 授权的两个阶段
			   1. 第一阶段: gl-auth-command检查
				  1. 读权限检查: 检查是否具有R, RW, RW+之一,如果有,则指定的用户对整个仓库(包含分支)均可读
				  2. 写权限检查: 检查是否具有RW,RW+,C之一,若果有,则通过第一阶段的写权限检查,准备第二阶段的写权限检查
				  3. 创建权限检查: 检查通配符仓库模块中,是否具有C权限,如果有,则指定用户可以 创建,读,写 和正则表达式匹配的仓库
			   2. 第二阶段: update钩子脚本检查
				  1. 写权限检查: 针对推送的操作的各分支, 精细的进行逐一检查是否具有写权限,若果有,则进行写授权
				  2. 基于路径的写授权也是发生在这个阶段
            2. 权限语法:
			   1. gitolite的权限语法的判定方式
			      1. 传统模式: 只采用 R,RW,RW+,- 关键字的授权,判定为传统模式的授权
			      2. 扩展模式: 在<权限>中出现: RWC, RW+C, RWD, RW+D, RWCD, RW+CD 之一的,则判定为扩展模式授权
				  3. 备注: 扩展模式能够使用更加精细的授权,因此,建议使用扩展模式的授权,下面的讲解也是基于扩展模式授权
		       2. 独立描述: C, D, M, R, W, +, - 
			      1. -: 不允许有任何权限
			      2. R: 决定允许允许有:访问,clone,fetch的权限
			      3. W: 决定是否允许有push的权限
			      4. C: 决定是否允许有创建ref的权限
			      5. D: 决定是否允许有删除ref的权限
			      6. M: 决定是否允许有拒绝包含了 merge commit 的 commit sequence的权限 (即只接受直线序列的提交,不接受合并提交.该功能很少使用)
			   3. 实际使用(见表): -, R, RW, RW+, RWC,RW+C, RWD, RW+D, RWCD, RW+CD
			3. [零个或多个,正则表达式的匹配,或者引用]
			   1. 你不可能对用户将要push的所有可能的branch和tag名写规则,唯一明智的方法就是使用正则表达式
			   2. 如果没有在授权指令中提供该选项,则相当于提供refs/.*作为引用参数
			   3. gitolite中使用到的正则表达式源字符
				  1. [asdf]: 依次拿[]中的字符, 去逐字符匹配目标文件,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
                     1. 示例: grep -n 'a[df]g' a.txt
	                 2. 解释: 在a.txt中,所有存在adg和afg的行都会被匹配,然后以带行号的形式,将这些行输出
				  2. ess*: 依次拿着 es,ess,esss ... 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	                 1. 重点: * 代表可以重复*前面的字符s任意次数(0次,1次...),上面的es是重复0次时匹配到的,注意,e不能被匹配
                     2. 示例: grep -n 'es*' a.txt
	                 3. 解释: 在a.txt中,所有存在e,es,ess,esss...的行都会被匹配,然后以带行号的形式,将这些行输出
				  3. e.e : 在目标文件中, 匹配 'e任何单个字符e',  若匹配成功,,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	                 1. 重点: 点 . 有且仅有单个字符,注意了,一定有一个字符,而且仅仅只有一个字符 edfe是不会匹配的
	                 2. 示例: grep -n 'o.o' a.txt
	                 3. 解释: 在a.txt中,所有存在o字符o的行都会被匹配,然后以带行号的形式,将这些行输出
                  4. ess+: 依次拿着 ess,esss ... 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	                 1. 重点: + 代表可以重复+前面的字符s大于等于1次(1次,2次...),上面的ess是重复1次时匹配到的,注意,es不能被匹配
				  5. $asdf: 拿着整个 'asdf' , 去和目标文件匹配, 若匹配成功,而恰好 asdf  又在串的结束位置(在grep中,结束位置定义为行尾),则满足该范式;
                     1. 示例: grep -n '$!' a.txt
	                 2. 解释: 在a.txt中,所有以!结尾的行都会被匹配,然后以带行号的形式,将这些行输出
			4. <user> [<user> ...]
	  3. 新增用户:
		 1. gitolite管理员从参与项目的开发者那些收集公钥,并将公钥按照ytulinjiajun@163.com.pub的方式统一命令
		 2. 将统一命名之后的公钥拷贝到keydir中
		 3. 将新增的公钥文件添加进版本库: git add keydir
		 4. 提交新增修改: git commit -m "add user: dev1 dev2 dev3"
		 5. 同步到服务器,完成用户添加: git push
		 6. 执行完毕push操作之后,将会发现在服务器的git账户的~/.ssh/authorized_keys中追加了新增用户的公钥
		 7. 这意味着该用户加入到研发团队中来,但是新增的普通用户仍然还没有读,写,克隆服务器上git/repositories/*.git的权限
		 8. 事情还没完,接下来需要配置用户对gitolite管理的所有版本库git/repositories/*.git的权限进行控制,见下面的权限控制
	  4. 删除用户:
		 1. 由gitolite-admin在gitolite-admin.git/keydir/中删除目标用户的公钥
		 2. 由gitolite-admin在gitolite-admin.git/conf/gitolite.conf中去除有关该用户的配置
	  5. 更换管理员
		 1. 更换管理员的本质,就是由老管理员自己在gitolite-admin.git/keydir/gitolite-admin.pub中的内容换成新管理员客户端的公钥
		 2. 操作: more new-gitolite-admin.pub >gitolite-admin.git/keydir/gitolite-admin.pub ,然后提交
	  6. 创建新版本库
		 1. 说明:
		    1. 在gitolite.git/keydir/的一个公钥,对应一个具体的加入git服务器的成员,而该公钥的名字就是gitolite系统承认的用户名
		    2. 配置代码里面的CREATOR关键字指代的正是gitolite.git/keydir/下公钥名字的集合
		 2. 创建步骤:
			1. 管理员在gitolite.git/config/gitolite.conf中加入以下语句
			   #+BEGIN_SRC 
			   repo shared-repo/CREATOR/[a-z]..*
                    C       =   @can_create-repo
                    RW+CD   =   CREATOR
			   #+END_SRC
			2. 确保上面1中所述的事,必要的的话,先创建秘钥
			3. 在本地创建版本库: git clone git@server:shared-repo/CREATOR/test
			4. 至此,在服务器和本地就创建了一个名为test的版本库(CREATOR注意替换为相应的名)
			5. 备注: 在服务器上创建的版本库只能
	  7. 异地管理
		 1. 场景描述:
			1. 作为gitolite管理员,我希望在公司,在家,在办公路上等,的任意一台电脑上,都能克隆到gitolite-admin.git,以便随时进行管理
			2. 作为gitolite项目参与者,我希望在公司,在家,在办公路上等,的任意一台电脑上, 都能拥有该有的权限以便随时随地进行开发
		 2. 可行性分析:
			1. 无论是gitolite的管理员还是项目参与者,约定好了它们在gitolite-admin/keydir/下面都唯一只有一个公钥(虽然每个用户可以有多个公钥)
			2. gitolite-admin/keydir/目录下的公钥一旦push到服务器,就会将下面的公钥存储至服务器git账号家目录下~/.ssh/authorized_keys中去
			3. gitolite管理员的秘钥肯定在服务器上的~/.ssh/authorized_keys中;至于项目参与者,管理员曾经肯定和它们收集过公钥加入了gitolite-admin/keydir/下,并push到服务器,因此项目参与者的公钥必定也在在服务器上的~/.ssh/authorized_keys中
			4. 原理: 客户端登录服务器时,使用~/.ssh/config下面identityfile指定的公钥文件中的内容去和服务器上~/.ssh/authorized_keys中的内容匹配,如果找到了匹配,则认证成功
			5. 结论: gitolite的认证是秘钥认证,和用户账号及密码无关, 无论是管理员还是项目参与者,只要备份好公钥和私钥,将其拷贝到其他电脑账户下的~/.ssh/下面,然后在~/.ssh/config中添加一条配置,该电脑即可登录服务器
		 3. 操作: 
			1. 将公司自己办公用的笔记本,家目录下面的公钥和私钥的内容做个备份,复制到自己的U盘里面
			2. 回到家后,将U盘里面的公钥和私钥拷贝到家里电脑家目录下的~/.ssh/中
			3. 配置家里那台电脑的~/.ssh/config(尤其注意identityfile的值一定是公钥名),服务器ip之类的,配置完毕之后就可以愉快的在家里登录上服务器了
| user  | access | clone | fetch | push  | create repo | create a ref | rewinds a ref | delete a ref |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| -     | Y      | Y     | Y     | Y     | N           | N            | N             | N            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| R     | @Y     | @Y    | @Y    | N     | N           | N            | N             | N            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW    | Y      | Y     | Y     | {@W}Y | N           | N            | N             | N            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW+   | Y      | Y     | Y     | Y     | N           | N            | {@+}Y         | N            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| C     | N      | N     | N     | N     | @Y          | N            | N             | N            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RWC   | Y      | Y     | Y     | Y     | N           | {@C}Y        | N             | N            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW+C  | Y      | Y     | Y     | Y     | N           | Y            | Y             | N            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RWD   | Y      | Y     | Y     | Y     | N           | N            | N             | {@D}Y        |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW+D  | Y      | Y     | Y     | Y     | N           | N            | Y             | Y            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RWCD  | Y      | Y     | Y     | Y     | N           | Y            | N             | Y            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| RW+CD | Y      | Y     | Y     | Y     | N           | Y            | Y             | Y            |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
| M     |        |       |       |       |             |              |               |              |
|-------+--------+-------+-------+-------+-------------+--------------+---------------+--------------|
备注: {@权限字符}	表示在这一列是yes或no由该权限字符说了算; - 表示去除用户的写权限,即让用户拥有只读权限(如何让用户连读的权限都木有呢?? 答案是:删除用户)
Blog creation time:[2017-10-09 一 15:13]
** DONE [#D] Theme:创建版本库　									   :Blog:@Git:
1. git init: 其结果是在工作区中生成版本库：.git/
2. git rev-parse --git-dir: 该操作可以在工作区的任何子目录下执行，其结果是显示该工作区的版本库的路径
3. git rev-parse --show-toplevel: 该操作可以在工作区的任何子目录下执行，其结果是显示该版本控制系统的根路径
4. git rev_parse --show-prefix: 该操作可以在工作区的任何子目录下执行，其结果是显示相对于该版本控制系统的根路径的相对目录
5. git rev_parse --show-cdup: 该操作可以在工作区的任何子目录下执行，其结果是显示当前目录回退到版本控制系统根的深度
** DONE [#D] Theme:查看状态										 :@Blog:@Git:
    SCHEDULED:<2017-10-05 四>
	- State "DONE"       from "WAITTING"   [2017-10-05 四 21:45]
1. 常规：git status
2. 精简(推荐)：git status -sb
   1. 红色： 表示该文件需要执行add操作
   2. 绿色： 表示该文件已经执行过add操作，现在可以执行commit操作
   3. 空： 表示工作区干净
   4. ??：表示该文件是一个未被追踪的文件(只可能是红色)
   5. A： 表示该文件还从未进行过commit(只可能是绿色)
   6. M: 表该文件发生了修改(红色和绿色均可能)
   7. D: 表示该文件被删除(红色和绿色均可能)
3. 原则: 使用该操作,只要有输出, 那就表明工作区,暂存区,最新提交三者之间文件内容不一致
Blog creation time:[2017-10-05 四 21:41]
** WAITTING [#D] Theme:引用									 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
1. HEAD: 
2. master: .git/refs/heads/master
3. stash
4. tag-name: .git/refs/tags/tag-name 
Blog creation time:[2017-10-07 六 21:16]
** DONE [#D] Theme:里程碑										 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
1. 创建里程碑: git tag -m "注释" tag-name
   1. 创建里程碑操作会产生一个tag-commit-ID提交,并产生一个tag-name
   2. 创建里程碑后,tag-name指向一个tag-commit-ID对象,该tag-commit-ID指向对象库中的commit-ID
2. 对特定提交创建里程碑: git tag tag-name commit-ID
3. 查看tag的ID: git rev-parse tag-name
4. 显示版本号: git descrbie
   1. 前提: 执行过创建里程碑的操作
   2. 作用: 将最新的提交显示为一个容易记忆的版本号,而不是ID
   3. 版本号格式: (tag-name)-(num)-(ID)
   4. 该命令会去选取离最新提交最近的里程碑的tag-name作为基础版本号,后面加一个数字(标识该提交是里程碑后面的第几个提交),最后就是最新提交的哈希值ID
   5. 该操作的输出可以作为软件版本号,这个功能非常有用,因为这样可以将发布的软件包版本和版本库中的代码对应到一起,当发现软件包中有bug时,查看该软件包的版本,直接在代码中就能找到对应代码并进行修复,然后提交
   6. tag-name的命令: linux-kernel_1.0
5. 说明: 里程碑是个非常好的功能,建议经常使用它
Blog creation time:[2017-10-07 六 21:13]
** DONE [#D] Theme:浏览											 :@Blog:@Git:
   SCHEDULED:<2017-10-05 四>
1. 浏览文件内容
   1. 浏览工作区中的文件内容：　less a.txt
   2. 浏览暂存区中的文件内容：　git diff
   3. 浏览对象库中的文件内容：　git cat-file blob commit-ID:a.txt
2. 浏览目录树
   1. 浏览工作区中的目录树： ls -al
   2. 浏览暂存区中的目录树： git ls-files -s
	  第三列是暂存区编号不是文件大小
   3. 浏览指定提交的目录树： git ls-tree -lrt commit-ID
	  1. 第一列100644是文件的属性：rw-r--r--
	  2. 第二列标识文件还是目录：blob，文件，tree,目录
	  3. 第三列标识该文件在当前分支中的40为SHA1哈希值ID
	  4. 第四列是文件大小(Byte)
	  5. 第五列是文件名
3. 浏览对象库
   1. ID的类型: commit-ID,tree-ID,blob-ID
   2. ID的本质: 指针
   3. 对象库本质: 一个双向链表,其节点是提交, git lg 可以查看到这些节点的ID
   4. 版本库的构成: HEAD指针,分支指针头,对象库
   5. "提交节点"的成分: 前驱指针域(id),数据域(tree,author),后继指针域(parent)
   6. 数据域中的tree: tree是一个tree-ID,因此,是一个指针,这个tree指向一个目录树索引,该目录树索引和暂存区中的目录树索引经常发生交互,它们均指向add进对象库中真正的文件 
   7. 获取指定ID的类型：git cat-file -t ID, 其返回值是: commit,tree,blob
   8. 解引用commit-ID: git cat-file -p commit-ID
	  1. 使用 git lg 可以查看到对象库的所有commit-ID
	  2. 其效果与 git cat-file commit commit-ID一致
	  3. 解引用的结果: 得到"提交节点"的成分,包括tree-ID
   9. 解引用tree-ID: git cat-file -p tree-ID
	  1. 其效果与 git ls-tree -lrt commit-ID 一样
	  2. 解引用的结果: 可以查看对象库中commit-ID下数据域tree-ID指向的目录树下面的所有blob-ID
   10. 解引用blob-ID: git cat-file -p blob-ID
	   1. 其效果与 git cat-file blob commit-ID:<tab补全>一致
	   2. 解引用的结果: 可以查看tree-ID下面所有blob-ID指向的文件的真正内容
Blog creation time:[2017-10-05 四 21:46]
** DONE [#D] Theme:添加至暂存区									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:28]
1. 添加单个文件： git add a.txt
2. 添加所有文件： git add -A
3. 所有文件中，添加已经被跟踪过的文件： git add -u
4. 选择性添加: git add -i (当文件特别多,且需要仔细考虑添加哪些文件时,该操作以交互的方式,给出一个更直观的操作)
Blog creation time:[2017-10-06 五 10:26]
** DONE [#D] Theme:撤销出暂存区									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:30]
1. 撤销单个文件的add： git reset -- a.txt
2. 撤销所有文件的add: git reset -- .
3. 该操作是add的逆,所以，对暂存区和对象库无任何影响
Blog creation time:[2017-10-06 五 10:28]
** DONE [#D] Theme:提交											 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:46]
1. 命令： git commit -m "Initialized"
2. 底层: 事实上执行add操作的时候,工作区中的文件就已经加入到了对象库中,暂存区的目录树索引和对象库tree-ID下的目录树索引同时指向对象库中真实的文件
3. 提交的本质: commit操作执行之后立即产生一个commit-ID节点,使用暂存区下面的目录树索引为该commit-ID节点下面的数据域tree-ID指向的目录树索引赋值
4. 提交到哪里: 提交永远都是HEAD的“跟屁虫”，只会盯着HEAD,HEAD在哪个分支，该提交就挂接在这个分支最新提交的后面成为最新提交
6. 结果:该命令执行之后，暂存区和最新提交就有了相同的目录树索引，均指向版本库的.git/object/下的文件,因此,使用git diff HEAD比价暂存区和最新提交时返回无差异
Blog creation time:[2017-10-06 五 10:32]
** DONE [#D] Theme:撤销提交										 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:49]
1. 命令： git reset --soft HEAD^
2. 说明: 该操作是commit的逆，对暂存区和工作区文件的内容没有任何影响，主要用于想要重新书写提交说明时使用
Blog creation time:[2017-10-06 五 10:46]
** DONE [#D] Theme:修补提交 								 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 10:51]
1. 命令： git commit --amend -m "重新注释"
2. 该命令本质上相当于这两条命令的组合：
   1. git reset --soft HEAD^
   2. git commit -e -F .git/COMMIT_EDITMSG(保存了上次的提交日志)  
Blog creation time:[2017-10-06 五 10:50]
** DONE [#D] Theme:比较差异										 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
1. 暂存区与工作区
   1. 比较暂存区与工作区的差异：git diff (原始对象是暂存区)
   2. 比较暂存区与工作区指定文件的差异：git diff -- a.txt
2. 提交与暂存区
   1. 比较最新提交与暂存区：git diff HEAD --cached
   2. 比较最新提交与暂存区中指定文件：git diff HEAD --cached -- a.txt
   3. 比较指定提交与暂存区: git diff commit-ID --cached 
   4. 比较指定提交与暂存区中指定文件: git diff commit-ID --cached -- a.txt
   5. 比较里程碑A与暂存区: git diff A --cached
   6. 比较里程碑A与暂存区中指定文件: git diff A --cached -- a.txt
3. 提交与工作区
   1. 比较最新提交与工作区: git diff HEAD
   2. 比较最新提交与工作区中指定文件: git diff HEAD -- a.txt
   3. 比较指定提交与工作区：git diff commit-ID
   4. 比较指定提交与工作区中指定文件：git diff commit-ID -- a.txt
   5. 比较里程碑A与工作区的差异: git diff A
   6. 比较里程碑A与工作区中,指定文件的差异: git diff A -- a.txt
4. 提交与提交
   1. 比较指定提交与指定提交: git diff commit1-ID commit2-ID 
   2. 比较指定提交与指定提交中指定文件:git diff commit1-ID commit2-ID -- a.txt
   3. 比较里程碑A与里程碑B: git diff A B
   4. 比较里程碑A与里程碑B中指定文件: git diff A B -- a.txt
Blog creation time:[2017-10-06 五 10:52]
** DONE [#D] Theme:回滚											 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
1. 从暂存区回滚至工作区
   1. 回滚单个文件： git checkout -- a.txt
   2. 回滚所有文件： git checkout .
   3. 说明：该操作会用暂存区的指定文件或者全部文件替换工作区的文件
   4. 结果： 工作区中的文件内容，同暂存区中目录树索引下的文件内容保持一致
   5. 后果： 这意味着会丢失工作区中未添加到暂存区中的修改 
2. 从对象库回滚至暂存区
   1. 回滚单个文件： 
	  1. 命令： git reset commit-ID a.txt
	  2. 说明： 回滚单个文件不会丢失对象库中的最新提交到commit-ID这一段之间的commit，因为只回滚个别文件，说明用户有意要和对象库中的commit-ID存在差异，所以，回滚后的a.txt和暂存区的其他文件构成另一个commit
	  3. 结果： 该操作用对象库commit-ID下的a.txt替换掉暂存区中的a.txt
	  4. 后果： 会丢失在执行该操作之前，使用命令git add a.txt到暂存区的修改
	  5. 备注： 该操作同3-1中回滚单个文件最大的区别在于，该操作不会更改工作区文件的内容 
   2. 回滚所有文件： 
	  1. 命令： git reset --mixed commit-ID
	  2. 说明： 该操作让对象库中的commit-ID提交同暂存区保持一致,但是,对象库比commit-ID还新的提交有可能存在，鉴于保持一致的理念，对象库只能将最新版本重置到commit-ID
	  3. 结果： 该操作用对象库commit-ID，替换整个暂存区，即，暂存区中的索引与commit-ID中tree指针下的索引，完全一致
	  4. 后果： 丢失最近一次add到暂存区的修改以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
3. 从对象库回滚至(暂存区+工作区)
   1. 回滚单个文件： git checkout commit-ID -- a.txt
   2. 回滚所有文件： git checkout commit-ID -- .
   3. 回滚所有文件(常用): git checkout tag-name -- .
   4. 说明：
	  1. 如果commit-ID不是最新提交(HEAD->master)而是之前的提交，那么，在回滚后，暂存区会与对象库的最新提交不一致而不干净，要求再次提交
	  2. 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换暂存区下（当前存在的文件）的索引，用索引下的全部文件替换工作区下（对应）的文件
	  3. 注意：2中用小括号括起来的两个关键字非常重要：在进行替换时，如果暂存区或者工作区中新增加了对象库提交中没有的文件，此时的替换只会替换对象库，工作区，暂存区中公共的文件，差异的文件内容以及文件状态不变
      4. 回滚操作与重置(git reset --hard commit-ID)的区别在于,回滚操作只用commit-ID中文件覆盖暂存区以及工作区中的同名文件,暂存区和工作区特有的,commit-ID中没有的这些文件保持原样,而重置则是使得工作区暂存区中有且仅有commit-ID中的文件(版本库干净)
   5. 结果：
      1. 工作区中的文件内容，暂存区目录树索引下的文件的内容，同commit-ID节点中tree元素指向的目录树索引下的blob文件内容一致
      2. 那些只在工作区下或者暂存区下才有的而commit-ID这个提交中没有的文件，依旧保持其该有的状态以及内容
   6. 后果：工作区中未add的改动以及暂存区中未commit的改动，如果发生改动的文件在commit-ID这个提交下存在，那么，这些改动会被commit-ID下的文件内容覆盖
Blog creation time:[2017-10-06 五 10:58]
** DONE [#D] Theme:重置											 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
1. 软重置
   1. 基础命令: git reset --soft commit-ID
   2. 常用命令: git reset --soft tag-name (里程碑真的很好用,建议多用!)
   3. “软”的意义：只改变对象库中HEAD->master对commit-ID的指向，不改变暂存区和工作区文件的内容
   4. 功能昵称: 多步悔棋,穿梭过去
   5. 使用场合： 开发过程中,对某一个特性功能进行一系列测试,修补,再测试之后终于得到了正确的版本,但是,却在版本库中遗留了多个提交,这些提交都是中间过程提交,遗留在版本库中意义不大,此时,可以使用该重置命令,将版本库中的最新提交重置到特性功能测试之前的那个提交上,然后再将这个最终得到的正确版本提交到版本库,这样就更改剔除了那些个不必要的版本,还可以重设提交说明,这样做使得版本库更加简洁
2. 混合重置
   1. 命令： git reset --mixed commit-ID(默认缺省--mixed)
   2. “混合”的意义： 不改变工作区文件的内容，但是会改变暂存区的内容
   3. 说明： 该操作会用对象库中的一个commit-ID节点在当前分支下的目录树索引，替换整个暂存区，即，暂存区中的索引与commit-ID中tree指针下的索引，完全一致
   4. 结果： 暂存区与commit-ID的文件内容一致，工作区的文件的内容还是重置前的内容，但是状态变为待add的状态
   5. 后果：丢失最近一次add到暂存区的修改以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
3. 强制重置
   1. 命令： git reset --hard commit-ID
   2. “强制”的意义： 工作区和暂存区的文件内容都会被commit-ID下的文件内容覆盖
   3. 结果：工作区，暂存区，与commit-ID的文件内容一致
   4. 后果： 会丢失工作区中尚未add的改动以及暂存区尚未提交的commit，丢失最新的commit到待重置的commit之间的这一段commit
   5. 备注： 可以使用git reset --hard HEAD来彻底恢复到上一次提交的那个干净的版本
4. 挽救错误的重置
   1. 重置最显著的特点就是，最新的commit-ID到待重置的commit-ID这一段之间的commit会丢失，因此，重置行为是版本库中最危险的行为，因为会丢失提交
   2. 使用reflog来挽救错误的重置
	  1. 从日志中获取最新ID：git reflog show | head -5
	  2. 找到eb3bcab master@{0}: reset: moving to HEAD^所在行
	  3. 由于该日志是将最新的改变放在前面，因此，这一行的下面一行就是重置前的commit，假设为master@{2}所在行
	  4. 再次重置：git reset --hard master@{2}
Blog creation time:[2017-10-06 五 11:12]
** DONE [#D] Theme:删除											 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 15:41]
1. 删除工作区尚未追踪的文件 
   1. 删除尚未追踪的指定文件: git clean -fd a.txt
   2. 删除尚未追踪的所有文件: git clean -fd
   3. 说明: 尚未追踪的文件,其删除操作与暂存区和对象库没有任何联系
2. 删除暂存区中的文件
   1. 删除指定文件： git rm -rf --cached a.txt
   2. 删除所有文件:  git rm -rf --cached *
   3. 说明： 该操作只删除暂存区中的文件,工作区中的文件依旧是删除操作之前的最新内容
3. 删除 工作区+暂存区 中的文件
   1. 删除指定文件: git rm -rf a.txt
   2. 删除所有文件: git rm -rf *
   3. 结果: 该操作使得在工作区和暂存区的指定文件都会被删除,因此,暂存区与对象库的最新提交不一致,会要求提交新版本
4. 删除对象库提交
   1. 命令: git reset --soft commit-ID
   2. 说明: 对象库中的提交是版本库这个大链表上的一些个节点,删除某个节点破坏了版本控制系统连续记录的原则,因此,该操作会将最新提交到该commit-ID之间的提交都删除掉
Blog creation time:[2017-10-06 五 14:17]
** DONE [#D] Theme:恢复删除										 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 15:41]
1. 命令: git checkout HEAD~1 -- a.txt
2. 说明: 如果a.txt使用git rm -rf a.txt删除了工作区和暂存区中的a.txt并进行了提交,如果想要找回a.txt,可以在HEAD^这个提交下面找回 
Blog creation time:[2017-10-06 五 15:27]
** DONE [#D] Theme:更改文件名字									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
	- State "DONE"       from "WAITTING"   [2017-10-06 五 22:25]
1. 命令: git mv a.txt aa.txt
2. 说明: 该操作可以同时更改工作区和暂存区中的中的a.txt的名字为aa.txt
Blog creation time:[2017-10-06 五 15:42]
** DONE [#D] Theme:保存工作进度									 :@Blog:@Git:
   SCHEDULED:<2017-10-06 五>
   - State "DONE"       from "WAITTING"   [2017-10-06 五 22:25]
1. 保存进度的原理:
   1. 调用进度保存指令git stash save "注释",触发下面的步骤
   2. 从当前分支的最新提交节点处,开创建一个特殊(stash分支)的新分支,这个最新的提交节点就是特殊新分支的起点,让进度指针头refs/stash指向这个起点,如此便创建了一个进度分支
   3. 将暂存区提交到进度分支上,保存好暂存区的进度
   4. 将该进度分支的起点节点与进度分支的暂存区进度进行合并,生成工作区进度
2. 保存进度: git stash save "gMrM--a.txt gM--b.txt gM--subdir/dir/c.txt"
   1. 该命令使用了git reset --hard HEAD,工作区,暂存区,最新提交,三者内容一致,版本库干净
   2. 当存在未追踪的文件时,进度保存操作无法进行,需要先追踪才可以
   3. 该命令执行之后,会产生一条进度保存记录,使用git stash list查看
   4. 我的注释格式: g:green ; r:red 用于描述大写字母的颜色
   5. 进度保存的实质: 将进度保存在引用refs/stash所指向的提交中
   6. 进度保存操作会将,暂存区提交后产生的stash-commit-ID,与进度保存前,对象库的最新进行合并,产生一个stash-commit-ID,refs/stash指向会指向它
   7. 可以使用-k参数,在保存进度后不会将暂存区重置
3. 查看进度保存记录: git stash list
   1. 该命令显示之前保存过的众多进度
   2. 恢复进度时,可以查看该记录来选择恢复那个进度
4. 恢复进度: git stash pop --index stash@{n}
   1. --index: 指明恢复进度时,除了恢复工作区之外,还会尝试恢复暂存区.如果不指定该参数则只恢复工作区的文件内容
   2. 恢复后删除进度保存列表中的记录
5. 运用进度: git stash apply --index stash@{n}
   1. --index: 指明恢复进度时,除了恢复工作区之外,还会尝试恢复暂存区.如果不指定该参数则只恢复工作区的文件内容
   2. 只是运用该进度而不会将其从进度保存列表中删除
   3. 该操作和恢复进度的功能是一样的,区别就是恢复后不删除,该命令的优点在于可以多次运用该进度
6. 删除进度: git stash drop stash@{n}
7. 删除所有进度: git stash clear
8. 查看进度保存日志: git log --graph --pretty=raw refs/stash -2
Blog creation time:[2017-10-06 五 14:17]
** DONE [#D] Theme:文件追溯										 :@Blog:@Git:
    SCHEDULED:<2017-10-09 一>
	- State "DONE"       from "WAITTING"   [2017-10-09 一 10:08]
1. 追溯a.txt中的所有行: git blame a.txt
2. 追溯a.txt中第2行开始的3行内容: git blame -L 2,+3 a.txt
3. 要求: blame的对象必须一个文件,且该文件必须commit到对象库中
4. 作用: 以行为单位,显示该行最早在哪个commit中引入,以及由谁在什么时候引入
5. 使用场合: 在开发过程中发现bug时,定位到具体的源文件之后,可以使用该命令追溯该bug是由谁在什么时候的哪个commit中引入
6. 使用前提: 该操作是建立在bug已经定位到源代码的基础之上,然后才能定位到bug行的提交者,进行打板子教育
Blog creation time:[2017-10-09 一 09:29]
** WAITTING [#D] Theme:拣选 									 :@Blog:@Git:
    SCHEDULED:<2017-10-09 一>
1. 开发还在进行中......
2. 在历史提交 commit-ID4 中发现一个严重的bug,需要去fixed这个提交的bug
3. 
4. 回滚版本库中 commit-ID3 至暂存区和工作区
5. 挑拣过程中出现冲突:http://blog.csdn.net/wh_19910525/article/details/7554430
Blog creation time:[2017-10-09 一 10:30]
** DONE [#D] Theme:忽略文件										 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
	- State "DONE"       from "WAITTING"   [2017-10-07 六 22:23]
1. 共享式忽略
   1. 一个文件的文件名如果被添加进workspace/.gitignore,则该文件不会被版本库管理
   2. 注意: 如果一个文件在被添加进.gitignore之前就已经add进了版本控制系统,则忽略无效
   3. 共享的含义: 当其他人clone,pull该版本库时,这个忽略文件仍然有效
2. 独享式忽略
   1. 局部独享: .git/info/exclude,只针对某一个版本库
   2. 全局独享: ~/.gitconfig,下面的core.excludesfile指定的文件,针对该用户相关的所有版本库
   3. 设置全局独享忽略: git config --global core.excludesfile /home/ljj/.gitconfig
   4. 独享的含义: 当其他人clone,pull该版本库时,该忽略文件不会被传递给该用户
Blog creation time:[2017-10-07 六 22:01]
** DONE [#D] Theme:文件归档										 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
	- State "DONE"       from "WAITTING"   [2017-10-07 六 22:45]
1. 基于提交创建归档: git archive -o lastest.zip commit-ID
2. 基于提交中的指定目录创建归档: git archive -o lastest.tar commit-ID -- subdir1 subdir2
3. 基于里程碑linux_1.0创建归档,并将归档中的所有文件都添加kernal/n前缀: git archive --format=tar --prefix=kernel/ linux_1.0 | gzip > linux_1.0-3-g5ea60ef.tar.gz
Blog creation time:[2017-10-07 六 22:27]
** DONE [#D] Theme:gitg											 :@Blog:@Git:
    SCHEDULED:<2017-10-07 六>
	- State "DONE"       from "WAITTING"   [2017-10-08 日 08:53]
1. gitg 是使用GTK+图形库实现的一个git版本库浏览器软件
2. gitg不仅可以实现gitk的全部功能(浏览历史和文件),还能帮助执行提交
3. 安装gitg: sudo aptitude install gitg
Blog creation time:[2017-10-07 六 22:52]
** WAITTING [#D] Theme:底层命令								 :@Blog:@Git:
    SCHEDULED:<2017-10-08 日>
1. git 的命令中,一部分是使用ID作为参数,一部分则使用范围作为参数,下面的两个底层命令中rev-parse就是负责ID相关,rev-list负责范围相关
2. git rev-parse
   1. 该底层命令功能非常丰富和杂乱,很多的git脚本或者工具都会用到这条命令
   2. 显示分支: git rev-parse --symbolic --branches
   3. 显示所有里程碑: git rev-parse --symbolic --tags
   4. 显示定义的所有引用: git rev-parse --symbolic --glob=refs/*
   5. 显示HEAD对应的的commit-ID: git rev-parse HEAD
   6. 显示tag对应的tag-commit-ID: git rev-parse linux_1.0
   7. 显示tag对应的tag-commit-ID指向的提交的父提交的commit-ID: git rev-parse linux_1.0~2
   8. 显示tag对应的tag-commit-ID指向的提交下的tree-ID: git rev-parse linux_1.0:
   9. 显示tag对应的tag-commit-ID指向的提交下的tree-ID下子目录的tree-ID或者文件的blob-ID
   10. 同时显示多个对应的SHA1哈希值: git rev-parse master refs/heads/master
   11. 给定一个简写的SHA1哈希值,给出完整的SHA1哈希值: git rev-parse 5ea60ef
3. git rev-list
   1. 显示,所有与版本A关联的历史提交: git rev-list --oneline A
   2. 显示,所有与版本A关联的历史提交(A自身除外): git rev-list --oneline A^@
   3. 显示,A自身: git rev-list --oneline A^!
   4. 显示,所有与版本A关联 and 与版本B关联的历史提交: git rev-list --oneline A B
   5. 显示,所有与版本A关联的历史提交中排除掉与D,F关联的历史提交之后剩下的提交: git rev-list --oneline B ^D ^F
   6. 显示,所有B,C的历史提交 中,排除B,C的交集之后,剩余的所有历史提交: git rev-list --oneline B...C
Blog creation time:[2017-10-08 日 08:54]
** WAITTING [#D] Theme:分支									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
1. 分支的构成
   1. 分支的祖先起点：主分支上的第一次提交，是任意分支的祖先起点
   2. 分支的起点： 每个分支，都有一个分支起点。任意分支上的任意提交，都可以是某指定分支的起点
   3. 分支指针头： 每个新建的分支，都有一个分支指针。分支指针头总是指向该分支的最新提交
   4. 空分支：只有分支起点和分支指针构成的分支称为一个空分支
   5. 分支指针头的生命周期：分支指针在该分支被创建的时候产生，在该分支合并到其起点所在的分支时，分支指针死亡
   6. 分支的构成：任意一个新创建的分支，由：分支起点 + 分支提交结点 + 指向分支最新提交的分支指针头 构成
2. 分支的背景知识
   1. HEAD，总是指向当前分支的分支指针头
   2. 分支指针头，总是指向自己分支所有提交中的最新提交
   3. 提交： 提交永远都是HEAD的“跟屁虫”，只会盯着HEAD,HEAD在哪个分支，该提交就挂接在这个分支最新提交的后面成为最新提交
   4. 切换到新分支的本质是让HEAD指向新分支的分支指针头 
3. 查看版本库的分支：git branch -v
4. 创建分支：git branch new-br
5. 切换到新分支：git checkout new-br
6. 创建分支并切换到新分支:git checkout -b new-br
7. 切换到“分离头指针状态”
   1. 命令： git checkout commit-ID
   2. 通常，HEAD总是指向分支指针头，表示该分支指针头指向的分支是当前分支，而让HEAD指向提交，表示版本库处于“分离头指针状态” 即，'detached HEAD'		 
   3. ”分离头指针状态“的特点：
	  1. 可以检查，测试，提交而不影响任何分支
	  2. 切换会分支之后，在分离头指针状态下的提交在log中不再显示，提交也消失了，但是，依然存在版本库中，但是，当reflog中的该提交日志过期之后，这个提交随时会彻底删除
	  4. 合并“分离头指针状态”的提交至主分支master
		 1. 命令：git merge new-commit-ID
		 2. 由于在“分离头指针状态”所做出的提交除了能被new-commit-ID所访问到之外，就无法通过分支访问。另外，该提交随时会在版本库中彻底消失，如果这个提交对master很重要的话，可以通过该操作将这个提交合并到master上即可
Blog creation time:[2017-10-06 五 14:21]
** WAITTING [#D] Theme:开发模型 								 :@Blog:@Git:
*** 金字塔式协同模型
1. linux社区就是使用的金字塔协同模型
2. 特点:
   1. 只有核心开发者develop才具备向master推送的权限,任何开发者都具备读master的权限(这意味着需要搭建一个只读的Git服务器)
*** Android式多版本协同模型(重点)	
1. 单人工作模型
2. 团队工作模型
2-1 金字塔版本控制模型：发布Linux
--最终版本库；  ---> Fedora 25发行版
--有一个权威贡献者的版本库（linus）
--有几个核心贡献者的版本库（Kernel、Samba、KDE、Gnome）
--有若干开发者（37人）的版本库（10个人负责开发Kernel、6个人负责开发Samba、
12个人负责开发KDE、9个人负责开发Gnome）

特点：
--每个贡献者的版本库都是平等的；
--用于版本控制的模型；

2-2金字塔版开发模型：开发Samba
2-2-1服务器端，主分支master;   ---> Samba 3.4.1
1.不允许在master分支上干活，所以该分支不属于某一个成员，应当找一个牛来管理
（合并分支）master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有slaver分支对它有写权限，即，只有slaver分支才能向它合并代码；
3.所有分支对它都有读权限；
4.这个分支是非常稳定的，可以作为产品的。

2-2-2服务器端，开发分支（slaver）
1.这个开发分支用于干活，但是该分支也不属于某一个成员，应当找一个牛来管理（合并分支）
master分支以及slaver分支，这个人一般是核心开发者中最牛的那一个人；
2.只有核心开发分支（A、B、C、D）才对它有写权限，即，只有核心开发者才能向
slaver分支合并代码；
3.只有核心开发分支（A、B、C、D）才对它有读权限
4.这个分支是不稳定的，找来管理它的牛在充分测试后时不时把它作为版本合并
到master分支上即可。

2-2-3服务器端，核心开发者的开发分支（A、B、C、D）
1.这四个分支的所有者可以在属于自己的分支上干活，并且时不时向slaver分支合并代码
并且，接受
2.向slaver合并代码，

--有若干开发者（37人）的开发分支（其中10个人只能）

特点：
-每个开发者的版本库都是平等的；
--用于版本开发的模型；

个人也必须有一个master分支和slaver分支，其中，slaver分支用于自己干活，master
分支主要用于三个方面：向上级分支推送代码，接受别人代码的合并，接受自己在slaver分支
上的代码的合并
Blog creation time:[2017-09-05 二 08:07]
** WAITTING [#D] Theme:克隆									 :@Blog:@Git:
    SCHEDULED:<2017-10-09 一>
1. 必要性: 再健壮的版本库设计,也抵挡不了存储介质的崩溃,因此,不要将鸡蛋装在同一个篮子里
2. 
Blog creation time:[2017-10-09 一 14:50]
** WAITTING [#D] Theme:日志									 :@Blog:@Git:
    SCHEDULED:<2017-10-06 五>
3. 日志
   1. 在执行commit命令之后，就会在log中产生一条提交信息
   2. git log --stat
      commit ccbbaeae9b9444ad21caa6d8216f7b8a4d22f59a (HEAD -> master, origin/master)
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Mon Oct 2 10:34:04 2017 +0800
	  
	  -----
	  
	  blogs-git-active.org       | 227 +++------------------------------------
	  blogs-linux-active.org     | 262 ++++++++++++++++++++++++++++++++++++++++++---
	  blogs-linux-arch-part2.org |   2 +-
	  3 files changed, 264 insertions(+), 227 deletions(-)
	  
	  commit e3f5fc176a40c3d889aecb4e051bfaec4101c4d5
      Author: ytulinjiajun <ytulinjiajun@163.com>
	  Date:   Sat Sep 30 20:55:18 2017 +0800
	  
	  -----
	  
      blogs-emacs-active.org | 144 +++++++++---------
      blogs-git-active.org   | 395 ++++++++++++++++++++++++++++++++++++++++++++++---
	  2 files changed, 449 insertions(+), 90 deletions(-) 
   3. git log --pretty=fuller
	  commit ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD)
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 20:17:49 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 20:17:49 2017 +0800
	  
	  -----
	  
	  commit 8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345
	  Author:     ytulinjiajun <ytulinjiajun@163.com>
	  AuthorDate: Fri Sep 22 19:35:59 2017 +0800
	  Commit:     ytulinjiajun <ytulinjiajun@163.com>
	  CommitDate: Fri Sep 22 19:35:59 2017 +0800
   4. git log --pretty=online
      ae1c32a2b284c241aed415ffb5b9bef4cf9f565f (HEAD -> master, origin/master, origin/HEAD) -----
	  8051ab98bf3b5d1e234ea8f0eb5efa145c1c5345 -----
	  228e998f2b5b1936fbd90f2441bf610d689caee1 -----
	  58c9b9ed50b28b4e47302dbc4248686d9e835f27 evil-mode
	  f9f1d307bb08c94f78e0714998759c1515e0f027 -----
	  34b45e97083e705d98900aaa8ec9692bc27e89eb -----
	  21c290a0cdebe3bebaff7148a5f69e4399a5ecc3 -----
	  915cd2a2564a5b8a942301de31b993d0f6ec2636 -----
   5. git log -l --pretty=raw
Blog creation time:[2017-10-06 五 14:21]
