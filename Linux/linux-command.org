* DONE [#C] theme:apt-get命令
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
--查询某软件在系统中的基本信息：
dpkg -s xxx
(1)是否安装
(2)安装包大小
(3)32位还是64位
(4)版本号
(5)依赖
(6)配置文件

--查询当前apt-source下面，可供安装的指定软件xxx的信息（xxx必须是待安装软件在仓库中的真实名）
apt-cache show xxx
结果：列出源仓库中，软件xxx不同版本的基本信息

--查询当前apt-source下面,与可供安装的指定软件xxx相关的软件（xxx不必是准确的名）
apt-cache search xxx
结果：列出源仓库中，所有与xxx沾边的软件

--安装：
1)dpkg -i xxx.deb
2)apt-get -f install 
3)dpkg -i xxx.deb
备注：上面的这两个语句经常用来解决软件安装过程的存在的依赖关系，首先下载xxx.deb,然后使用dpkg -i xxx.deb
安装，此时，一般情况下会显示有依赖文件找不到，接着在使用apt-get -f install,系统就会去安装那些个找不到
依赖的文件，之后，再使用dpkg -i xxx.deb就能顺利完成xxx.deb的安装了

--删除：
apt-get autoremove --purge xxx
备注：删除，软件包+依赖软件包+配置文件

--更新：
apt-get update && apt-get upgrade && apt-get dist-upgrade
备注：更新源+更新已安装的软件+系统升级

--了解安装包的依赖关系
apt-cache depends xxx

--清理下载文件的存档 && 只清理过时的包
apt-get clean && apt-get autoclean

--检查是否有损坏的依赖
apt-get check

--查看系统中与xxx相关联的包
dpkg -l |grep -i xxx

--查询系统中已安装的软件xxx在系统中的所有路径
dpkg -L xxx

源码包安装
   apt-cache showsrc 查找看源码包的文件信息(在下载之前)
   apt-get source 下载源码包.
   apt-get build-dep +"包名" 构建源码包的编译环境.
Blog creation time:[2017-09-05 二 09:07]

* DONE [#C] Theme:curl命令
	- State "DONE"       from "WAITTING"   [2017-09-11 一 15:30]
--curl命令是一个利用URL规则在命令行下工作的文件传输工具

--支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具

--作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、
从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征
做网页处理流程和数据检索自动化，curl可以祝一臂之力。


安装：
Ubuntu下，只需一条命令即可安装curl：
--sudo apt-get install curl libcurl3 libcurl3-dev php5-curl


Blog creation time:[2017-09-11 一 15:24]
* DONE [#C] theme:diff命令
   - State "DONE"       from "WAITTING"   [2017-10-01 日 18:14]
1. 基础框架
   1. 范式：diff OPTIONS... TAG1  TAG2
   2. 情况一，TAG1与TAG2均是文件
	  1. 这种情况是最为简单的，diff命令比较的是这两个文件的内容
	  2. 特殊标识‘-’代表标准输入，diff -u - b.txt <a.txt >c.txt 等价于 diff -u a.txt b.txt >c.txt
	  3. 这种情况按照下面的三种方式：正常模式，上下文模式，合并模式进行操作
   3. 情况二，TAG1与TAG2之间有其一是文件，比如TAG1是文件，其一是目录，比如TAG2是目录
	  1. 命令： diff -u a.txt dir/
	  2. 该命令会且仅会将a.txt同dir/a.txt相比较
	  3. diff -u - dir/ <a.txt在该情况下是不合法的，即，不支持标准输入
   4. 情况三，TAG1与TAG2均是目录
      1. 比较的基本原则是：同一目录深度处， 有名字相同的文件，进行比较，有名字相同的目录，则进入该目录，同时双方的目录深度各自加一，然后进行文件遍历
	  2. 目录的比较一般都需要加上-rcanshu
2. 研究对象
   1. 原始文件： a.txt
	  应该杜绝文章中的错别子。
	  
	  但是无论使用
	  *全拼，双拼
	  *还是五笔
	  
	  是人就有可能犯错,软件更是如此。
	  
	  犯了错，就要扣工资！
	  
	  改正的成本可能会很高。
   2. 目标文件: b.txt
      应该杜绝文章中的错别字。
	  
	  但是无论使用
	  *全拼，双拼
	  *还是五笔
	  
	  是人就有可能犯错,软件更是如此。
	  
	  改正的成本可能会很高。
	  
	  但是“只要眼球足够多，所有的bug都好捉“，
	  这就是开源的哲学之一
   3. 备注： 在 diff [选项] [FILE1] [FILE2] 中，定义FILE1为原始文件，FILE2为目标文件
3. 正常模式(normal diff)
   1. 命令：diff a.txt b.txt >c.txt
   2. 差异输出：
	  1c1
	  < 应该杜绝文章中的错别子。
	  ---
	  > 应该杜绝文章中的错别字。
	  9,10d8
	  < 犯了错，就要扣工资！
	  < 
	  11a10,12
	  > 
	  > 但是“只要眼球足够多，所有的bug都好捉“，
	  > 这就是开源的哲学之一
   3. 要点
	  1. 正常模式的基本原则：需要对原始文件做出怎样的操作之后，才能用与目标文件匹配
	  2. 正常模式是diff命令的默认模式
	  3. 默认模式的输出结果比较符合计算机的思维方式，但是，不太直观，所以，提供了contex-mode和unified-mode，使得人们能更好的理解
	  4. git diff使用的是unified-mode,即，合并模式
   4. 语法分析：(正常模式语法分析的重要原则是：需要对原始文件做出怎样的操作“a d c”之后，才能用与目标文件匹配)
	  1. [数字1，数字2] + 字母 + [数字3,数字4]格式分析： 如上结果中的 9,10d8
		 1. 字母: a=add ; c=change ; d=delete
		 2. [数字1，数字2]：  9,10 表示原始文件中的第[9,10]行，注意是闭区间，包含第9行和第10行
		 3. [数字3，数字4]：  8 表示目标文件中的第8行
		 4. 9,10d8的含义：对原始文件的第9行到第10行，做出删除的操作后，可以同目标文件的第8行匹配
	  2. 以<开始的行： 标识这是属于原始文件专有的行
	  3. 以>开始的行： 标识这是属于目标文件专有的行
	  4. ---： 原始文件和目标文件的分隔符
4. 上下文模式(context diff)
   1. 命令： diff -c a.txt b.txt >c.txt
   2. 差异输出：
	  *** a.txt	2017-09-30 16:11:33.961502252 +0800
      --- b.txt	2017-09-30 16:12:27.869501287 +0800
      ***************
      *** 1,4 ****
      ! 应该杜绝文章中的错别子。
	  
      但是无论使用
      *全拼，双拼
      --- 1,4 ----
      ! 应该杜绝文章中的错别字。
	  
      但是无论使用
	  *全拼，双拼
	  ***************
	  *** 6,11 ****
	  
      是人就有可能犯错,软件更是如此。
	  
      - 犯了错，就要扣工资！
      - 
      改正的成本可能会很高。
      --- 6,12 ----
	  
      是人就有可能犯错,软件更是如此。
	  
      改正的成本可能会很高。
      + 
      + 但是“只要眼球足够多，所有的bug都好捉“，
      + 这就是开源的哲学之一
   3. 要点
	  1. 在输出的差异文件中，无论+ - !出现在原始文件块还是目标文件块中，其含义均是表示需要对原始文件做出操作才能与目标文件相匹配
	  2. 命令中的 -c 正是标识上下文模式的关键选项 
   4. 语法分析(上下文模式语法分析的重要原则是：需要对原始文件做出怎样的操作“+ - ！”之后，才能与目标文件匹配)
	  1. 原始文件标识： 第一行以3个***开头，标识的是原始文件，该行记录了原始文件的文件名和时间戳
	  2. 目标文件标识： 第二行以3个---开头，标识的是目标文件，该行记录了目标文件的文件名和时间戳
	  3. 分隔符： 第三行15个***************是分隔符
	  4. 原始文件，差异定位语句： *** 1,4 ****
		 1. ***： 原始文件，差异定位语句开始标志
		 2. 1,4： 本差异小节的内容，位于原始文件的第[1,4]行
		 3. ****： 差异定位语句结束标志
	  5. 目标文件，差异定位语句： --- 1,4 ----
		 1. ---： 目标文件，差异定位语句开始标志
		 2. 1,4： 本差异小节的内容，位于目标文件的第[1,4]行
		 3. ----： 差异定位语句结束标志
	  6. 两个差异定位语句之间的内容称为一个差异小节
      7. 差异小节操作符：
	     1. + 表示，原始文件需要增加这一行，才能同目标文件匹配
	     2. - 表示，原始文件需要删除这一行，才能同目标文件匹配
	     3. ! 表示，原始文件需要经过修改，才能同目标文件匹配
5. 合并模式(unified diff)
   1. 命令： diff -u a.txt b.txt >c.txt
   2. 差异输出：
	  --- a.txt	2017-09-29 14:55:40.091131063 +0800
 	  +++ b.txt	2017-09-29 15:00:00.075126407 +0800
 	  @@ -1,4 +1,4 @@
 	  -应该杜绝文章中的错别子。
 	  +应该杜绝文章中的错别字。
	  
 	  但是无论使用
 	  *全拼，双拼
 	  @@ -6,6 +6,7 @@
	  
 	  是人就有可能犯错,软件更是如此。
	  
 	  -犯了错，就要扣工资！
	  - 
   	  改正的成本可能会很高。
	  + 
   	  +但是“只要眼球足够多，所有的bug都好捉“，
   	  +这就是开源的哲学之一
   3. 要点
	  1. 合并模式是比较重要的模式，因为git集成的diff使用的就是该模式，因此务必掌握
      2. 命令中的 -u 正是标识合并模式的关键选项
   4. 语法分析
	  1. 原始文件标识： 第一行以3个---开头，标识的是原始文件，该行记录了原始文件的文件名和时间戳 
      2. 目标文件标识： 第二行以3个+++开始，标识的是目标文件，该行记录了目标文件的文件名和时间戳
      3. 原始文件专有行：以-号开始的行，表示只出现在原始文件中的行，从打补丁命令patch的角度看，表示该行需要删除
      4. 目标文件专有行：以+号开始的行，表示只出现在目标文件中的行，从打补丁命令patch的角度看，表示该行需要增加
      5. 公共行：以空格开始的行，表示在原始问价和目标文件中都出现的行
      6. 差异定位语句： @@ -6,6 +6,7 @@
	     1. @@： 差异定位语句开始标志
	     2. -6，6： 本差异小节的内容，位于原始文件中的位置是：从第6行开始,之后的6行
	     3. +6,7： 本差异小节的内容，位于目标文件中的位置是：从第6行开始，之后的7行
	     4. @@： 差异定位语句的结束标志
      7. 差异小节：两个差异定位语句之间的内容构成一个差异小节
6. 文件同目录之间的比较
   1. 命令： diff a.txt dir/
   2. a.txt会且仅会同dir/a.txt进行比较，即，即使dir/sub-dir/a.txt存在，且使用-r,比较也无法进行
7. 目录同目录之间的比较(最重要，项目管理常用！！！)
   1. 目录与目录比较的要领： 
      1. 当原始目录和目标目录在各自的递归(指定-r选项)过程中,在相同深度的地方,出现名字相同的文件时，才会对这个名字相同的文件做比较
	  2. 当原始目录和目标目录在各自的递归(指定-r选项)过程中,在相同深度的地方，出现名字相同的目录时，才会各自进入这个名字相同的目录，并goto 1
	  3. 一旦在相同深度的地方，找到名字相同的文件时，比较的原则就演变为文件同文件之间的比较,将上面所述的3中模式！
   2. 目录比较时，4个重要的选项
      1. -u: unified,采用合并模式生成补丁文件
	  2. -q: 只列举出两个文件有无差异，而不进行比较
	  3. -r: 递归比较目录中的子目录，其本质要点是：原始目录和目标目录，在相同深度的位置，是否有相同名字(文件，目录)
	  4. -N: 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录，文件A 若使用-N参数，则diff会将文件A 与一个空白的文件比较；该选项能确保补丁文件能正确地处理已经创建或删除文件的情况
   3. 生成补丁文件的最终命令： diff -u -Nr old-package/ new-package/ 
Blog creation time:[2017-10-01 日 08:48]
* DONE [#C] theme:patch命令
   - State "DONE"       from "WAITTING"   [2017-10-01 日 18:13]
1. 当patch的对象是一个文件
   1. 打补丁命令，版本升级：patch old-version.txt <diff.patch  
   2. 去除补丁命令，版本回退：patch -R  new-version.txt <diff.patch  
   3. 原则：
      1. 明确自己是想进行版本升级，还是版本回退，如果是进行版本升级，则使用打补丁命令，如果是进行版本回退，则进行去除补丁命令
	  2. 明确哪个是老版本，哪个是新版本，其方法是less diff.patch，补丁头处，以---开始的是原始文件，即老版本；以+++开始的是目标文件，即新版本
	  3. 在明确想要版本升级还是版本回退，以及分清楚哪个是老版本，哪个是新版本之后，严格根据上面的1,2条所示的命令，即可达到目的
2. 当patch的对象是一个目录(工程中常用，非常重要)
   1. 背景：
	  1. 发起了一个工程项目，并完成了它的初始版本，工程的源代码放置在linux/这个目录树下面
	  2. 该版本只包含了最基础的配置但可满足用户的基本需求，初始版本的大小为3GB，版本号为linux1.0
	  3. 将这个3GB大小的软件上传到ftp服务器，供广大用户免费下载使用
	  4. 随后，该工程项目逐步添加一些功能,对linux1.0进行了一些优化，删减了一些源代码，修复了一些bug，编译之后形成linux2.0,该版本的大小为4.8GB
	  5. 使用命令diff -uNr linux1.0/ linux2.0/,制作出补丁文件linux2.0.patch,该补丁的大小为36MB
	  6. 将这个36MB大小的linux2.0.patch上传到ftp服务器，供广大用户免费下载进行升级
	  7. 广大用户下载了一个36MB大小的补丁文件，然后按照下面介绍的打补丁的方法，对第一次下载的3GB大小的linux1.0执行打补丁操作
	  8. 使用命令patch -p0 <linux2.0.patch，这样就将linux1.0的源代码升级成linux2.0的源代码
	  9. 广大用户完成升级之后，发现linux2.0不稳定，很不爽，因此对刚升级的linux2.0的源代码进行去除补丁操作，会退回linux1.0的源代码
	  10. 使用命令patch -p0 -R <linux2.0.patch,这样，又穿梭回linux1.0了，棒棒哒
	  11. 广大用户中有一部分人很喜欢linux2.0中新增的一些功能，因此，找到了导致linux2.0不稳定的那个bug，并报告给该项目的发起者让它进行紧急修复该bug
	  12. 该项目的发起者收到该bug后，发现是linux/arch/alpha/boot/目录下出了问题，项目发起者立即火速修补了代码的bug，重新编译之后形成linux2.0.1,该版本大小为4.9GB
	  13. 使用命令diff -uNr linux2.0/arch/alpha/boot/ linux2.0.1/arch/alpha/boot/ >linux2.0.1.patch,该补丁的大小为7MB
	  14. 广大用户又下载了这个7MB大小的补丁文件，然后按照下面介绍的打补丁的方法，对本地的linux2.0执行打补丁操作
	  15. 使用命令patch -p1 <linux2.0.1
	  16. 现在广大可以愉快的使用linux2.0.1而不会出现不稳定的问题了
	  17. 该方案的优点
		  1. 用户只需下载一次3GB的linux1.0,之后就只用下载36M的linux2.0.patch而不用下载4.8GB的linux2.0就能获得linux2.0的源代码
		  2. 工程项目的发起者只用上传36M的linux2.0.1.patch，而不用每fix一个bug就上传几个G的工程源代码
		  3. 用户拿着补丁文件能随意的在linux1.0和linux2.0之间穿梭
   2. 打补丁命令，版本升级： patch -p(num) <diff.patch    
   3. 去除补丁命令，版本回退：patch -R -p(num) <diff.patch
   4. 操作步骤：
	  1. 明确自己是想进行版本升级，还是版本回退，如果是进行版本升级，则使用打补丁命令，如果是进行版本回退，则进行去除补丁命令
	  2. 明确哪个是老版本，哪个是新版本，其方法是less diff.patch，补丁头处，以---开始的是原始文件，即老版本；以+++开始的是目标文件，即新版本 
      3. 确定-p(num)中的num,一般为0，或者1，或者2，其意义需要参照补丁文件的补丁头，假设diff.patch的补丁头如下所示：
         --- linux-2.6.25_android/arch/alpha/boot/misc.c 2010-05-06 01:56:42.565397700 -0700
         +++ linux-2.6.29_android/arch/alpha/boot/misc.c 2010-05-06 00:51:06.000000000 -0700

         -p0：代表忽略0层目录，即从光标所在的当前目录中查找linux-2.6.25_android/arch/alpha/boot/misc.c，然后进行patch操作
		 -p1：代表忽略1层目录，即从光标所在的当前目录中查找arch/alpha/boot/misc.c，然后进行patch操作
		 -p2：代表忽略2层目录，即从光标所在的当前目录中查找alpha/boot/misc.c，然后进行patch操作
      4. 明确光标应该定位到哪个目录   
         --- linux-2.6.25_android/arch/alpha/boot/misc.c 2010-05-06 01:56:42.565397700 -0700
         +++ linux-2.6.29_android/arch/alpha/boot/misc.c 2010-05-06 00:51:06.000000000 -0700

         patch -p0 <diff.patch 由于忽略0层目录，所以应当进入到linux-2.6.25_android/目录下时，才能执行该操作
         patch -p1 <diff.patch 由于忽略1层目录，所以应当进入到linux-2.6.25_android/arch/目录下时，才能执行该操作
         patch -p2 <diff.patch 由于忽略2层目录，所以应当进入到linux-2.6.29_android/arch/alpha/目录下时，才能执行该操作
   5. 思考：为什么要有-p(num)参数
	  1. 一个工程可以看作一个目录树，很有可能我们只对该目录树下面第n层深度目录处的某个目录进行了修改，因此只用对该子目录打补丁就行，此时就可忽略掉前面的n层目录，直接对该子目录打补丁，即-p(num)使得我们可以对目录树下的任意子目录打补丁而不是对整个工程进行打补丁
	  2. 一个工程可能是合作的产物，所以会有很多人对它进行打补丁操作，由于不同的人对文件或目录的命名方式会不同，所以导致自己本地的该目录名可能与服务器上的该目录名不同步，此时如果你还是使用对整个工程进行打补丁的方法，那么由于目录名不同步，必然无法递归进入到这个原本已经经过修改的存在差异的目录中去，出现漏打补丁的现象，所以，在多人合作的项目中，务必使用-p(num)参数，过滤掉不是你负责的那些目录，直接定位到你负责的目录下去打补丁，这样既能能做到互不干扰，又能避免漏打补丁
   6. 工程合作项目打补丁的思考
	  1. 一个工程项目一般由多个成员共同开发，由于任务分工必然会存在交叉工作，因此如果在交叉代码处出现了bug，而双方都去制作了补丁来修补这个bug的话,很可能因为文件或目录的命名不一致的问题导致第二个打补丁的人在这些命名不一致的目录处出现漏打补丁的现象
	  2. 建议，最好尽量做到分工明确，交叉的地方，由双方协作共同生成补丁，然后打一次补丁即可
   7. patch操作的4个重要参数
	  1. -p(num): num是一个数字，表示，使用patch命令给 package-dir/ 打补丁时，忽略掉前num个目录层“/”，一般用-p0,-p1
	  2. -R: 给新对象打补丁，将其还原为旧对象
	  3. -E: 如果发现空文件，就删除它
Blog creation time:[2017-10-01 日 09:46]
* DONE [#C] theme:grep命令
  CLOSED: [2017-12-26 二 14:53]
1. 文本搜索工
2. 以行为单位
3. 具支持正则表达式
4. 接收的输入: 文件,标准输入流
5. 经典示例
   1. grep -n 'the' a.txt b.txt ... 
      1. 从文件序列a.txt,b.txt,c.txt ... 中,区分大小写的匹配含有关键字符串'the'的所有行
	  2. 以带行号的形式将匹配到的这些行打印到标准输出
	  3. -n: 输出时显示行号
   2. grep -nv 'the' a.txt b.txt ...
      1. 从文件序列a.txt,b.txt,c.txt ... 中,区分大小写的匹配含有关键字符串'the'的所有行,
	  2. 以带行号的形式将除匹配到的行之外的所有行打印到标准输出
	  3. -v: 方向选择
   3. grep -ni 'the' a.txt b.txt ...
	  1. 从文件序列a.txt,b.txt,c.txt ... 中,不区分大小写的匹配含有关键字符串'the'的所有行
	  2. 以带行号的形式将匹配到的所有行打印到标准输出
	  3. -i: 不区分大小写
   4. grep -nvi 'the' a.txt b.txt ...
	  1. 从文件序列a.txt,b.txt,c.txt ... 中,不区分大小写的匹配含有关键字符串'the'的所有行
	  2. 以带行号的形式将除匹配到的行之外的所有行打印到标准输出
Blog creation time:[2017-10-17 二 15:33]
* DONE [#C] theme:sed命令
 - State "DONE"       from "TODO"       [2017-09-04 一 22:40]
** sed介绍
>> sed英文全称是stream editor,流编辑器，它是一个简单而强大的文本解析转换工具

>>在1973-1974年期间由贝尔实验室的Lee E. McMahon开发，今天，它已经运行在所有的主流操作系统上了，
	
>>支持正则表达式

>>可以从文件中接受类似于管道的输入

>>可以接受来自标准输入流的输入

>>功能同awk类似，差别在于，sed简单，对列处理的功能要差一些，awk的功能复杂，对列处理的功能比较强大

>>一次处理一行内容,处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令
处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，
直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。

>>用于：文本替换，选择性的输出文本文件，从文本文件的某处开始编辑，无交互式的对文本文件进行
编辑，自动编辑一个或多个文件，简化对文件的反复操作，编写转换程序等
** sed的工作原理
sed的内部实现遵循简单的工作流：读取，执行和显示
--读取：sed从输入流(标准输入流，文件，管道)读取一行，并存储在专用buff中
--执行：sed命令对专用的buff中的执行命令
--显示：将专用buff中由命令执行后的行发送到输出流，发送之后，专用buff会被清空
结论：
>> 行，是sed处理的基本单位
>> sed相关的命令作用于专用buff中的行，对输入流中的数据没有影响
** sed命令的两种调用形式
>> 命令模式：sed [option] 'sed_command' target_filename
>> 脚本模式：sed [option] -f command_script_files target_filename
其中，命令模式使用单引号指定要执行的命令，而脚本模式则指定了包含sed命令的脚本文件

--[option]:
-e ：直接在命令行模式上进行sed动作编辑，此为默认选项；
-f ：将sed的动作写在command_script内，-f command_script_files则可以运行其内部的动作；
-n ：默认情况下(-e)，模式空间中的内容在处理完成后将会打印到标准输出，该选项用于阻止该行为
-r ：sed 的动作支持的是延伸型正规表示法的语法(默认是基础正规表示法语法)；
-i ：直接修改目标文件的内容，而不是输出到终端 

Blog creation time:[2017-09-01 五 10:39]
* DONE [#C] theme:netstat命令
  CLOSED: [2017-12-26 二 14:54]
--功能：用于打印linux系统网络的状态信息,列出系统上所有的网络套接字连接情况，包括 
tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字

--参数：
(1) -a:显示侦听和未侦听的套接字，即列出当前所有的连接
输出：
>> Proto:被套接字使用的协议，有tcp, udp, udpl, raw四种
>> Recv-Q:没有被连接到这个套接字的用户程序复制的字节数
>> Send-Q:没有被远程主机认可的字节数

备注：该命令列出 tcp, udp 和 unix 协议下所有套接字的所有连接，然而这些信息还不够详细，管理员往往需要查看某个协议或端口的具体连接情况


Blog creation time:[2017-09-14 四 15:20]
