* shell and shellscripts
** DONE [#C] theme:shell
  - State "DONE"       from "TODO"       [2017-09-04 一 22:42]
*** 关系链：
 硬件（硬盘，CPU，网卡，显卡等） 
 <--> 
 操作系统内核（CPU进程，内存管理，I/O资源管理） 
 <--> 
 接口（Shell，X Window） 
 <--> 
 运用程序
*** shell 基本概念:
    每一个用户账号，在其用户配置文件：/etc/passwd中，都为其分配了默认shell，当用户登陆时，就能取得这个shell进行工作
 1./bin/sh：最早出现的shell，叫做Bourne Shell，简称sh
 2./bin/bash：目前的标准shell，简称bash
 3./bin/csh：语法类似C语言，称C shell，简称csh
 备注：shell是用户与linux系统内核交互的接口，而bash总是被作为标准shell安装；

 特别地，有一种shell叫做：/usr/sbin/nologin，这个shell正如其名字，如果一个用户的配置文件中的shell指明为/sbin/nologin，那么
 就表示该用户无法登陆系统取得shell，该用户相当于被锁定
*** 启动 shell 的流程:
1. 使用useradd xxx添加一个用户，则系统会在/etc/passwd以及/etc/shadow中注册该用户的信息，
包括用户名，密码，值得说明的是还分配了一个登陆shell给该用户。

2. 输入用户名，密码，登陆系统成功后，该用户会取得在/etc/passwd里面设定的默认shell；

3. 取得shell后，这个shell就是一个独立的进程，接下来在这个shell里面所执行的任何命令就称为shell的子进程；
比如：用户www在/etc/passwd里面设定的默认shell为/bin/bash,当www输入密码登陆系统后，
就会取得一个叫做bash的shell，这个bash就是一个独立的进程。此时，我们输入命令gnome-terminal打开了另一个bash，
那么新打开的这个bash称为用户默认bash的子进程，这个用户默认的bash称为父进程

4. 只有在该子进程bash结束掉后，才能回到原来的父进程bash

5. 父进程bash，产生子进程bash后，这个子进程会继承父进程的所有环境变量，而父进程的用户自定义变量则无法继承过来

小结：从登陆流程的分析，不难看出，如果将用户自定义变量转变为环境变量，那么，就可以在子进程中随意使用这些个用户定义的变量了。
下面有具体的方法。

Blog creation time:[2017-09-04 一 22:29]
*** shell 脚本
1. 注释： 以 # 开头的行为注释行

2. 特殊注释行： #！/bin/sh, 其中 #! 用来告诉系统同一行上，紧跟在它后面的那个参数是
用来执行该脚本的程序

3. shell 脚本本质上可以看作 shell 的标准输入，所以，在脚本中可以包含任何能在 PATH 
环境变量中引用到的命令

4. exit 0: 确保脚本程序能够返回一个有意义的退出码，这个退出码的用途在于，如果你打算
从另一个脚本程序里调用这个脚本，并检查它是否执行成功，返回一个适当的退出码就显得十分重要。
在 shell 程序设计里， 0 表示成功，如果脚本没有错误， 且存在该指令，那么执行该脚本后会返回0

5. 运行脚本： 
- 给你的脚本加上可执行的权限： chmod u+x first.sh
- 运行： ./fisrt.sh
备注：当你确信你的脚本程序能够正确执行之后，你可以将其添加到 /usr/local/bin 中去， 如果
你的脚本只是想自己使用，建议在将其移动到自己的家目录下面的 bin 目录中去。
注意：为了防止其他用户修改你的脚本，你应当去掉你的脚本的写权限。

6. 当你在终端里面运行  ./first.sh 时，linux 会重新为 first.sh 这个脚本开启一个 shell 进程

7. 在linux中，&和&&,|和||介绍如下：
   1. &  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &
   2. && 表示前一条命令执行返回的结果为真时，才执行后一条命令 ，如 echo '1‘ && echo '2'    
   3. | 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l
   4. || 表示上一条命令执行返回的结果为假，才执行下一条命令，如 cat nofile || echo "fail"
*** shell 语法
**** 变量
    - State "DONE"       from "TODO"       [2017-09-04 一 22:42]
***** 认识变量
1. 变量有两种类型：环境变量（系统默认变量）；用户自定义变量；

2. 环境变量能够被子进程继承引用，因此，可以将环境理解为全局变量；

3. 用户自定义变量只能在当前进程中使用，子进程不能继承引用，因此，可以将用户自定义变量理解为局部变量；

4. 在 shell 里，使用变量之前并不需要事先声明， 通过使用他们（比如赋值）来创建他们

5. 在默认情况下，所有的变量都被看作字符串并以字符串来存储，即便他们被赋值为数值也是如此，shell 和一些工具会在需要时将数值型字符串转换为对应的数值以对他们进行操作

6. Linux 是一个区分大小写的系统， 因此，shell 是区分大小写的

7. 从硬件的角度理解用户自定义变量和环境变量：
	 1. 当启动一个shell时，操作系统分配一块内存给shell，存储在该内存的变量可以被子进程访问到；
   2. 只有环境变量才会被存储到这一内存上，用户自定义的变量不可以；
   3. 使用export命令就可以实现将用户自定义的变量写到这块内存上，所以其子进程就能访问到了；

8. 在bash中，变量只能指定为字符串类型，整型，常量类型，数组类型；

9. 在bash中，变量的作用域有局部和全局两种，局部变量称为用户自定义变量，全局变量称为环境变量；

10. 创建变量时，如果变量的值包含空格，那么需要用引号将其引起来
***** 操作变量
1. 查看系统中所有变量：set >set-info.txt

2. 查看系统中的所有环境变量：env >env-info.txt

3. 自定义变量转换为环境变量：export

4. 环境变量转换为用户自定义变量：declare； 事实上，declare是声明变量类型的关键字，可以通过它来指定变量的类型

5. 创建变量： a="hello world";   b=3+5 

6. 键盘输入：read a, 这条命令使得当 shell 解析该脚本的过程中解析到这一命令时，光标停顿，等待用户输入，输入的内容赋值给变量 a

7. 获取变量 a 的内容： $a  

8. 输出打印：echo $a
***** 变量的规范
   1.正确：
   1-1:var1=12------>12
   1-2:myname="lin jia jun"----->lin jia jun
   1-3:var2="lang is $LANG"----->lang is zh_CN.UTF-8
   1-4:var3='path is $PATH'----->path is $PATH
   1-5:var4="you need pay for \$20"----> you need pay for $20
   1-6:PATH="$PATH":/home/bin  export PATH
   1-7:通常大写字母为系统变量，小写字母为用户自定义变量
   1-8:取消变量：unset myname
   1-9:单引号与双引号的区别：
   --单引号：1-4所示，内容仅作为纯文本
   --双引号：1-5所示，试图解释变量
   --不带引号：其内容不能有空格，如paths=/home/ljj
   --带引号：其内容需要空格,如myname="lin jia jun"
   1-10:花括号与括号的区别：
   --花括号：myname="lin jia jun" --- echo ${paths} --- /home/ljj
   --括号：pwd=/home/ljj paths="$(pwd)" --- echo ${paths} --- /home/ljj
   --结论：${变量}   $(命令),注意，pwd是命令，但是PATH是变量
   --建议：为避免混乱，定义变量一律采用：变量="内容的形式",显示一律采用：echo ${变量}的形式

   2.错误：
   2-1:var1 = 12,等号两边有空格
   2-2:var2=lin jia jun,等号右边有空格
   2-3:4var=12,数字开头
***** 自定义变量
   1.定义，用户自定义变量：a="b c d"  ; lin="$(pwd):lin jia jun"
   2.显示，用户自定义变量：echo ${a}  ; echo $(pwd)
   3.销毁，用户自定义变量：unset a    ; unset lin
   Blog creation time:[2017-09-04 一 22:30]
**** 环境变量
    - State "DONE"       from "TODO"       [2017-09-04 一 22:42]
***** 认识环境变量：
   1.环境变量是特殊的可以理解为全局变量，在子进程和父进程中都能使用；
   2.环境变量一定是大写；
   3.为了安全起见，不建议将当前目录.加入到环境变量PATH中去；
   4.不同身份的用户，默认的PATH是不同的；
   2.自定义变量转换为环境变量：export
   3.环境变量转换为用户自定义变量：declare
***** 常见的环境变量
1. PATH：该环境变量给出的是执行文件的查找路径；

2. HOME：该环境变量给出用户的家目录路径:/home/ljj

3. LANG：该环境变量给出当前系统的默认语系，如：en_US.UTF-8或者zh_CN.UTF-8或者zh_CN.gb2312

4. SHELL：该环境变量给出当前系统使用的shell，如/bin/bash

5. MAIL：该环境变量给出当我们使用mail命令去收信时，系统会去该路径下读取邮件信箱文件，如/var/spool/mail/ljj

6. HISTSIZE：该环境变量给出系统记录我们执行过命令的条数，默认是1000条

7. RANDOM:这是一个随机数变量，可以当成一个随机数生成器，默认随机范围在（0~32767），也就是/dev/random这个文件。
	 1. 如果想使用随机数生成器，生成一个任意范围内的数，如（0~9），则可以作如下转换：
   2. declare -i number=${RANDOM}*10/32768
   3. 显然，可以些一个shell scrip包含该语句，每次执行就能它，就能产生(0~9)范围内的随机数

8. $: 当前开启的 shell 的 PID， 通过 echo "$$" 进行查看，注意，如果 echo "$$" 是在shell脚本中，那么显示的是shell脚本的进程ID

9. #：传递给脚本参数的个数，不包括脚本的名字

10. $0: 脚本的名字（./first.sh）

11. $1: 传递给脚本的第一个参数

12. $2: 传递给脚本的第二个参数，依次类推

13. ?: 上一条执行命令的回传码，0表示执行成功；

14. $*： 以 IFS 中的第一个字符为分割符，存储脚本的所有参数列表, 建议使用 $@

15. $@: 总是以空格分割，存储脚本的所有参数列表

15. PS1:命令提示符，默认PS1='[\u@\h \W]\$ ';
    1. \d：以“星期月日”的格式显示日期；
    2. \H：完整主机名
    3. \h：仅主机名第一个小数点之前的名字
    4. \T：显示时间，12小时格式
    5. \t：显示时间，24小时格式
    6. \u：显示用户名
    7. \v：显示shell版本
    8. \w：完整的当前工作目录名称
    9. \W：当前工作目录最后一个目录的名称
    10. \＃：执行的第几个命令
    11. \$:提示符，如果是root时，提示符为＃，否则为$
    备注：我的PS1:PS1='<\u@\# \t \w>\$ '

16. PS2:二级提示符，用来提示后续的输入，通常是 <

17. IFS:输入域分割符，，当shell 读取输入时，用该变量给出的分割符来分割一组字符

18. OSTYPE:操作系统位数

19. pwd:显示当前路径
***** PATH环境变量的规范：
   3-1.例：/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:\
          /home/ljj/.local/bin:/home/ljj/bin
   3-2.采用 ：来分隔，与windows里面的 ；作用一样
   3-3.在查找命令时，是按照PATH给的路径的顺序来查找，在哪个路径先找到，就先执行哪个路径下的命令
   3-4.不同的用户，默认的PATH不同，默认能够随意执行的命令也不同
   3-5.当前目录./不要放置到环境变量中去
***** 添加环境变量
   1. 将gcc-arm-none-eabi添加进环境变量:
      export PATH="$PATH:$HOME/usr/local/bin:$HOME/stm32/arm-none-eabi-gcc/gcc-arm-none-eabi-5_4-2016q3/bin"
   2. 临时添加环境变量： PATH＝"${PATH}":home/ljj   export PATH
   3. 永久添加环境变量: emacs /etc/environment
   追加：
   /usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/home/ljj/.local/bin:/home/ljj/bin
   :/home/ljj
***** 将用户自定义变量转换为环境变量
   1.方法一：export xxx（其中xxx是一个用户定义的变量）
   2.方法二：declare -x xxx （其中xxx是一个用户定义的变量）
***** 将环境变量转换为用户自定义变量
   --declare +x xxx （其中xxx是一个环境变量）
***** 语系变量
   1.Linux默认支持多国的语言，不同的语言有不同的语系，采用a语系书写的文档，采用b语系查看会出现乱码
   2.查看所有语系：locale -a，这些语系存放在/usr/lib/locale目录下面
   备注：不要与文件查找命令locate xxx 混淆
   3.查看当前语系：locale 
   4.语系的设置：
   原则上，设置语系，就需要逐一的设置使用locale命令所罗列出来的语系变量，但事实上，如果你设置了
   LC_ALL和LANG，其它语系都没有设置，那么，其它语系都会被这两个变量所替代。如：
   LC_ALL=en_US.UTF-8;LANG=en_US.UTF-8;export LANG；export LC_ALL 
   5.整体系统默认的语系定义：/etc/sysconfig/i18n
***** 键盘读取变量：read
   1.意义：
   1-1.键盘读取变量read的值，由用户从键盘输入给于赋值；
   1-2.其重要价值在于能与用户进行交互；
   1-3.该变量多用于shell script中；
   1-4.read相当于c中的scanf，echo相当于c中的printf；

   2.命令：read -p “Please input you name: ” -t 30 named
   备注:-p指定后面接提示语句;-t指定超时时间为30s
***** 声明变量的类型：declare
   1.意义：
   1-1.在bash中，默认情况下，变量的类型为字符串，所以num=300+100,当echo ${num}时，结果是300+100 
   1-2.declare可以声明变量的类型以适应不同场合，如：declare -i num=300+100,当echo ${num}时，结果是400

   2.命令：
   2-0.查看变量的类型：declare -p num 
   2-1.定义局部字符串类型变量：declare num=300+100  --- num=300+100 
   2-2.定义局部整型变量：declare -i num=300+100    --- num=400 
   2-3.定义全局变量(环境变量）：declare -xi num=300+100 --- num=400(全局有效)
   2-4.定义局部常量：declare -r num="lin jia jun" （类似于c的const变量，不可更改，不可重设）
   备注：常量又叫只读变量，如果你将一个变量声明为只读，那么，只能注销再登陆才能复原该变量的类型了
   2-5.定义数组：
   2-1.定义：arry[1]="hello"  arry[2]="world"
   2-2.打印：echo “${var[1]},${var[2]}” 
   2-6.将环境变量转换为用户自定义变量：declare +x sum
***** 资源限制
   1.背景：
   Linux是多用户操作系统，它允许多个用户同时使用这台计算机，但是存在下面所述的问题：
   假设某Linux主机有10个用户，这10个用户同时打开了100个文件，这些文件每个大约有10M，显然，该主机
   需要提供10G的内存才行，这显然是不现实的，所以，我们需要对主机的某些资源，如打开文件的数量个，可以
   使用的CPU时间，可以使用的内存总量的做出限制。

   2.查看当前用户的资源限制情况：ulimit -a

   3.限制可创建单一文件的大小：ulimit -f 10240  （默认单位是KB）  限制--10M
   备注：
   --想要复原ulimit限制最简单的办法就是注销再登陆
   Blog creation time:[2017-09-04 一 22:31]
**** 条件语句
***** 基础知识
 1. test 或者 [ 是 shell 的布尔判断命令，在一些系统上，这两个命令的作用是一样的

 2. 为了增强可读性，在使用 [ 命令时，我们还会使用 ] 来结尾

 3. test 命令是shell内置的一个命令，使用 which test 可以返回 /usr/bin/test

 4. test 经常被用户拿来作为一些测试程序的名字，这有可能引起程序工作不正常，建议用户测试程序中使用 ./test的形式
***** 基础语句
****** 文件存在性测试
|---------+------------------------------------------------------------|
| 参数    | 结果                                                       |
|---------+------------------------------------------------------------|
| -f file | 如果文件名存在，且是一个普通文件，则结果为真               |
|---------+------------------------------------------------------------|
| -d file | 如果文件名存在，且是一个目录，则结果为真                   |
|---------+------------------------------------------------------------|
| -b file | 如果文件名存在，且是一个 block device 设备，则结果为真     |
|---------+------------------------------------------------------------|
| -c      | 如果文件名存在，且是一个 character device 设备，则结果为真 |
|---------+------------------------------------------------------------|
| -S      | 如果文件名存在，且是一个 Socker 文件，则结果为真           |
|---------+------------------------------------------------------------|
| -p      | 如果文件名存在，且是一个 FIFO(pipe)文件，则结果为真        |
|---------+------------------------------------------------------------|
| -L      | 如果文件名存在，且是一个链接文件，则结果为真               |
|---------+------------------------------------------------------------|

****** 文件权限测试
|---------+------------------------------------------------------|
| -r file | 如果文件可读，则结果为真                             |
|---------+------------------------------------------------------|
| -w file | 如果文件可写，则结果为真                             |
|---------+------------------------------------------------------|
| -x file | 如果文件可执行，则结果为真                           |
|---------+------------------------------------------------------|
| -s file | 如果文件大小不为0, 则结果为真                        |
|---------+------------------------------------------------------|
| -u file | 如果文件存在，且具有 SUID 的属性，则结果为真         |
|---------+------------------------------------------------------|
| -g file | 如果文件存在，且具有 SGID 的属性，则结果为真         |
|---------+------------------------------------------------------|
| -k      | 如果文件名存在，且具有 Sticky bit 的属性，则结果为真 |
|---------+------------------------------------------------------|
| -s      | 如果文件名存在，且为非空白文件，则结果为真                            |
|---------+------------------------------------------------------|
****** 文件之间的比较
|-----------------+----------------------------------------------------|
| file1 -nt file2 | 如果 file1 比 file2 的时间戳新，则结果为真         |
|-----------------+----------------------------------------------------|
| file1 -ot file2 | 如果 file1 比 file2 的时间戳旧，则结果为真         |
|-----------------+----------------------------------------------------|
| file1 -ef file2 | 如果 file1 和 file2 均指向同一个 node， 则结果为真 |
|-----------------+----------------------------------------------------|
****** 算数比较
|-----------------+-----------------------------------------------|
| expr1 -eq expr2 | 如果 expr1 和 expr2 的数值相等，则结果为真    |
|-----------------+-----------------------------------------------|
| expr1 -ne expr2 | 如果 expr1 在数值上不等于 expr2，则结果为真   |
|-----------------+-----------------------------------------------|
| expr1 -gt expr2 | 如果 expr1 在数值上大于 expr2, 则结果为真     |
|-----------------+-----------------------------------------------|
| expr1 -lt expr2 | 如果 expr1 在数值上小于 expr2, 则结果为真     |
|-----------------+-----------------------------------------------|
| expr1 -ge expr2 | 如果 expr1 在数值上大于等于 expr2, 则结果为真 |
|-----------------+-----------------------------------------------|
| expr1 -le expr2 | 如果 expr1 在数值上小于等于 expr2, 则结果为真 |
|-----------------+-----------------------------------------------|
****** 与，或，非
|--------------------+----------------------------------------------|
| -r file -a -x file | 如果 file 同时具有 rx 权限，则结果为真       |
|--------------------+----------------------------------------------|
| -r file -o -x file | 如果 file 具有 r 权限或者 x 权限，则结果为真 |
|--------------------+----------------------------------------------|
| ! -r file          | 如果 file 不具有 r 权限，则结果为真          |
|--------------------+----------------------------------------------|
****** 字符串之间的判定
|--------------+-----------------------------------|
| -z str       | 如果 str 为空字符串，则为真       |
|--------------+-----------------------------------|
| -n str       | 如果 str 不为空字符串，则为真     |
|--------------+-----------------------------------|
| str1 == str2 | 如果 str1 等于 str2, 则结果为真   |
|--------------+-----------------------------------|
| str1 != str2 | 如果 str1 不等于 str2, 则结果为真 |
|--------------+-----------------------------------|

示例：
 #+BEGIN_SRC test
 if test -f fred.c
 then
 ...
 fi
 #+END_SRC
 #+BEGIN_SRC [
 if [ -f fred.c ]; then
 ...
 fi
 #+END_SRC
***** 条件语句的经典用法
****** &&, || 
#+BEGIN_SRC 
test -d /bin && echo "exit" || echo "not exist"
#+END_SRC
****** 在脚本中捕获用户在命令行的输入，判断输入是否为空
#+BEGIN_SRC 
echo "plese input a filename,and i will check the filename's type and permission.\n\n"

read -p "Input a file name:" filename

test -z $filename && echo "you must input a filename" && echo exit 0
#+END_SRC
****** 判断文件是否存在，如果不存在，则显示信息并结束脚本
#+BEGIN_SRC 
test ! -f $filename && echo "The filename '$filename' Do not exist" && exit0
#+END_SRC
****** 解析文件
#+BEGIN_SRC 
test -f $filename && filetype="regulare file"
test -d $filename && filetype="directory"
test -r $filename && permission="readable"
test -w $filename && permission="$permission writeable"
test -x $filename && permission="$permission executable"

echo "The filename: $filename is a $filetype"
echo "And the permission is: $permission"
#+END_SRC
****** 脚本提示用户选择 Y 或者 N，如果输入 Y 则显示 contine, 如果输入 N，则显示 interrupt, 其他则显示 I don't no what mean
#+BEGIN_SRC 
read -p "Please input Y/N: " yn 
[ yn == 'Y' ] && echo "contine"
[ yn == 'N' ] && echo "interrupt" || echo "I don't know what mean"
#+END_SRC
** DONE [#C] theme:shell的环境配置文件
  - State "DONE"       from "TODO"       [2017-09-04 一 22:42]
*** bash的环境配置文件介绍：
 1.为什么我们刚进入bash就有一堆有用的变量，如pwd，PATH，HOME等？显然，
 系统有一些环境配置文件存在，用于规划bash的操作环境；
 2.系统的环境配置文件分为全体系统配置文件以及用户个人偏好配置文件；
 3.只有写入配置文件中的变量或者环境变量才能永久有效，在当前会话配置的只对本次会话有效，注销重启后配置消失；

*** login shell 与 non-login shell：
 1.login shell：取得bash需要完整的登陆流程的（输入账号和密码），称为login shell；
 2.non-login shell：取得bash不需要重复登陆，如进入x window界面时输入一次账号和密码，在x window
 下面进入bash终端时，不再需要账号和密码，就称，此时的shell为non-login shell；
 3.login shell 与 non-login shell取得bash过程中，读取配置文件数据不一致。

*** 配置文件的分类：
**** 从全局和用户个人的角度：
 1.系统全局配置文件：/etc/profile  (不可轻易修改)

 2.用户个人配置文件：~/.bash_profile或~/.bash_login或~/.profile
 备注：之所以会有这么三个文件，是为了照顾从其它shell转换过来的用户，实际系统中只会有一个存在，
 bash也只会按照上面的顺序找一个来读取，先找到谁读取谁，我的Linux给出的是~/.bash_profile

**** 从 login shell 与 non-login shell的角度
 1.取得login shell后读取的配置文件：
 1-1. /etc/profile 
 1-2. ~/.bash_profile或~/.bash_login或~/.profile
 备注：3-2的三个配置文件我用了或，事实上，bash的login shell只会读取上面三个配置文件中的一个，并且，
 读取规则如下：首先查找~/.bash_profile是否存在，存在则读取，且不再去管~/.bash_login或~/.profile
 如果不存在~/.bash_profile，接着查找~/.bash_login，若存在则读取，不管~/.profile，若不存在，接着查找
 ~/.profile。

 2.取得non-login shell后读取的配置文件：
 2-1.~/.bashrc 
 2-2./etc/bashrc
 2-3./etc/profile.d/*.sh
 备注：non-login shell调用2-1,2-1调用2-2,2-2调用2-3
*** 详解/etc/profile：
 1.文件简介：
 1-1.该文件是全体系统配置文件；
 1-2.该文件不建议轻易修改；
 1-3.该文件只会被login shell读取；
 1-4.每个用户取得bash后必须去读取该文件；
 1-5.该文件除了设置一些环境变量的逻辑之外，还调用其它外部文件。

 2.涉及的文件及文件内容：
 2-1./etc/profile：bash会去读取的文件；
 2-2./etc/inputrc：
 --/etc/profile主动判断用户有没有自定义输入按键的行为，决定是否设置INPUTRC这个环境变量；
 --该文件内容为bash的热键,[TAB]有无声音等数据，一般用户不用再去配置它；
 2-3./etc/profile.d/*.sh：
 --在profile.d目录下后缀为sh的且具有r属性的文件都会被/etc/profile调用；
 --在profile.d目录下后缀为sh的这些文件规定了bash接口的颜色，语系，命令的别名等；
 2-4./etc/sysconfig/i18n：
 --这个文件由/etc/profile.d/lang.sh调用；
 --该文件决定了bash默认使用的语系，文件里面有LANG这个重要的环境变量；

 3.完成工作：
 3-1.内部处理路径PATH；
 3-2.内部处理默认权限；
 3-3.内部处理环境变量：USER、MAIL、HOSTNAME、HISTSIZE；
 3-4.外部调用文件:/etc/inputrc   （自动判断是否调用）
 3-5.外部调用文件:/etc/profile.d/*.sh  (在profile.d目录下后缀为.sh且具有r权限的文件会被/etc/profile调用) 
 3-6.外部调用文件：/etc/sysconfig/i18n  (由profile.d目录下的lang.sh调用) 
*** 详解~/.bash_profile
 1.文件简介：
 1-1.该文件是用户个人的配置文件，每个用户都有一个；
 1-2.该文件只会被login shell读取；
 1-3.每个用户取得bash首先读取/etc/profile，然后再读取各自的~/.bash_profile文件；
 1-4.该文件会去判断~/.bashrc是否存在，若存在则调用；

 2.文件内容：
 2-1.判断~/.bashrc是否存在，存在则读取该文件的设置。
 2-2.设置PATH这个变量。由于在/etc/profile里面已经设置过，所以，这里的设置会以累加的方式载入；
 备注：该文件下的PATH变量在设置完毕后还用export将PATH变量转换为环境变量，所以，一些第三方软件
 的可执行文件的路径可以添加到这来，之后随便在哪个地方都可以执行。

 3.详解~/.bashrc  （non-login shell会读取的文件）
 3-1.该文件是由~/.bash_profile调用；
 3-2.该文件还调用了/etc/bashrc;
 3-3.该文件还会被non-login shell读取；
 3-4.该文件做了两件事：第一，调用/etc/bashrc；第二，配置别名
 备注；需要特别注意的是，配置别名的工作主要是在root的~/.bashrc下面进行的，一般用户的~/.bashrc配置的别名是不起作用
 3-5./etc/bashrc详解：
 3-5-1.依据不同的UID规定了unmask的值；
 3-5-2.依据不同的UID规定了PS1的值；
 3-5-3.调用/etc/profile.d/*.sh文件；
*** bash配置文件的读入指令source
 1.我们要修改bash配置文件的步骤应该是这样的，首先登陆系统取得login shell，然后，修改上面所述的配置文件；
 2.由于/etc/profile和~/.bash_profile都是在用户取得login shell后才读取的，所以，这次的修改
 当前的login shell是加载不到的，所以得注销后重新登陆，取得login shell；
 3.基于上面得解释，我们可能希望当前修改了bash得配置文件，不用注销重新登陆就能生效，那就使用source命令；
 4.source命令：source 配置文件名，例如：source ~/.bash_profile；
 备注：也可以用：小数点 配置文件，的方式来替代source命令，如：. ~/.bash_profile;
*** 其它相关配置文件
 1./etc/man_db.config:该文件里面有一个MANPATH变量，该变量可以指定man指令的查找路径；
 2.~/.bash_history：记录该用户上次登陆bash时操作的命令
 3.~/bash_logout：可以写一写脚本，要求bash离开后为我们做一些扫尾的工作
 Blog creation time:[2017-09-04 一 22:32]
** DONE [#C] theme:重定向
	 - State "DONE"       from "TODO"       [2017-09-04 一 22:43]
1. 重定向的对象是标准文件描述符，用0代表标准输入，1代表标准输出，2代表标准错误输出；
默认情况下不加文件描述符的话就代表对标准输出进行重定向
 
2. 文件描述符都很多，一般情况下，对0,1,2以外的文件描述符重定向是很少见的；
   
3. 对标准输出进行重定向：
> 该操作符默认以新建或覆盖的方式将 标准输出 重定向到一个文件
>> 该操作符默认以新建或追加的方式将 标准输出 重定向到一个文件
示例： ls -al 1> /home/ljj/info.txt   ls -1 >> /home/ljj/info.txt

4. 对标准输入进行重定向：
more < killout.txt
该操作会去 killout.txt 中读取文件内容，然后作为参数传递给 more  

5. 对标准错误输出进行重定向：
- 标准错误重定向的文件描述符号为2
- 示例：
将标准输出和标准错误分别重定向到不同的文件：kill -9 6500 1>killout.txt 2>killerr.txt  
将标准输出重定向到一个文件中然后将标准错误重定向到与标准输出相同的文件（注意顺序）：kill -9 6500 1>kill.txt 2>&
意义： 在该示例中，当 6500 进程不存在时，执行 kill 所产生的错误信息会被重定向到指定文件而不会输出到屏幕

Blog creation time:[2017-09-04 一 22:34]
** DONE [#C] theme:管道
	 - State "DONE"       from "TODO"       [2017-09-04 一 22:43]
1. 管道的作用： 连接进程，Linux 下，通过管道连接的进程可以同时运行，并且随着数据流
在他们之间的传递可以自动协调

2. 管道操作符：|

3. 示例：ps -xo comm | sort | uniq | grep -v sh | more
在这组命令中，数据流从左往右边依次传递

4. 管道能连接的进程数目没有限制
	 
5. 不要在命令流中使用相同的文件名
例如：cat mydata.txt | sort | uniq > mydata.txt,将得到一个空文件，
原因是在管道操作中，| 连接的进程在得到最终结果之前是同时执行的， >操作符在得到结果之前先覆盖了mydata.txt

Blog creation time:[2017-09-04 一 22:33]
** DONE [#C] theme:通配符与特殊符号
  - State "DONE"       from "TODO"       [2017-09-04 一 22:43]
*** 常见的通配符
 1.*:代表0到无穷多的任意字符
 2.?:代表一定有一个字符
 3.[]:代表一定有一个在中括号内所列出的字符
 4.[-]:代表编码顺序范围内的所有字符
 5.[^]:代表除了中括号内给出的字符外，只要存在就接受
Blog creation time:[2017-09-04 一 22:32]
** theme: 基础操作
*** 查看shell版本号: /bin/bash --version
*** 查看系统有哪些shell: less /etc/shells
*** 切换shell: /bin/zsh
*** 退出shell: exit 
*** 获取子进程的输出：$(...)
