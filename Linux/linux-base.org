* DONE [#C] theme:linux基础概念
 - State "DONE"       from "TODO"       [2017-09-04 一 22:40]
** 计算机系统：
1.硬件<-->内核<--->系统调用（shell）<--->应用程序
** Linx简史：
    时间      人物                      事件                    意义					
-->196x年     MIT                      分时操作系统（CTSS）      一台主机可以提供多个（30台以内）终端机，近代操作系统的鼻祖，划时代
-->1965年     Bell＋MIT＋GE（通用电器）   Multics项目             计划实现一台主机提供300台以上的终端机
-->1969年     Bell                     退出Multics项目          UNIX萌芽期，Multics项目培养了出相当优秀的人才，Ken Thompson退出该项目之后有了一些想法
-->1969年     Ken Thompson             在PDP－7上用编写UNIX内核   实现UNIX的雏形
-->1973年     K&R                      发明C语言并重写了UNIX内核  UNIX正式诞生
...           ...                      ...                     ...
-->1979年     谭宁邦                    写了一个UNIX Like：Minix  用于教育，但是Linux的诞生奠基者
-->1984年     Richard Mathew Stallman  发起GNU项目              不可磨灭
-->1984年     Richard Mathew Stallman  Emacs诞生                神器
-->1984年     Richard Mathew Stallman  GCC Bash诞生             意义重大
-->1985年     Richard Mathew Stallman  GPL（通用公共许可证）       自由软件
-->1988年     MIT                      XFree86项目              GUI 
-->1988年     Linus Torvalds           学习Minix，捣鼓inter 386   Linux萌芽
-->1991年     Linus Torvalds           在BBS上宣称自己写了一个小内核 Linux诞生
** 查看内核版本：
uname -r:4.10.17
备注：主次版本为奇数，开发中版本
     主次版本为偶数，稳定版本
** 几个专有名词
1.GPL：通用公共许可证，GNU的版权声明
2.POSIX：可携式操作系统接口，目的在于规范内核与应用程序的接口，由IEEE发布
3.LSB：Linux标准规范，厂商征对Linux的内核设计不同distributions时的参考标准
4.FHS：目录架构规范，厂商征对Linux的内核设计不同distributions时的参考标准
5.BSD：开源的一种授权模式
6.Linux distributions安装软件的两大系统：
6-1:RPM，RedHat  Fedora  SUSE属于此类  
6-2:DPKG，Debian Unbuntu 属于此类
** 磁盘介绍
1.磁盘的物理组成：磁片、磁头、主轴马达、机械手臂
2.磁盘的工作原理：控制主轴马达让磁片转动，控制机械手臂，带动磁头在磁片上进行读写
3.详细剖析：
3-1:磁头：磁头是用线圈缠绕在磁芯上制作而成的，磁头可以在磁片上读写数据，其依据的原理是，盘片的电阻值会随着磁场的变化而变化
    磁头读数据的原理：通过感应旋转盘片上磁场的变化来读数据
    磁头写数据的原理：通过改变盘片上的磁场来写入数据
    工作时，磁头悬浮在高速旋转的盘片的上方而不与之接触，两者之间的间隙是0.1~0.3um，不工作时，磁头自动落回盘片上，此位置作为盘片的起始位置
3-2:磁头数：每个盘片有一个磁头，所以，盘片数总等于磁头数
3-3:盘片：在铝合金或者玻璃基底上涂磁性材料和其他多种材料加工制成
3-4:圆盘数：就是盘片的数量        
3-5:磁道：当磁头在磁片圆心到半径长度的范围内的某一位置禁止不动，磁片旋转，则磁头会在磁片上产生一个以当前位置到圆心距离为半径的圆形轨迹，
	   这样的一个轨迹称为磁道，显然，可以在圆心到半径的范围内有若干这样的磁道；
3-6:磁柱：磁盘通常由多个盘片构成，而且每个盘片都被划分成数目相等的磁道并从外向内编号，如此，各个盘片编号相等的磁道构成一个柱面
3-7:磁道数：磁道是从盘片外圈往内圈编号0磁道，1磁道...，靠近主轴的同心圆用于停靠磁头，不存储数据；
3-8:扇面：由磁盘圆心以放射状的方式分割整个盘片，称，由相邻量条射线半径、圆心以及盘片外边圆轮廓所围成的区域为一个扇面
3-9:扇区：相邻两条射线，相邻两个磁道围成的四边曲边梯形，称为一个扇区。扇区是磁盘读写擦出的最小单位，每个扇区大小固定为512B，每个扇区的两端都有一些特定的数据，这些数据构成扇区的界限标志

** 磁盘的第一个扇区：
1.磁盘的第一个扇区是非常重要的，它记录了该磁盘的两个重要信息，分别是：
1-1.MBR：Master Boot Record,主引导加载分区，该分区有446B，里面安装最基本的引导加载程序，系统开机时，会主动去读取该区的内容
1-2.分区表：Partition table,有64B，用来记录整块硬盘的分区状态
** 分区表：partition table
1.分区表： 
有时我们需要对磁盘进行分区，而分区的状态就被记录在了分区表里面，分区是以磁道（柱面）为参考标准的，其最小单位是柱面，64B的分区表被分为4组，每组16B，记录了
该区段的起始与结束的柱面号码，如，假设有400个柱面，1~100柱面为第一主分区，200~300柱面为第二主分区，300~400柱面为第三主分区，则，第一组的16B就为1~100,依次类推。
需要注意的是，第一个扇区里面的分区表记录的是主分区或扩展分区。
2.结论：
2-1:所谓的“分区”，只是针对那64B字节的分区表进行设置而已；
2-2:磁盘的默认分区表总共只能写入4组主分区或者扩展分区信息；
2-3:分区的最小单位是柱面；
2-4:利用那64字节来扩展更多的分区：
	上面2-2提到，磁盘分区表只能写入4组分区信息，但是，如果我们想要分更多个区怎么办，那就使用扩展分区技术，其原理如下：
2-4-1:假定磁盘有400个柱面，有分区表里面第一组标记为主分区，比如1~100柱面为第一主分区；
2-4-2:第二组标记为扩展分区，比如101~400柱面为扩展分区；
2-4-3:第三组和第四组标记为无记录；
2-4-4:对扩展分区所标记的分区号，从101开始的一块区域拿出来比如拿80B，作为扩展分区记录区，这个记录区标记101~160为第一逻辑分区，161~220为第二逻辑分区，221~280
	  为第三逻辑分区，281~340作为第四逻辑分区，340~400作为第五逻辑分区
2-4-5:逻辑分区，扩展分区持续切割就切割出来了一些个逻辑分区
2-4-6主分区，扩展分区，逻辑分区的关系：
	我们说磁盘的第一个扇区中后64个字节用作分区表，这个分区表以柱面单位为参考，要么是全部用来记录主分区的分区情况，要么是用来记录主分区和扩展分区混搭的分区情况，显然，
第二中种情况混搭的情况必然会产生一个针对扩展分区的分区表，该扩展分区的分区表用来记录逻辑分区的分区情况。事实上，我们将按扩展分区表所分的区称为逻辑分区，不要将扩展分区
与逻辑分区搞混，扩展分区受操作系统的限制最多只能有一个，在第一扇区的64字节的第二组中指定，这个扩展分区一般情况下，就是磁盘中除了主分区以外的所有磁盘空间，可以将扩展分
区理解为逻辑分区的一个全集。
备注：扩展分区最多只能有一个，主分区最多只能有4个；
	 逻辑分区是由扩展分区持续切割出来的分区；
	 主分区与逻辑才能被格式化，扩展分区不能；
	 扩展分区被破坏的话，所有逻辑分区都将会被删除；
	 磁盘的第一扇区的MBR与分区表如此重要，所以，硬盘的第一个扇区物理坏掉的话，那么，整个硬盘大概没用了
     逻辑分区的设备文件名号码一定由5号开始
** CMOS与BIOS：
1.CMOS是一块内存芯片，这块内存用来记录各项硬件参数；
2.BIOS是直接写死到主板芯片中一某一快闪存或者EEPROM芯片上的一套程序；
3.CMOS的主要功能：记录主板上的重要参数，包括系统时间，CPU电压与频率，各项设备的I\O地址，以及IRQ等，记录这些数据需要用电，所以主板上有电池；
4.BIOS的主要功能：开机第一个执行的程序，开机时，BIOS首先加载CMOS中的参数，然后根据在BIOS中设置的启动项去加载相应存储设备里面的操作系统
** 开机流程：
1.按电源开机；
2.计算机自动加载写死到主板闪存中的BIOS程序；
3.BIOS首先将加载CMOS中的各项参数；
4.BIOS接着去分析计算机中当前有哪些存储设备，然后根据用户设置的开机启动项BOOT尝试去取得存在的硬盘；
5.BIOS到硬盘里去读取硬盘的第一个扇区的MBR，BIOS的任务就完成了，接下来交给MBR去引导；
6.MBR程序里面有一段引导加载程序Boot loader，是操作系统在安装的时候所提供的，所以，这段引导加载程序会去加载操作系统的内核文件，MBR的任务也完成了，接下来交给内核文件；
7.内核文件开始调用操作系统的其他代码开始相关的功能。
** Boot loader:
1.计算机硬件提供了BIOS和CMOS的支持，而硬盘的物理上提供了MBR，BIOS调用CMOS和MBR，而在我们安装操作系统的时候，操作系统往MBR里面写了一段Boot loader，这个Boot loader去调动
操作系统的内核，操作系统的内核去调用操作系统的其他组件。Boot loader会作三件事：
1-1.提供菜单：用户可以选择不同的开机选项；
1-2.载入内核文件；
1-3.转交其他loader，这句话的意思是，计算机可以有多个loader，这意味着，Boot loader不但可以安装在MBR，还可以安装在每个分区的引导扇区，这意味着每个分区都可以有启动扇区，这意味着多重引导，
     这意味着双系统，多系统的可能性。
1-4.bootloader可以安装的地点有两个：MBR和boot sector
** 多重引导的流程：
1.MBR里面的Boot loader提供两个菜单，第一个是直接加载Windows内核的菜单，第二个是将加载工作转交给第二分区的启动扇区；
2.选择第二个启动菜单，该分区的引导加载程序只有一个启动菜单Linux
备注：安装双系统时，应当先安装windows再安装Linux，应为Windows在安装时没有提供给我们选择菜单的，它会直接覆盖调MBR以及自己所在分区的启动扇区，而Linux就有提供选项菜单
** 内核文件：
	当安装操作系统时，内核文件是被安装到各自分区的，比如C盘安装Windows，D盘安装Linux，那么Windows的内核文件是放到C盘，Linux的内核文件放到D盘，loader只会认识自己系统分区里面的内核文件
以及其他loader而已。
** 关于Linux的命令：
	command [-optional] parameter1 parameter2 ...
1:[-optional]作为参数选项，通常前面都有-,当选项使用全名时，使用--,例如:ls -al 或 ls -al --full-time
2:当命令太长时，使用\来转义会车，然后可以在下一行接着输入
Blog creation time:[2017-09-04 一 22:18]

* DONE [#C] theme:linux分区
 - State "DONE"       from "TODO"       [2017-09-04 一 22:41]
** 关于挂载：
	Linux的所有数据都是文件的形式来呈现的，所以，Linux有一个以/为起点的目录树结构来组织磁盘上的所有文件，可是磁盘是存在分区的，我们知道各个分区之间是独立的，
所以要想使用文件系统来操作不同分区，就涉及挂载问题，挂载就是利用一个目录当成进入点，将磁盘分区的数据放置到该目录下面，进入这个目录就可以操作这个分区内的所有数据，
我们称，这个目录为挂载点。
** 关于分区：
	上面的章节已经介绍过，在硬盘的第一个扇区有一个64字节的分区表，这个分区表描述了如何划分整个硬盘的存储空间，这个分区表被划分4组，每组16字节，有两种分区模式，
主分区和扩展分区，主分区最多4个，扩展分区最多1个。
** 挂载点与分区的规划：
1.分区的依据：
3-1.分析这台主机的用途，依据用途去分区需要较大容量的目录；
3-2.分析读写较为频繁的目录，将这些目录从/目录中独立出来；

2.分区时我们关注焦点包括：/ /boot /swap /home /usr /var /tmp 空闲，这8个对象。
** 分区建议：
1./:是目录树结构的根，这里存放的文件与开机、还原、系统修复有关所以，FHS建议，根目录单独挂载在某个分区，且该分区不再放置其他软件，并且这个分区应当越小越好，如此
不但性能好，根目录下的系统文件也不容易发生问题；
2./boot:在某些比较旧的主机中，BIOS可能找不到一些容量较大或者较新的硬盘的MBR，但是linux是能够安装并且将bootloader写入MBR的，在安装完成后开机，这种情况应该
是无法开机的，因为BIOS读不到MBR，无法加载bootloader，解决方案就在于这个/boot目录，这里面有linux的系统启动文件。由于BIOS捕捉到的磁盘容量不对，所以无法加载MBR，
但是，整个磁盘的前面几个扇区是能够被BIOS读取到的，因此，可以在这个磁盘的前面几个扇区分出一个100M左右的分区，并将这个分区挂载到系统启动文件目录下面，开机后BIOS就能
加载到/boot下面的启动文件。
注意：一定要将/boot分区放到整块磁盘带的最前面
3./home：该目录可以说是用户的工作目录，也就是说该目录是使用得最频繁得目录，务必单独分区出来；
4./usr：这个目录相当重要，usr 是 UNIX Software Resources的缩写，系统默认的软件（distribution发布）都安装在这里，该目录类似Windows下面的C：\Program files
所以，系统安装完后，这个目录占用硬盘的容量是最大的，随着安装软件的增多，这个目录会变得越来越大
5./var：这个目录在系统安装完成后，系统运行过程中的一些缓存，日志文件，mysql的一写文件，一些程序文件，email文件等都放在里面，随着系统的使用这个目录会变得越来越大
6./swap：该分区大小设置的规则：当物理内存小于等于4GB时，交换分区至少4GB，当物理内存4-16GB时，交换分区至少8GB，当物理内存16GB－64GB时，交换分区至少16GB，
当物理内存64G－256GB时，交换分区至少32GB。还有一哥原则时，交换分区至少为物理分区的1.5-2倍左右
7.建议预留一块不分区的磁盘容量，作为备份重要的配置文件以及脚本，以及分区练习使用，大小为总容量的1/5
** 文件系统类型：
1.ext3/ext4:Linux适用的文件系统类型
2.LVM：有弹性调整文件系统大小的机制，可以动态的改变文件系统的大小而不改变文件数据
3.RAID：利用Linux的特性，用软件仿真出磁盘阵列的功能
4.Swap：内存交换空间
5.vfat:能同时被windows和Linux所支持的文件系统
Blog creation time:[2017-09-04 一 22:22]

* DONE [#C] theme:版本与系统升级
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
apt-get clean 
apt-get update && apt-get upgrade -y && apt-get dist-upgrade -y

内核升级: apt-get install linux-header-${uname -r}
Blog creation time:[2017-09-05 二 08:11]
* DONE [#C] theme:linux基础操作
 - State "DONE"       from "TODO"       [2017-09-04 一 22:41]
** 帮助：man
1.man的文档规则：
--第一行：命令（编号），该标记有特殊意义，通常，编号都为1,表示该命令是一个在shell环境中可以操作的命令或可执行文件，这个编号有1-9,代表不同的含义
--NAME：这一行简要的说明了命令的作用
--DESCRIBES：对该命令的详细的介绍
--OPTIONS：列举该命令的所有选项
--SEE ALSO：告诉我们在其它什么地方还可以查到相关资料
2.man的用法：
--翻页符合emacs
--/或？向下查询或向上查询
--n或N向下继续或向上继续查询
--q退出
--man -f 命令：列举出所有与该命令相关的文档源
--man -k 命令：列举出所有含该命令的说明文档
** 帮助：info
1.info与man的区别：man是UNIX里面的帮助指令，在Linux下还提供了另外一个帮助工具，info，与man一下子输出一堆信息不同的是，info将文件拆分成段落，还有超链接
2.info的文档规则：
--翻页命令符合emacs的基本命令：C v
--？查询info命令
--[Tab]:在节点之间移动
--[Enter]:进入节点
--d: 跳转到info的目录节点
--<: 移动到这个文件的顶层节点
--u：向上移动一层
--l：前进到最近一次访问的历史节点
--r：回退到最近一次访问的历史节点
--n：前往下一节点
--p：前往上一个节点
--q：退出
** 帮助：/usr/share/doc
/usr目录是Linux的distrution软件都安装在这里，所以，这里面会有一些商家提供的关于软件的说明文档
** Terminal与X window的切换：
	Fedora默认提供4个tty，1个x window，切换到x window的快捷键是：CTRL＋ALT＋F2,切换tty的快捷键是CTRL＋ALT＋F3  ～  CTRL＋ALT＋F6 
如果是以tty的模式启动Linux，要想使用x window，可以在终端中输入startx。
** 注销Linux：
exit （等价于CTRL＋d）
** 关机和重启：
	Linux是多用户操作系统，关机以及重启是个十分严肃的操作，因此有两种情况你能关掉主机：第一，你在主机面前，以x window方式操作系统，来关机和重启（身份不限）；
第二，你远程关机和重启，必须使用root身份。同时，作为root，你在关机或者重启之前要考虑一下别人的感受，你得通知人家，让人家将内存数据同步到硬盘
1.首先查看系统的使用状态：
--查看谁在线：who
--查看网络联机状态：netstat -a
--查看后台的执行程序：ps -aux
2.若有人在线，通知他：
--shutdown -k 11:15 'I will shutdown at 11:15':通知系统将在11:15时刻关机
--shutdown -r 11:15 'I will reboot at 11:15':通知在11:15时刻重启

--shutdown -h 10 'I will shutdown after 10 mins':10分钟后关机
--shutdown -r 10 'I will reboot after 10 mins':10分钟后重启

--shutdown -h 11:15 'I will shutdown at 11:15':在11:15时刻关机
--shutdown -r 11:15 'I will reboot at 11:15':在11:15时刻重启

--shutdown -h +10 :系统再过10分钟关机
--shutdown -r +10 :系统再过10分钟重启

--shutdown -h now：立即关机
--shutdown -r now：立即重启

--shutdown -c:取消
6-3.将内存数据同步到磁盘
--sync
** 基本命令：
1.查看内核版本：uname -r
2.查找：find / -name a.txt
3.显示时间：date
4.显示日历：cal 7 2008
5.计算器：bc （保留3位小数点：scale＝3; quit 退出）
6.中断程序：CTRL＋c
7.浏览文件：ls -al --full-time
8.创建目录：mkdir -p test1/test2/test3  (-p指定递归创建)
9.进入目录：cd /home/ljj/test1/test2/test3
10.删除文件或目录：rm -rf test1/
9.复制文件：cp -a a.txt ./b.txt   (-a = -rpd:r－递归；p：权限；d：连接文件)
9'.复制文件：cp -a a.txt b.txt /home/ljj  (最后一个必须是目录)
10.备份文件：cp -au a.txt ./   (-u目标?=源)
11.移动文件或目录：mv a.tx ../
11'.移动文件或目录：mv a.tx b.txt ../  (最后一个必须是目录)
12.重命名：mv a.txt ../b.txt
13.查看文件内容：cat -n a.txt
14.查看文件内容：less a.txt (?,/查找)
15.查看第11行到20之间的数据：head -n 20 /home/ljj/a.txt | tail -n 10
14.查看命令的路径：which cd
15.查看当前目录：pwd
16.读取二进制文件：od -t -xxx file
其中：xxx为：
-- -a：利用默认字符输出
-- -c：利用ASCII码输出
-- -d：利用十进制输出
-- -f：利用浮点数输出
-- -x：利用十六进制输出
-- -o：利用八进制输出 
例如：od -t xCc /etc/issue
17.创建一个空文件：emacs 或者 vi  （建议touch只用于修改文件时间）
18.修改文件时间：touch
18-1.文件的三个时间：可信度最高的是ctime
--mtime：修改时间；文件内容最近一次被修改的时间
--ctime：状态时间；文件状态最近一次发生改变的时间，如文件权限与属性最近一次被更改的时间
--atime：访问时间；文件内容最近一次被读取的时间
18-2.查看时间（状态时间）：ls -al --full-time --time=ctime xxx
备注：亲测访问时间可信度不够，不稳定，而修改时间mtime可以使用下面18-3的方法被修改，所以
不建议将mtime和atime作为参考。使用ctime最为妥当。
18-3.修改时间：touch -t 1706050902 xxx
** 各种查找命令
1.which：查找“执行文件”路径
1-1.命令：which ls  --> /usr/bin/ls
1-2.该命令是依据PATH所规范的路径去查找，所以cd是找不到的，它是bash的内置命令。

2.whereis：查找特定的文件
2-1.命令：whereis -[参数] xxx
2-2.参数:-b：只找二进制文件;-m：只找说明文件;-source：只找源文件
2-3.Linux系统将系统内的所有文件都记录在一个数据库文件(/var/lib/mlocate）里面，该指令是居于数据库查找的，所以速度比find快

3.locate:查找特定文件
2-1.命令：locate -[参数] xxx
2-2.参数:-r：后面接正则表达式的显示方式;-i忽略大小写；
2-3.Linux系统将系统内的所有文件都记录在一个数据库文件(/var/lib/mlocate）里面，该指令是居于数据库查找的，所以速度比find快
2-4.由于是从数据库查找，数据库默认是1天更新一次，所以，你刚创建的文件是找不到，因为它没有更新到数据库
2-5.使用updatedb就可以更新数据库。

4.find：查找指定文件
4-1.find 路径 -mtime 参数
备注：
路径：指明在哪个地方查找；
参数：
-- -mtime n：例举出所有在n天之前的“一天之内”被更改过的文件
-- -mtime +n：例举出所有在n天之前（不含n天的）的被更改过的文件
-- -mtime -n：例举出在n天之内（含n天本身）被更改过的文件
-- -newer xxx：例举出比xxx还要新的文件，用于比较两个文件之间的新旧关系
4-2.find /home -user ljj 找出与用户ljj有关的所有文件
4-3.find / -group ljj 找出与用户组ljj有关的所有文件
4-4.find / -nouser 找出系统中不属于任何人的所有文件
4-5.find / -nogroup 找出系统中不属于任何用户组的所有文件
4-6.find / -name passwd 找出文件名为passwd的这个文件
4-7.find / -type s 找出路径下所有文件类型为s的文件
4-8.find / -size +50k 找出路径下所有比50k还要大的文件
4-9.find / -name passwd -exec ls -al {} \; 
备注:-exec到\；之间的内容为为额外命令。
Blog creation time:[2017-09-04 一 22:26]
** 进程,端口,服务
1. 查看服务: netstat -tlnp
2. 显示所有进程: ps -aux
3. 杀死进程: kill -9 PID

* DONE [#C] theme:用户与用户组管理
 - State "DONE"       from "TODO"       [2017-09-04 一 22:41]
** linux如何辨识系统中的每一个用户
--用户标识:linux依据用户标识来唯一标记系统中的每一个用户,而不是依靠用户名,用户标识是给linux看的,而用户名以及用户组名是给用户看的
--用户标识由用户ID和用户组ID构成,每一个在Linux中注册的用户用户至少取得这两个ID
--用户ID:linux唯一为一个向系统注册的用户分配一个ID,称为UID
--用户组ID:每个用户可以拥有一个自己的用户组,linux为用户的用户组唯一分配一个ID,称为GID
备注:当向linux系统注册一个用户时,可以手动指定用户标识,也可以让系统自己分配,该标识将记录在/etc/passwd文件中

--在linux的终端下面,当你输入su xxx来试图切换到xxx用户时:
-->系统会首先到/etc/passwd下面找是否有xxx账户,如果没有则退出
-->如果有,则将该账号对应的UID与GID从/etc/passwd中找到并读出来,该账号的主文件夹和shell设置也一并读出来
-->进入/etc/shadow里找到对应的账号与UID,然后核对你输入的密码与记录的密码是否相符
-->如果密码相符,则将 /etc/passwd下设置的shell分配给该用户
备注:当用户登录linux主机时,/etc/passwd和/etc/shadow就必须让系统来读取,所以,这两个配置文件是极度重要的,其中的内容也是十分值得考究的,所以
应当对这四个文件做好备份(许多攻击者会将特殊账号写到这/etc/passwd中去,所以,应当做好管理)
** 剖析/etc/passwd文件
--每一行都代表一个账号,有多少行就表示系统中有多少账号
--里面很多账号都是系统账号:bin daemon adm nobody等,这些账号不可随意删除
--系统账号和用户账号构成了整个文件
--系统账号通常是不可登录的,即分配给它的shell是nologin
--用户如果有特殊需求,也可以自行创建一个系统账号来使用
--该文件的权限:644,文件所有者是root,用户组是root

例子:
系统账号:daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
(1)-->账号名称:
	为了便于用户使用,每个用户都有一个用户名

(2)-->密码:
	x,由于密码放到/etc/shadow中去了,所以显示x,这是有原因的,该文件的权限是644,所有人都可见,这不安全,
密码放到/etc/shadow去,shadow的权限是640,所有者是root,用户组是shadow,即除root和shadow外,任何人都无法查看shadow文件

(3)-->UID:
	用户标识,UID为0代表该用户是系统管理员(root),所以,当你想要其他用户也具有root权限时,将该账号的UID改为0即可,
一个系统上是可以有多个UID为0的用户的,但是不建议多个用户的UID为0;UID为1~499是默认留给系统账号使用的,之后留给用户,UID是给系统使用的;

(4)--GID:
	用户组标识,用来标识该用户自己的用户组,默认情况下,UID号与GID号是相同的;在/etc/group文件的第(3)个字段也有一个用户组GDI,这两个GID必须是对应的,
在用户组管理时,会使用到这个GID来将用户和用户组关联起来,这里的GID叫做初始用户组

(5)--用户信息说明列:
	存储用户的全名,如LJJ,用于解释账号的意义,默认情况下填写用户账号名在这,但是如果开启了finger功能的话,该字段能提供更多的信息,
更多finger的使用参加下面的用户的那些事里面的普通用户章节

(6)--家目录路径
	每个用户账号一般都会有一个自己的家目录,以后该用户账号在系统上的办公文件都放在自己的家目录里面,当然,用户有没有家目录
起决于在执行useradd命令来添加用户的时候,有没有使用-m参数来强制为该用户生成家目录,所以,如果你想修改家目录的路径,可以修改
该字段来实现

(7)--用户shell:
	每个用户在注册时都会为其指派一个shell,该用户在登录成功之后就在指派的shell下来与系统内核通讯,可以配置该字段为该用户
提供登录shell,有一个特殊的shell叫做nologin-shell,如果为该用户指派了nologin-shell,那么该用户就没法登录了,使用该功能可以用来配置
禁止用户登录
	shell程序的路径:
-->/bin/bash
-->/bin/sh
-->/usr/sbin

-->退出shell: exit 

** 剖析/etc/shadow文件
--每一行都代表一个账号
--该文件主要记录用户的密码
--该文件的权限:640,文件所有者是root,用户组是shadow,即除root和shadow外,任何人都无法查看shadow文件

例子:
系统:daemon:*:17212:0:99999:7:::
用户:ljj:$6$xA8e4EBv$bmGLgROKdUR7btWacgH/CmAN2aZRrPlQ8WLPE.QFq9ZEFZ2C2WLEJKGpSL3fJvGqB6gUYvn.Yd59IeZuFv9uv/:17346:0:99999:7:::
(1)-->账号名称:daemon

(2)-->密码:
	该密码是用户真正的密码,但是是经过加密的,由于规定的编码系统(如MD5)产生的密码长度必须一致,所以当该密码字段的长度发生改变时,密码就无法被编码
系统计算出来,即密码失效,所以root可以在某个用户的密码前面加上!,该用户的密码就会失效

(3)-->最近更改密码的日期:
	该字段记录了最近一次改动密码的日期,从1970年1月1日开始到最近一次修改密码,累加的天数,记录在该字段处

(4)-->密码不可被更改的天数:默认0
	该字段记录了该账号的密码从,最近一次密码更改日期开始算起,的多少天之内不能再次被更改,0,表示随时可以更改;这个设计是用来防止用户对密码一而再再而三的更改,
例如,该字段设置为20,表示,从该用户最近一次更改密码的日期开始算,20天之内该用户都不能再进行更改密码的操作

(5)-->密码需要重新更改的天数:默认99999
	该字段指定了该账号的密码从,最近一次密码更改日期开始算起,的多少天之内必须再次更改密码,如果在限制天数之后还不更改,该密码将会具有过期特性,99999,表示密码的
更改没有强制性之意;这个设计是用来提醒用户树立安全意识,因为经常更改密码是个好习惯.例如,该字段设置为20,表示,从该用户最近一次更改密码的日期开始算,20天之内该用户
需要重新设置自己的密码

(6)-->密码过期前的第多少天发出警告:(5)有效该字段才有效,默认值为7
	当设置了(5)字段之后,密码在(5)字段指示的日期之后会具有过期特性,所以该字段是用来配合(5)的,如上面的(5)给出值20设置之后,从该用户最近一次更改密码的日期开始算,
在20天之后,该用户的密码会具有过期特性,显然,如果(5)配置了而不配置(6),那么,该用户在第20天晚上使用密码登录系统时还一切正常,第二天来使用密码登录系统时,就提示该密码
过期了,这显得很唐突,所以,(6)的作用就是让该用户在配置了(5)的前提下对密码的修改有个缓冲区,比如将(6)字段设置了5,那么,在(5)配置了的前提下,用户在最近一次修改密码
之后的第15天登录系统时,系统会提示该用户,该密码又需要改了,而且再过n天密码就会过期,应当尽快修改为好

(7)-->密码过期后账号的宽限时间:(5)有效该字段才有效,默认值为空
	在(5)字段中配置了,从最近一次密码更改日期开始算起的多少天内密码会具有过期特性,注意,是具有过期特性!而不是真正的过期,一个具有过期特性的密码,还是可以使用的,只不过
当该用户使用过期的密码登录系统时,系统会强制要求你必须重设密码才能取得bash继续工作.那么,该字段(7)的作用是什么呢?那就是如果一个密码过期了,那么再过(7)字段设置的天数之后,
该用户的密码将会失效,即,该账号再也无法使用该密码登录系统了,此时,唯一的办法就是求助管理员,让管理员帮忙重新设置该用户的密码(注意,管理员设置用户的密码是不需要旧密码的)
密码过期后是否失效,0,立即失效,-1永远不失效

(8)-->账号失效日期:(收费计时账号)
	该字段用于指定该账号字段值所示的日期之后将失效,无法再使用,字段值是一个从1970年1月1日开始累加的天数值,注意,该字段多用于"收费服务"的系统中,规定一个日期,日期到了,该
账号就不能再使用了

(9)-->保留:以后扩展使用,默认为空
** 剖析/etc/group文件
--每一行都代表一个用户组
--该文件就是GID的配置文件
--该文件的权限:644,文件所有者是root,用户组是root

例子:
系统:bin:x:1:root,bin,daemon
用户:ljj:x:1000:
(1)-->用户组名:
	为了便于用户使用,每个用户组都有一个用户组名

(2)-->用户组密码:
	同用户密码一样,用户组也可以有一个密码,这里显示x的原因和/etc/passwd中密码字段显示x的原因是一样的,真正的用户组密码在/etc/gshadow中
gshadow的权限是640,所有者是root,用户组是shadow,即除root和shadow外,任何人都无法查看gshadow文件,还是出于安全考虑

(3)-->用户组GID
	在/etc/passwd下面每个用户的第(4)个字段都有一个GID,该字段同其对应

(4)-->用户组下包含的用户:(同/etc/gshadow的第四个字段)
	每个用户在注册时都产生一个和用户名相同的用户组,并且该用户是自己用户组的组员,一般将之设置为用户组管理员;
该字段记录了用户组下面除了用户组管理员之外,加入该用户组的成员

** 剖析/etc/gshadow文件
--该文件最大的功能就是创建用户组管理员
--一个用户组最好有一个用户组管理员,一个用户xxx被注册时都会产生一个属于该用户的用户组xxx,该用户组xxx是该用户xxx的初始用户组,对于
该用户组xxx来说,最好将xxx用户作为它的用户组管理员
--每个用户组都创建用户组管理员的好处在于,如果其他用户想要加入该用户组,而系统管理员又很忙,没时间用usermod来帮用户加入用户组时,这些用户可以去
找该用户组的管理员帮忙,让他使用gpasswd命令帮忙加入他所管理的用户组

例子:
系统:daemon:*::
用户:ljj:!::
(1)-->用户组名:
	为了便于用户使用,每个用户组都有一个用户组名

(2)-->用户组真实的密码
	如果该字段为!就表示该用户组不具有用户组管理员,加入该用户组的成员想要使用newgrp切换到该用户组,需要输入该密码才行(用户组管理员除外)

(3)-->用户组管理员账号:
	当使用gpasswd命令来指派用户组的管理员时,指派到的管理员就填充到该字段

(4)-->用户组下面包含的用户:(同/etc/group的第四个字段)
	每个用户在注册时都会有一个自己的用户组,如xxx用户通过useradd命令向系统注册用户,注册成功后就有产生了一个可以登录系统的xxx用户,同时,还产生了一个名为
xxx的用户组,这个xxx用户组的所有者就是xxx用户,此时,其他用户,如yyy,可以加入到xxx用户的用户组xxx里面,成为xxx用户组的成员,xxx用户是xxx用户组的小组长,yyy用户是组员;当然了,
xxx用户也可以加入到yyy用户拥有的用户组yyy里面去,此时yyy用户是yyy用户组的小组长,而xxx用户变成了组员
	该字段记录了用户组下面除了用户组管理员之外,加入该用户组的成员

** 剖析/etc/default/useradd文件
--useradd命令在缺省选项的情况下也能成功注册用户,那是因为系统定义了在缺省选项的情况下,默认的处理方式
--/etc/default/useradd文件就给出了useradd xxx时的默认值

分析:
# Default values for useradd(8)
#
# The SHELL variable specifies the default login shell on your
# system.
# Similar to DHSELL in adduser. However, we use "sh" here because
# useradd is a low level utility and should be as general
# as possible
SHELL=/bin/sh    //系统默认的shell,假如系统是作为mail server,那么可以设置为/usr/sbin/nologin,不允许用户登录系统
#
# The default group for users
# 100=users on Debian systems
# Same as USERS_GID in adduser
# This argument is used when the -n flag is specified.
# The default behavior (when -n and -g are not specified) is to create a
# primary user group with the same name as the user being added to the
# system.
#GROUP=100     //当系统用户组的类型为公有用户组时,该设置才开启,使用私有用户组时,此项设置应当注释
#
# The default home directory. Same as DHOME for adduser
#HOME=/home    //家目录 
#
# The number of days after a password expires until the account 
# is permanently disabled
#INACTIVE=-1    //密码过期后是否失效,0,立即失效,-1永远不失效,shadow中的第(7)字段
#
# The default expire date
#EXPIRE= 		//账号失效日期,shadow中的第(8)个字段 
#
# The SKEL variable specifies the directory containing "skeletal" user
# files; in other words, files such as a sample .profile that will be
# copied to the new user's home directory when it is created.
#SKEL=/etc/skel    //注册用户完成后,用户的家目录下的问价会从该目录下拷贝过去
#
# Defines whether the mail spool should be created while
# creating the account
#CREATE_MAIL_SPOOL=yes   //是否创建用户的mailbox,如果开启的话,在/var/spool/mail/下面有各个用户的专用邮件信箱
** 剖析/etc/skel/目录
--该目录是用户主文件夹参考基准目录
--每一个用户在注册时,如果指定了-m参数创建了用户主文件夹,那么,系统会将/etc/skel/目录下的全部文件复制到刚注册的用户的家目录下面,
默认有.bashrc .profile .bash_logout  examples.desktop(ubuntu16.04)
--该文件的权限是755,用户为root,用户组为root
--显然,管理员可以在该文件夹下面加入一些文件,当进行用户注册时,这些文件就会被分发到每一个注册用户的家目录下
-->(1)使用root权限将.emacs.d复制到该目录下; 

** 剖析/etc/login.defs
--MAIL_DIR /var/mail:用户默认邮件信箱放置路径
--UMASK 027:注册用户时,如果指明生成家目录,则将家目录的默认权限设置为750,用户组里面的成员才允许进入
--PASS_MAX_DAYS   99999:shadow中的第(5)字段
--PASS_MIN_DAYS   0:shadow中的第(4)字段
--PASS_WARN_AGE   7:shadow中的第(6)字段

--UID_MIN				 1000:用户最小的UID,默认每注册一个常规用户自增1,系统用户比它小
--UID_MAX			    60000:用户最大的UID
--GID_MIN                1000:用户组最小的GID,默认每注册一个常规用户组自增1
--GID_MAX               60000:用户组最大的GID

--USERGROUPS_ENAB yes		 :yes意味着使用useradd时,将创建一个与用户名一样的用户组,使用userdel时,如果用户的用户组没有其他成员,将移除该用户组
** 用户的那些事
*** 系统管理员或超级用户
**** 更改新注册用户家目录的默认权限
--需求:管理员希望为新注册的账户的家目录设置统一的权限(在注册之前设置好),以后注册的账户的家目录都这这个设定值如700
--实现:sudo emacs /etc/login.defs  --> 更改UNMASK 0077
**** 添加新注册用户家目录中的默认文件 
--需求:管理员希望,每个用户在创建之后,这些用户的家目录里面都默认有某些工作的基础文档或者通告之类的
--实现:将希望默认添加的文件加入到/etc/skel/目录下即可
**** 注册用户
	系统用户:useradd -r test    (-r:指定创建的是系统用户)

-->	常规用户:useradd -m -s /bin/bash -G grp_group1,grp_group2 -c "2nd user" test   (除了加入-G指向的组列表,还会创建test用户组)
	*常规用户:useradd -m -s /bin/bash -U -c "3th user" test2
    *常规用户:useradd -m -s /bin/bash -N -g grp_group1 -c "4th user" test3
--> 更改用户组名:groupmod -n grp_test test

建议:
	使用上面箭头给出的方案来创建,之后再使用groupmod改一下用户组名,因为,默认用户组和用户组是同名的,这样
容易对以后的用户组管理造成混乱,我的原则是:用户组名 = "grp_" + 用户名 

原则:
(1)创建用户时不指定UID和GID而让系统自己指定;
(2)创建用户时不考虑对该用户进行配置,配置在后期由管理员或者用户组管理员来进行专业的配置
(3)常规用户都创建家目录,且指定shell为/bin/bash
(4)常规用户都重设用户组名而不是默认与用户组同名,以便后期用户组管理时方便区分

备注:
--m:指定强制为该用户创建家目录
--s指定默认shell
--G指定的是一个已经存在的用户组列表,表示现在新建的这个用户都会加入到-G指定的这些用户组中去
--U指定创建一个和用户同名的组,并将用户添加到组中
--N -g指定不要创建同名组,而是将用户添加到 -g 选项指定的组中去
--查看该系统使用useradd xxx添加用户的默认配置:useradd -D,这些默认值在/etc/default/useradd中配置
--经测试,ubuntu16.04使用useradd xxx时,默认不会创建主文件夹,不会为其分配shell,所以需要使用-m和-s手动指派
--如果使用了-r,则除非使用-m,否则不会为系统账号创建主文件夹

**** 删除用户
    准备工作1:less /etc/groups 看第四个字段是否有其他用户加入该用户的用户组,有则进入准备工作3,没有则进入准备工作2   
	准备工作2:find -/ -user xxx
	准备工作3:gpasswd -A another_user xxx_group  (xxx被罢免了!将他之前的用户组管理员身份转交给另一位在该用户组内的用户)  
	操作:userdel -r xxx 
备注:
--> r选项指示连用户的主文件目录也一起删除
--> 由于待删除的用户可能在系统上工作一阵子了,系统内可能还有该用户的文件(邮件),所以,如果想要完整的删除该用户,在执行删除操作之前
应当先查找出整个系统内该用户的文件删除之后,再执行删除用户操作
--> 由于/etc/login.defs中设置USERGROUPS_ENAB yes,所以使用userdel删除用户时,如果用户的用户组没有其他成员,将移除该用户的用户组
**** 设置用户密码
	用户自己设置:passwd www  --> 提示:输入当前密码 --> 两次提示:输入新密码
	系统管理员设置:passwd www --> 两次提示:输入新密码
备注:
--用户设置自己的密码需要提供以前的旧密码,系统管理员设置某用户的密码则直接设置即可
--当用户忘记密码时可以找管理员帮忙,管理员的密码一定不能忘记
**** 查看用户密码状态
使用passwd命令:
--测试当前用户的密码状态:passwd -S 
--测试系统所有用户的密码状态:passwd -a -S (管理员或超级用户可用)
实例:
	ljj P 06/29/2017 0 99999 7 -1
(1)-->用户的登录名:ljj
(2)-->L:用户密码已经锁定; NP:用户没有密码; P:密码可用
(3)-->最后一次更改密码的日期:2017-06-29
(4)-->shadow中的第(4)字段,最近一次密码更改日期开始算起,的多少天之内不能再次被更改,0,表示随时可以更改
(5)-->shadow中的第(5)字段,最近一次密码更改日期开始算起,的多少天之内必须再次更改密码,如果在限制天数之后还不更改,该密码将会具有过期特性,99999,表示密码的更改没有强制性之意
(6)-->shadow中的第(6)字段,密码过期前的第多少天发出警告,(5)字段配置了的情况下该字段才有效
(7)-->shadow中的第(7)字段,密码过期后是否失效,0,立即失效,-1永远不失效

使用chage命令:(推荐)
ljj@Ubuntu-16:~$ chage -l ljj
最近一次密码修改时间				： 6月 29, 2017
密码过期时间					    ： 从不
密码失效时间					    ： 从不
帐户过期时间						： 从不
两次改变密码之间相距的最小天数		：0
两次改变密码之间相距的最大天数		：99999
在密码过期之前警告的天数        	：7

**** 配置用户密码(shadow文件)
--最近更改密码的日期:<shadow中的第(3)字段>
	修改:chage -d 2017-07-10 www  
	查看:chage -l www

--密码多少天内不可被更改:<shadow中的第(4)字段>
	配置:chage -m 20 www 
	移除:chage -m 0 www  (0,表示无此限制,可在任何时间更改)
    查看:chage -l www
备注:该配置对于管理员或者超级用户来说没有限制作用;以最近一次更改密码的日期为起点开始算

--密码多少天内需要重设:<shadow中的第(5)字段>
	配置:chang -M 20 www 
	恢复:chage -M 99999 www
	移除:chage -M -1 www   (移除密码的有效性检查)
    查看:chage -l www
备注:以最近一次更改密码的日期为起点开始算

--密码过期前的多少天发出警告:<shadow中的第(6)字段>
	配置:chage -W 10 www
    查看:chage -l www
	
--密码过期后宽限都少天密码失效:<shadow中的第(7)字段>
	配置:chage -I 3 www
    查看:chage -l www
备注:以密码过期的那一天的日期为起点开始算;该期限过后还没有更改密码,以后就都进不去了,只能找管理员帮忙

--账号失效时间:<shadow中的第(8)字段>
	配置:chage -E 2017-08-01 www
	上锁:chage -E 0 www    (立即失效)
	移除:chage -E -1 www   (从不失效)
	查看:chage -l www
**** 强制用户首次登录系统时更改密码
--需求:管理员可能想要用户在第一次登录时强制他们一定要更改密码之后才能使用系统资源

--实现:chage -d 0 www

--恢复:chage -d 2017-6-29 www (即重新为www指定一个不为0的密码最近修改日期即可),当然了,也可以重设一次密码

--分析:
	由于-d选项是用来指明最近更改密码的日期,该日期被指定为0,实际上就是1970-01-01,这会有问题,当你这样配置后,你使用
chage -l www指令来查看密码状态,发现密码状态变为:密码必须更改,当你此刻切换到www输入密码登录时,系统会强制要求你重设自己的密码

**** 配置用户账户(passwd文件)
--用户名:<passwd中的第1字段>
	修改:usermod -l newer
	*修改主文件名:mv /home/test1 /home/test2 
	*修改邮件池:mv /var/pool/mail/test1 /var/pool/mail/test2 (备注:邮件目录需要查看/etc/login.defs中给出的定义)
备注:该配置只是将用户名更改为newer,不会更改别的任何东西,所以,用户的主目录名和邮件池需要手动修改以和新登录名对应

--用户UID:<passwd中的第3字段>
	修改:usermod -u 1003 test 

--用户组GID:<passwd中的第4字段>
	修改:usermod -g 1004 test 
备注: 
(1)表示强制使用1004这个用户组作为test这个用户的用户组,其中1004这个用户组必须存在;
(2)用户主目录中,属于原来的主组的文件将转交新组所有,主目录之外的文件所属的组必须手动修改;

--用户信息说明列:<passwd中的第5字段>
	修改:usermod -c "this is test count!" test 

--家目录路径:<passwd中的第6字段>
	修改:usermod -d /home/tmp/test test 

--用户shell:<passwd中的第7字段>
	修改:usermod -s /bin/sh test 
**** 用户密码上锁与解锁
	上锁:passwd -l www  
	解锁:passwd -u www	
备注:
--这两条指令实际上配置的是/etc/shadow中的第(2)密码字段,事实上就是在密码的前面加上!来改变密码的长度,使得密码无法被编码系统解析
--由于shadow的权限是640,所以只有管理员或者超级用户才能执行上面的两条指令
**** 用户账户上锁与解锁
	上锁:chage -E 0 www    (账户立即失效)
	解锁:chang -E -1 www   (恢复账户,且永不失效)
备注:
--本质上,配置的是/etc/shadow中的第8个字段
--如果只是想让该账号暂时不启用,那可以使用该命令将其封锁,以后使用时再解锁,如果真正确定不让该用户在主机上使用任何数据了,那使用userdel删除账号

**** 将某用户设置为超级用户
--添加超级用户:
	(1)切换至root: su root
    (2)为/etc/sudoers文件添加写权限:chmod u+w /etc/sudoers
	(3)使用emacs打开该文件并添加超级用户:
-->如下所示:添加www用户    
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    www             ALL=(ALL:ALL) ALL 
    # Members of the admin group may gain root privileges
    %admin ALL=(ALL) ALL
   (4)减去/etc/sudoers文件的写权限:chmod u-w /etc/sudoers

--使用系统用户创建文件:sudo -u sshd touch /tmp/mysshd
备注:-u参数后面接想要切换的用户,无-u参数则默认为接root
意义:sshd是一个系统账号,其shell是/usr/sbin/nologin,即无法登录,即无法创建文件,此时使用sudo之后可以愉快的创建一个属于sshd用户的文件了

--当前用户为hello,在www用户的家目录下:sudo -u www touch test.txt ---> 输入hello的密码 ---> 在/etc/sudoers中验证hello是否具备超级权限 ---> 是,创建成功,否创建失败
**** 将某用户设置为管理员
--需求:
	在一个大型项目中,系统管理员root可能一个人忙不过来,所以在考虑清楚之后可以将少数几个极其信赖的
人设置为管理员,一般不建议这么干,因为有sudo这个工具

--依据:
	用户UID为0的用户,系统就认为它是管理员,所以,可以注册某用户,指定其UID为0,则该用户和root一样就是系统管理员了

--实现:
-->useradd -r -o -N -g 0 -u 0 -s /bin/bash super 
备注:
	-r:指明是一个系统账户
	-o:指明允许重复UID    (必须有的关键选项)
	-N -g:指明不创建用户组,而是把该用户添加到-g所指定的用户组下面去
    -u:指明

--当这样做以后,有个大问题就是你无法再使用root删除掉super,因为此时super就是root,root就是super(本质上他们还是各是各的,因为他们各自有各自的密码,家目录),
想要删除掉super那只有emacs /etc/passwd,将super的UID和GID改掉,之后就可以使用userdel -r super来删除了

**** 修改用户的UID
	查看:id www ---> uid:1007
	命令:usermod -u 2007 www 
	查看:id www ---> uid:2007
备注:将用户www的UID从1007修改为2007
**** 修改家目录路径
	命令:usermod -d /home/NewUser -m Olduser
备注:将Olduser用户的家目录路径指向/home/Newuser,并将之前家目录里面的文件移动到该路径下
**** 重命名用户名
       usermod -l NewUser -d /home/NewUser -m OldUser
-l 修改用户名
-d 修改登录后使用的路径
-m 修改登录名称的同时将目录名称一同修改

-->用户名重命名之后，注意检查 ~/.local/ 目录下，很多旧文件还是保存着旧用户名作为路径的，使用sed -i 改一改就好
-->如果使用了用户组,一方面需要将该用户从他加入过的用户组中去除,然后将重命名之后的用户名加入到这些用户组里面来,另一方面,
该用户所管辖的用户组最好也改一下名和重命名后的用户名保持一致

备注:系统管理员才能进行该操作,另一方面,一旦用户注册完毕后很不建议重命名,因为该用户可能在系统中有了很多文件,重命名之后这些文件就变成无主的了
*** 常规用户
**** 来回修改默认权限
--需求:
	出于安全的考虑,用户在新建文件时,需要考虑该文件用户具有哪些权限,用户组具有哪些权限,其他人具有哪些权限,通常的做法是
先把文件给touch出来,然后再去修改它的权限,这是很麻烦的,实际上,我们使用系统的环境应该是这样的:某用户会加入许多个用户组进行办公,
该用户在每个用户组里面的职责是不同的,所以,该用户登录系统的第一件事应当是考虑应该切换到哪个用户组去工作,在这之后,我们自然需要
设置默认权限,因为接下来该用户touch的文件都是属于该用户组的,在这个用户组完成工作后,该用户又得切换到其他用户组完成其他工作了,切换
过去之后,该用户发现这个用户组里面完成的工作可能是绝密的,所以他又得修改用户默认权限了

--思想:
	修改默认权限的思想不同于传统的先touch文件,再去修改权限这样的思想,修改默认权限是先考虑权限,再touch文件,在实际工作中,通常修改默认
权限的思想更加高效

--实现:umask 0002,被拿走的权限,详情参考文件与目录管理的默认权限章节
**** 添加用户的个人办公信息
	命令：chfn ljj 
备注：依照提示，会要求你依次输入名字，办公室门牌号，电话
**** 查看用户登录信息和状态信息
	命令:finger　ljj   
备注:该命令返回:用户账号,全名(passwd的第5个字段批注),家目录路径,当前使用的shell,用户登录主机的情况,邮件，电话,门牌号等
**** 查看系统可用的shell
	命令:chsh -l
	*命令:less /etc/shells
备注:chsh -l本质上就是列举出/etc/shells里面的内容,ubuntu16.04的测试中,该命令失效所以可直接查看/etc/shells

**** 查看系统当前shell
  命令:finger www 
**** 切换系统shell
	命令:chsh -s /bin/sh ljj
备注:该修改完成后,需要重启才能生效
**** 查看用户UID和GID
  命令:id www
**** 判断系统中是否有某用户
	命令:id xxx 
备注:如果该用户xxx存在,则返回其用户ID和用户组GID,不存在则显示无此账户
** 用户组的那些事
*** 用户组知识
--用户组研究的角度:
	显然我们可以有两个视角来研究用户组,第一个视角是用户组yyy下面有哪些用户;第二个视角是用户xxx加入了哪些用户组,实践证明,第二个视角是分析用户组
正确的视角,因为工作模式是这样的,某用户登录了系统,在系统中,该用户需要来回切换用户组,以区分在不同用户组里面干的活

--初始用户组与有效用户组:
	一个用户可以加入多个用户组中,此时,有一个问题来了,如果这个用户使用touch a.txt新建了一个文件,那么使用ls -al a.txt时,
你觉得a.txt的用户组字段应该是谁呢?基于这个问题,就有了初始用户组和有效用户组的概念
	有效用户组:a.txt的用户组字段显示的一定是有效用户组,那如何判断一个用户当前的有效用户组呢?最简单的方法是,使用使用该用户登录系统后,
使用groups命令列出该用户都加入过哪些用户组,排在最前面的那个用户组就是该用户的有效用户组啦,此时,使用touch a.txt新建了一个文件时,文件属性
的用户组字段就是当前的有效用户组;
	初始用户组:在/etc/passwd文件的第(4)个字段所示的GID就是初始用户组
	备注:一个用户可以加入很多个用户组,其中某一时刻只能有一个用户组是该用户的有效用户组,该用户在创建文件时,该文件所属的用户组就是有效用户组;
该用户也唯一有一个初始用户组,在该用户所加入的所有用户组中,除了初始用户组和有效用户组以外,还会有其他的用户组,暂且称为不活跃的用户组,显然,我们
就有这么一种需求,既然该用户加入了这么多的用户组,如果把每个用户组当成一个团队,相当于一个人同属于多个团队,那问题来了,今天我可能需要在这个团队干活,
即在这个用户组内创建文件,明天我可能又需要在另一个团队干活,即在另一个用户组创建文件,那么必然需要做有效用户组的切换

--用户组的两种机制:
(1)私有用户组机制:
	系统为每个注册用户都创建一个与用户名一样的用户组给用户作为该用户的初始用户组,以后其他用户可以加入该用户组,这种方案还规定主文件夹的权限是700
该用户也可以加入其他用户组私有用户组的代表系统有Fedora,RHEL,Centos
(2)公有用户组机制:
	在/etc/default/useradd文件里面,GROUP的值是一个已经存在的用户组的GID,以后向系统注册的所有用户都使用这个GID的用户组作为初始用户组,即注册用户不再
为其单独生成一个自己的用户组,每个用户都加入到GROUP指定的用户组里面去,而且,这种方案还规定主文件夹的权限是755,大家都可以互相分享对方家目录下面的东西
代表性的系统有SuSe
备注:Ubuntu16.04的用户组方案采用私有用户组,但是家目录的权限同公有用户组为755

*** 系统管理员或超级用户
**** 新建用户组
	常规用户组:groupadd -g 1004 grp_techology
	系统用户组:groupadd -r grp_manage   
备注:系统用户组的GID与/etc/login.defs中的GID_MIN有关
**** 删除某用户组
	准备:(1)确保该被删除的用户组不是任何用户的初始用户组,如果是,则是不允许删除的
		 (2)应当先将该用户组内的用户成员剔除
	操作:groupdel grp_test 
备注:删除一个用户组之前,不考虑准备工作会带来一些麻烦,我测试删除用户组的过程中,没有先将用户组的成员踢出去就删除,那以前加入
这个组的用户不知道该用户组已经删除了,在使用id指令查看时,这些用户总会提示被删除的这个用户组找不到,这是不友好的
**** 给某用户组设置一个密码
	命令:gpasswd test1   (其中,test1是一个用户组名)
备注:
-->该命令本质上是在修改/etc/gshadow文件下的第二个字段:用户组密码
-->用户组密码的作用:加入该用户组的成员,在使用newgrp切换到该用户组时,需要提供该密码才允许切入
**** 将某用户组的密码删除
	命令:gpasswd -r grp_www 
备注:将grp_www用户组的密码删除
**** 将某用户组的密码失效
  命令:gpasswd -R grp_www 
**** 将某用户组失效的密码恢复正常
	命令:emacs /etc/gshadow  ---> 将第二个字段,用户组密码前面的!去掉
备注:好像没有提供相应的命令,只能这么干了
**** 给某用户组指派用户组管理员
	命令:gpasswd -A test1,test2 grp_test1   (注意:test1是用户,grp_test1的初始用户组)
备注:
-->建议将用户组的所有者设置为该用户组的管理员
-->用户test1和test2不在用户组grp_test1内,也可以设置为用户组grp_test1的管理员
-->一个用户组可以有多个用户组管理员
**** 查看某用户组中谁是用户组管理员
  命令:less /etc/gshadow  ---->  第三个字段就是用户组管理员,如果该字段为空且第二字段为!,表示该用户组不具有用户组管理员
**** 将一批用户加入到某个用户组中
	命令:gpasswd -M user1,user2,user3 grp_groupname
备注:该指令是管理员操作的,能将一批用户加入到指定的用户组中去
**** 查看某用户组下面都有哪些用户
	命令:less /etc/gshadow的第四个字段
备注:
(1)如果第四个字段为空,则说明,该用户组下面除了用户组管理员之外,再无其他用户
(2)同下面常规用户的查看不同,由于此处是管理员操作,所以可以查看权限为640的gshadow,当然了,也可查看权限为644的group
**** 查看某用户都加入过哪些用户组
**** 系统管理员将某用户加入某用户组
	命令:usermod -G grp_test,grp_www -a ljj 
 备注:
(1)G给出用户加入的用户组列表;
(2)a给出将哪个用户追加至用户组列表
**** 修改用户组GID
方案一:
	查看:id www ---> gid:1007
	命令:usermod -g 2007 grp_www 
	查看:id www ---> gid:2007
备注:将用户组grp_www的GID从1007修改为2007

方案二:
	查看:id www ---> gid:1007
	命令:groupmod -g 2007 grp_www 
	查看:id www ---> gid:2007
备注:将用户组grp_www的GID从1007修改为2007
**** 重命名用户组名
	查看:id www ---> gid=1007(grp_www)
	重命名:groupmod -n my_grp_www  grp_www
	查看:id www ---> gid=1007(my_grp_www)
备注:将用户组grp_www重命名为my_grp_www
*** 用户组管理员
**** 将某位用户加入自己的用户组 
	准备:前提是系统管理员已经为该用户组指派了用户组管理员
	操作:groups -a www grp_ljj
备注:用户组管理员管理自己的用户组时不需要具备超级权限
**** 将某用户从自己的用户组里剔除
  准备:前提是系统管理员已经为该用户组指派了用户组管理员
  命令:groups -d www grp_ljj 
*** 常规用户
**** 查看某用户加入了哪些用户组
方案一:  
      准备:切换到该用户下面;
      命令:groups ljj
备注:列出的第一个是有效用户组

方案二:
	命令: id ljj 
备注:该命令的结果如下:
uid=1000(ljj) gid=1000(ljj) 组=1000(ljj),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),1004(grp_charge)
其中:gid=1000(ljj)表示的是有效用户组;
	 组= ... 表示的是该用户加入的所有用户组

结论:建议使用方案二! 
**** 查看某用户组下面都有哪些用户
      less /etc/group 的第四个字段
备注:
(1)如果第四个字段为空,则说明,该用户组下面除了用户组管理员之外,再无其他用户
(2)同上面系统管理员的查看不同,由于此处是常规用户操作,所以仅可以查看权限为644的group而不可查看权限为640的gshadow
**** 切换用户当前所在的用户组
--用户加入的用户组:
	一个用户可能加入很多个用户组,而任意时刻,该用户只属于其中的一个用户组,可以使用groups来查看用户加入的所有用户组 

--有效用户组:
	用户当前所在的用户组,使用groups命令列出的所有用户组中,位于第一个的用户组就是该用户的当前有效用户组
    id命令列出的gid所示的用户组就是有效用户组

--切换有效用户组:
	(1)必要性:用户加入这这么多的用户组,必然需要经常切换到不同的用户组里面去办公
    (2)条件:如果想要切换进去的用户组添加了密码,需要输入该用户组的密码才能切换到该用户组
	(3)实现:newgrp xxx

--备注:
-->待切换的用户组必须是该用户加入过的用户组;
-->用户组切换是以另一个shell来提供功能的,使用exit退出当前shell后,再次使用groups查看就会发现有效用户组又恢复为初始用户组了
-->默认情况下,有效用户组就是初始用户组
-->加入该用户组的成员想要使用newgrp切换到该用户组,需要输入该密码才行(用户组管理员除外)
*** 用户加入某一用户组:
-->使用usermod:系统管理员root利用usermod帮你加入!
-->使用gpasswd:如果系统管理员root太忙了而且你要加入的用户组有设用户组管理员,可以找该用户组的用户组管理员使用gpasswd命令帮你加入进去他所管理的用户组内
** 管道数据作为密码
--需求:仅在shell script中使用
--泛型:echo "123456789" | passwd --stdin user 
--描述:标识 | 是一个管道命令,echo "123456789"的结果是流向标准输出流的--stdin的,passwd命令截取到这个标准输出流的内容123456789作为用户user的密码
Blog creation time:[2017-09-04 一 22:27]

* DONE [#C] theme:文件与目录管理
 - State "DONE"       from "TODO"       [2017-09-04 一 22:42]
** 文件类型
--基本观念：
在linux下面的一切设备都是文件

--文件种类：
1.普通文件：
--使用ls -al所显示出来的第一个字符为-的文件
2.目录：
--使用ls -al所显示出来的第一个字符为d的文件
3.纯文本文件（ASCII）：
--我们可以直接读到如数字、字母的这样的内容的文件称为纯文本文件，纯文本文件是Linux中最多的一类文件
3.二进制文件（Binary）：
--一些可以执行的文件，也是系统唯一认识的文件，例如/bin/more文件就是一个二进制文件，使用vi或者emacs打开，显示一堆人看不懂但是计算机特别懂的东西 
4.连接文件：
--使用ls -al所显示出来的第一个字符为l的文件，类似于windows上面的快捷方式
5.块设备文件：
--使用ls -al所显示出来的第一个字符为b的文件，这些文件和一些存储设备相关，例如，/dev/sda
6.字符设备文件：
--使用ls -al所显示出来的第一个字符为c的文件，这些文件和一些串行接口如鼠标键盘等相关，例如，/dev下面就有好多这样的文件
7.套接字文件：
--使用ls -al所显示出来的第一个字符为s的文件，这些文件和网络通讯相关，例如 /var下面就有好多这样的文件
8.管道文件：
--使用ls -al所显示出来的第一个字符为p的文件
9.数据格式文件（data）：
--一种特殊的文件，如/var/log/wtmp文件

--查看文件类型
1.使用ls -al查看第一个字符来判别文件的类型；
2.使用file命令：file xxx 
** 文件扩展名
1.在Linux下文件扩展名对文件的属性没有任何影响，它的价值仅仅在于告诉用户，这个文件可能是个什么东西，什么种类的，什么用途而已
真正的规范，还得需要权限的规范才行。
2.需要注意的是，网络传输后，文件的属性与权限可能会发生改变的
3.文件名长度的限制：单一文件名或目录名允许255个字符，包含全路径名允许4096字符
** 目录配置标准FHS
--为什么会有FHS：
	利用linux来开发产品或distration的团队或公司实在是太多了，如果每个人都用自己的想法来配置文件放置的目录，那么后果不堪设想
FHS标准给出什么类型的文件放置到什么目录下面。

--下面是规范给出的一些代表性的目录：
-- /:与开机、还原、系统修复操作有关，FHS标准建议，根目录所在的分区越小越好，且应用程序安装不要和它放在同一分区内
-- /usr：软件安装执行相关
-- /var:与系统运作过程有关
-- /boot：开机内核文件
-- /etc：配置文件
-- /opt：第三方软件，如KDE
** 文件权限
*** 权限的种类：
1.rwx:读、写、可执行、特殊权限;
2.权限对文件和目录有着不同的意义,说到权限首先得看对象是文件还是目录
3.文件所有者对文件具有一切权限，即使修改了文件所有者对该文件的权限
4.root对一切文件具有一切权限

*** 权限对文件的意义：
	值得注意的是，文件的原子组成是文件的内容，对文件的操作有：读文件的内容（r），编辑文件的内容（w），执行文件的内容（x），一定要记得文件的操作的对象是文件的内容。
这句话不是废话，需要深刻理解，理解这句话就能理解删除文件的操作为什么与文件自身的权限无关，而是与所在目录的权限有关，因为删除操作的对象是文件，而非文件的内容，
而文件是文件所在目录的操作对象；你也能理解复制文件的操作为什么与文件自身得权限有关而不是与文件所在目录的权限有关，因为复制操作的对象是文件内容，而非文件。
1-1.r：控制，读文件内容，的权限：cp、cat more less emacs vi
1-2.w：控制，编辑文件内容，的权限:emacs vi
1-3.x：控制，执行文件内容，的权限：./
--备注：
1.需要特别关注cp操作，复制权限受文件的r控制
2.x权限类似于windows下面具有.exe扩展名的文件，只不过linux下面不是以后缀来区分文件类型的，该权限表明该文件是否可以被系统执行。

*** 权限对目录的意义：
1.值得注意的是，目录的原子组成是文件以及子目录，对目录的操作有：进入目录（x），浏览目录（r），在目录下创建、删除、复制、移动、重命名，文件或子目录（w），
一定要记得目录的操作的对象是目录下的文件或子目录。
1-1.r：控制，浏览该目录，的权限：ls
1-2.w：控制，在目录下创建、删除、移动、重命名，文件或子目录，的权限：touch、rm、mv
1-3.x：控制，进入该目录，的权限：cd
--备注：
--对于目录来说，执行权限是放在第一位的，可以说，没有x权限，只有x、w权限是没有什么意义的：连门（目录）都不给人家进(x)，谈什么交流（rw）；
--对于目录来说，有了x权限，一般情况下都会给r权限：给人家进门了（x），肯定就是默许他参观你的家了(r)，但是不一定允许他乱动你家里的东西(w)；
--需要特别关注rm操作，删除权限受目录的w控制。

*** 文件和目录的默认权限
1.文件和目录权限的形态：
--数字形态：umask   --->  0022
--符号形态：unmask -S  --->  u=rwx,g=rx,o=rx
备注：数字形态有四位数字,最高位代表特殊权限,不用管,次高位依次往后代表：用户,用户组,其它人的权限

2.数字形态的含义:
	需要减掉的权限;如0022的含义是,针对用户组和其他人,需要拿走他的写权限,转换为符号形态即: u=rwx,g=rx,o=rx

3.文件和目录的默认权限:
	在默认权限上,文件与目录是不一样的,文件一般不会有执行权限,而执行权限对于目录来说那就十分重要了,所以有如下约定
默认文件权限:最大666,即rw-rw-rw-
默认目录权限:最大777,即rwxrwxrwx

4.更改默认权限: unmask xxx 
实例1: unmask 0022
--文件被更改了什么:用户组和其他人在默认文件权限(rw-rw-rw)的基础上,被拿掉了写权限,所以,新建文件的文件权限应当是:rw-r--r--
--目录被更改了什么:用户组和其他人在默认目录权限(rwxrwxrwx)的基础上,被拿掉了写权限,所以,新建目录目录权限应当是:rwxr-xr-x

实例2:unmask 0077
--文件被更改了什么:用户组和其他人在默认文件权限(rw-rw-rw)的基础上,被拿掉了全部权限,所以,新建文件的文件权限应当是:rw-------
--目录被更改了什么:用户组和其他人在默认目录权限(rwxrwxrwx)的基础上,被拿掉了全部权限,所以,新建目录目录权限应当是:rwx------

备注:更改后的默认权限只在当前shell下有效,重新开启shell后就失效了,

2.探讨文件和目录默认权限之间的区别：
2-1.执行umask 0022,即，默认情况下将用户组和其它人的写权限拿掉：755
2-2.新建一个文件，并查看其权限为：644
2-3.新建一个目录，并查看其权限为：755
----
2-4.执行umask 0002,即，默认情况下将其它人的写权限拿掉：775
2-5.新建一个文件，并查看其权限为：664
2-6.新建一个目录，并查看其权限为：775
结论:上面的操作中，对用户组的写权限进行测试，拿掉用户组的默认写权限后，创建的文件和目录，其用户组都不再具备写权限

3.更改默认权限：
umask 数字形态权限
例如:

4.修改权限
				-rw-r-xr-x www www 0 Jun 1 21:57 test 
1:使用8进制：chmod 754 test  --> -rw-r-xr-- www www 0 Jun 1 21:57 test 
2:使用符号：
2-1.chmod o-x test  --> -rw-r-xr-- www www 0 Jun 1 21:57 test 
2-2.chmod u+x test -->-rwxr-xr-x www www 0 Jun 1 21:57 test 
2-3.chmod u=rwx,g=rx,o=- test -rwxr-x--- www www 0 Jun 1 21:57 test 
2-4.chmod a=rx test -r-xr-xr-x www www 0 Jun 1 21:57 test

--文件和目录的隐藏属性
     去在Linux中，所有的东西都被处理成文件，所以，在Linux中文件的安全性是及其重要的，所以，在权限的基础之上
还有两个十分重要的命令用于加强文件的安全性。
1.chattr [-+=]参数 文件或目录
其中:-删除某一特殊参数，其它参数保持不变；
	+增加某一特殊参数，其它参数保持不变；
	=仅有后面的参数
参数：a：这个文件只能增加数据，不能删除、修改数据；（适合log文件使用）
	 i：该文件不可以被删除，写入数据，重命名等； 
备注：这两个参数威力巨大，只有root才能进行设置，设置完毕后，连root都不能删除文件，必须解除设置才行。

2.设置隐藏属性：chattr +i xxx ；
3.解除隐藏属性：chattr -i xxx ；
4.显示文件的隐藏属性：lsattr [-adR] 文件或目录
参数：a：将隐藏文件的属性显示出来
	 d：如果是目录，仅显示目录
	 R：连同子目录也一起列出来

--特殊权限
1.SUID：待续
2.SGID：待续
3.SBIT：待续

--更改文件所有者及文件所属用户组
--条件：
1.xxx必须存在于/etc/passwd中才行
1.只有root才有权限执行该操作

--命令：
chown -R xxx:yyy file/directory
1. -R参数表示进行递归的持续更改，一般情况下都会带-R参数
2. xxx指代更改后得用户，yyy指代更改后得用户组

--命令变形：
1.只更改文件所属用户：chown -R xxx file/directory
2.只更改文件所属用户组：chown -R :yyy file/directory 
--备注：上面得命令中的 ：也可以用 . 替代，不过还是用 ：好
其实更改文件所属用户组有单独的命令，chgrp -R xxx file/directory，不过我还是习惯用上面的chown
Blog creation time:[2017-09-04 一 22:27]
*** 文件和目录的隐藏属性
	 - State "DONE"       from ""           [2017-09-05 二 10:07]
     去在Linux中，所有的东西都被处理成文件，所以，在Linux中文件的安全性是及其重要的，所以，在权限的基础之上
还有两个十分重要的命令用于加强文件的安全性。
1.chattr [-+=]参数 文件或目录
其中:-删除某一特殊参数，其它参数保持不变；
	+增加某一特殊参数，其它参数保持不变；
	=仅有后面的参数
参数：a：这个文件只能增加数据，不能删除、修改数据；（适合log文件使用）
	 i：该文件不可以被删除，写入数据，重命名等； 
备注：这两个参数威力巨大，只有root才能进行设置，设置完毕后，连root都不能删除文件，必须解除设置才行。

2.设置隐藏属性：chattr +i xxx ；
3.解除隐藏属性：chattr -i xxx ；
4.显示文件的隐藏属性：lsattr [-adR] 文件或目录
参数：a：将隐藏文件的属性显示出来
	 d：如果是目录，仅显示目录
	 R：连同子目录也一起列出来
** 绝对路径：
1.定义：从根目录开始写起的路径
1.特点：路径较长，但是准确性较高，建议在写shellscript时使用绝对路径
** 相对路径：
1.定义：从当前目录开使，以 . 或者 .. 来定位某一目录定义出来的路径
1.特点：路径较短
Blog creation time:[2017-09-04 一 22:28]
* DONE [#C] theme:打包、压缩、解压
 - State "DONE"       from "TODO"       [2017-09-04 一 22:43]
** 压缩：
计算机中的最小单位是bit，实际使用时，最小单位是byte，这个byte总是由8个bit的0和1的形态来构成，显然
这8个bit应该是0和1的排列，通过一些算法，可以将一些重复的1简单记录，比如有100个1,就简单记录100个1
而不是真的有100个1的bit存在；也可以将一些连续的0"丢出来",并将丢出的个数记录在案以备解压，这些被“丢出来的位”
可以用于存储其它数据，这样就可以节省大量的空间。

** 解压：
压缩后的文件是没有办法直接使用的，因此，根据记录，还原压缩前的文件的过程就称为解压
** 压缩文件的扩展名：
1.理论上，扩展名在Linux中是不能反映文件的属性的，但是，由于支持压缩的命令非常多，不同的压缩命令所采用的
技术是不一样的，因此彼此间是没有办法兼容的，所以，压缩文件都会提供后缀进行标式，来提示你，应当采用哪种
压缩命令。
2.常见的压缩文件扩展名：
--*.tar*：tar程序打包的数据，并且没有压缩过
--*.gz：gzip程序压缩的文件
--*.bz2:bzip2程序压缩的文件
--*.tar.gz：tar程序打包的数据，并且经过gzip程序压缩的文件
--*.tar.bz2：tar程序打包的数据，并且经过bzip2程序压缩的文件
--*.Z：compress程序压缩的文件 （古老的压缩方法，不再流行，且gzip能解开该类型的压缩文件，不必再关注）
备注：gzip和bzip2是两个压缩程序，这两个压缩程序都只能针对单一的文件进行压缩很烦人，所以就需要tar
这个打包程序，tar能够把很多文件甚至目录给打包在一起，不过tar只能打包不能压缩，所以.tar.gz以及.tar.bzip2
就是结合了二者。

** tar详解：
1.说明：
--将多个目录或文件打包成一个大文件,不包含压缩功能；
--该命令可以结合gzip或者bzip2程序在打包的同时还进行压缩；
--该命令如此强大，以至于windows上的WinRAR也支持它； 

2.命令：
2-1.tar打包：
--创建打包文件：tar -cvp -f /tmp/c.tar ~/a.txt ~/b.txt
--查看打包文件：tar -tv -f /tmp/c.tar
--解压打包文件：tar -xv -f /tmp/c.tar -C ~/ 

2-2.gzip与bzip2压缩与解压：
--由于这两个命令只能针对单一文件进行压缩与解压，单独使用意义不大，不做单独介绍

2-3.tar打包gzip压缩与解压:  -z
--创建打包压缩文件：tar -czvp -f /tmp/c.tar.gz ~/a.txt ~/b.txt
--查看打包压缩文件：tar -tzv -f /tmp/c.tar.gz
--解压打包压缩文件：tar -xzv -f /tmp/c.tar.gz -C ~/

2-4.tar打包bzip2压缩与解压：
--创建打包压缩文件：tar -cjvp -f /tmp/c.tar.bz2 ~/a.txt ~/b.txt
--查看打包压缩文件：tar -tjv -f /tmp/c.tar.bz2
--解压打包压缩文件：tar -xjv -f /tmp/c.tar.bz2 -C ~/

Blog creation time:[2017-09-04 一 22:35]

* DONE [#C] theme:正则表达式
  CLOSED: [2017-12-26 二 15:01]
1. 知识点
   1. 处理字符串的手段 = 支持正则表达式的工具 +  正则表达式
   2. 正则表达式给出字符串的表示法, 它的作用只是以行为单位表示出指定字符串
   3. 支持正则表达式的工具给出处理字符串的方法, 它的作用是处理正则表达式给出的字符串
   4. 正则表达式是字符串处理的标准依据
   5. 正则表达式不是通配符,通配符代表的是bash接口的一个功能,而正则表达式是字符串的表示法
   6. 常见的支持正则表达式的工具: grep,awk,sed
   7. 支持通配符的工具: ls,cd等bash的接口命令均支持通配符
   8. 语系直接影响正则表达式的结果:
	  1. LANG=C: 0 1 2 3 ... 8 9 A B C D ... X Y Z a b c d ... x y z
	  2. LANG=zh_CN: 0 2 3 4 ... 8 9 a A b B c C d D ... x X y Y z Z
	  3. 针对LANG=C使用正则表达式: [A-Z] = A B C D ... X Y Z
	  4. 针对LANG=zh_CN使用正则表达式: [A-z] = A b B c C ...x X y Y z Z
	  5. 备注: 可以使用export LANG=C来设置语系
   9. 为了免疫语系对正则表达式结果的影响,给出了一些特殊的符号来代表特定的集合:
	  1. [:digit:]: 代表数字的集合: [0-9]
	  2. [:lower:]: 代表小写字母集合: [a-z]
	  3. [:upper:]: 代表大写字母集合: [A-Z]
	  4. [:alpha:]: 代表小写字母,大写字母的集合: [a-z] | [A-Z]
	  5. [:alnum:]: 小写字符,大写字母,数字的集合: [0-9] | [a-z] | [A-Z]
2. 正则表达式泛型: '元字符'
3. 正则表达式的元字符
   1. 关于元字符的重要说明:
      1. 元字符是对字符串的一种描述(更像一种范式),每个元字符规范一种类型的串
	  2. 元字符不带任何"感情色彩",仅仅是刻画符合这个元字符规范的串
	  3. 元字符描绘的对象是字符(包括回车,空格,换行等),不是单词,不是串,搞清楚这一点这是非常重要,大多数文档为了好看,经常以单词来示范,这是一个误区,下面的解释中特别以键盘随便敲击的asdf来强调这一点
	  4. 元字符描绘哪个目标文件中的串? 在目标文件中匹配到符合元字符范式的串以行为单位输出? 这两个重要的问题跟元字符无关,只跟正则表达式查找工具(如:grep,awk,sed等)相关
   2. asdf: (非元字符),拿整个 'asdf', 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	  1. 示例: grep -n 'hello world' a.txt
	  2. 解释: 在a.txt中,所有存在hello world的行都会被匹配, 然后以带行号的形式,将这些行输出
   3. [asdf]: 依次拿[]中的字符, 去逐字符匹配目标文件,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
      1. 示例: grep -n 'a[df]g' a.txt
	  2. 解释: 在a.txt中,所有存在adg和afg的行都会被匹配,然后以带行号的形式,将这些行输出
   4. [^a.sD!f]: 从效果上理解, 拿着整个'a.sD!f' 去和目标文件匹配, 若没有匹配成功(在grep中,这里说的串被解释成行), 则满足该范式;
      1. 示例: grep -n 'I like dog!' a.txt
	  2. 解释: 在a.txt中, 所有不存在I like dog!的行被锁定,然后以带行号的形式,将这些行输出
	  3. ^在此处有取反的意思
   5. ^asdf: 拿着整个 'asdf' , 去和目标文件匹配, 若匹配成功,而恰好 asdf  又在串的开始位置(在grep中,这里说的开始位置被解释为行首), 则满足该范式;
      1. 示例: grep -n '^#' a.txt
	  2. 解释: 在a.txt中, 所有以#开头的行都会被匹配,然后以带行号的形式,将这些行输出
   6. $asdf: 拿着整个 'asdf' , 去和目标文件匹配, 若匹配成功,而恰好 asdf  又在串的结束位置(在grep中,结束位置定义为行尾),则满足该范式;
      1. 示例: grep -n '$!' a.txt
	  2. 解释: 在a.txt中,所有以!结尾的行都会被匹配,然后以带行号的形式,将这些行输出
   7. \x: 拿着x(代表任意字符的转义), 去和目标文件匹配, 若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行),则满足该范式
      1. 示例: grep -n '\"' a.txt
	  2. 解释: 在a.txt中,所有含有双引号的行都会被匹配,然后以带行号的形式,将这些行输出
	  3. 备注: grep -n '\'' a.txt是错误的,此时应当写为 grep -n \' a.txt
   8. ess*: 依次拿着 es,ess,esss ... 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	  1. 重点: * 代表可以重复*前面的字符s任意次数(0次,1次...),上面的es是重复0次时匹配到的,注意,e不能被匹配
      2. 示例: grep -n 'es*' a.txt
	  3. 解释: 在a.txt中,所有存在e,es,ess,esss...的行都会被匹配,然后以带行号的形式,将这些行输出
   9. ess+: 依次拿着 ess,esss ... 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	  1. 重点: + 代表可以重复+前面的字符s大于等于1次(1次,2次...),上面的ess是重复1次时匹配到的,注意,es不能被匹配
   10. o\{2\}: 目标文件中,2个o连续出现(oo)的串将被匹配
 	   1. 注意,对于grep来说,o\{2\}的含义是2个及以上的o连续出现(oo,ooo,oooo ...)
	   2. eo\{2\}中,同样也只关注o连续出现的次数,不用关注e连续出现的次数
   11. o\{2,\}: 目标文件中,2或者2个以上的o连续出现(oo,ooo,oooo)的串将被匹配
   12. o\{1,3\}: 目标文件中,连续出现o的个数最少为1个,最多为3个的串将被匹配
   13. do\(es)?: 依次拿着 do 或者 does 去和目标文件匹配,若匹配成功,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
   14. e.e : 在目标文件中, 匹配 'e任何单个字符e',  若匹配成功,,则称目标文件中匹配点处的串(在grep中,这里说的串被解释成行), 则满足该范式
	   1. 重点: 点 . 有且仅有单个字符,注意了,一定有一个字符,而且仅仅只有一个字符 edfe是不会匹配的
	   2. 示例: grep -n 'o.o' a.txt
	   3. 解释: 在a.txt中,所有存在o字符o的行都会被匹配,然后以带行号的形式,将这些行输出
Blog creation time:[2017-10-17 二 13:32]

