* blogs-linux-arch-part1
** DONE [#D] theme:我的工具网站								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:40]
--Linux内核官网：http://www.kernel.org
--Linux官网：https://www.linux.org/
--中国linux团队：http://www.linux.org.cn/
--Fedora官方网站：http://getfedora.org
--Linux U盘启动盘工具网站：http://rufus.akeo.ie/
--GNU 官网 : http://gnu.org
--Fedora中文社区软件源：https://repo.fdzh.org/
--rpmfusion官网：https://rpmfusion.org/

--Ken Thompson的个人网站：http://plan9.bell-labs.com/cm/cs/who/ken/index.html
--Dennis Ritchie的个人网站：http://cm.bell-labs.com/cm/cs/who/dmr/
--Richard Mathew Stallman的个人网站：http://www.stallman.org
--Multics项目网站：http://www.multicians.org/
--XFree86项目网站：http://www.xfree86.org/
--IEEE POSIX标准: http://standards.ieee.org/regauth/posix/
--GPL条款：http://www.gnu.org/licenses/licenses.html#GPL
--BSD授权模式：http://en.wikipedia.org/wiki/BSD_licens
--FHS标准：http://www.pathname.com/fhs/
--LSB标准：http://www.linuxbase.org/
--CLE项目：http://cle.linux.org.tw
--Linux distributions:http://distrowatch.com/
--酷学园：http://www.study-area.org/
--鸟哥私房菜：http://linux.vbird.org/
--蓝灯翻墙：https://github.com/getlantern/lantern

kali:
中文：https://www.hackfun.org/kali-tools/kali-tools-zh.html
英文：https://tools.kali.org/tools-listing
http://blog.csdn.net/u011596455/article/details/57125844
介绍查询系统信息的命令：http://www.cnblogs.com/losbyday/p/5842661.html

ubuntu:
--Emacs软件包下载地址：http://ftp.gnu.org/gnu/emacs
--搜狗输入法官网：http://pinyin.sogou.com/

Blog creation time:[2017-09-04 一 22:16]
** DONE [#D] theme:我的快捷键习惯							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:40]
*** fedora
Keyboard:
启动终端：SUPER + T；    自定义shell：gnome-terminal
退出终端：SUPER + Q；
设置：SUPER + Z
减小音量：Alt ＋ 下
增大音量：Alt ＋ 上
浏览器：SUPER + B
家目录：SUPER + H
计算器：SUPER + C
邮件：SUPER +  E
切换到工作区1：SUPER + 1
切换到工作区2：SUPER + 2
切换到工作区3：SUPER + 3
切换到工作区4：SUPER + 4
切换窗口：SUPER + TAB
直接切换窗口：SUPER + W
切换输入法：SHIFT     搜狗输入法，添加英文键盘，禁用设置里面的快捷键、勾选搜狗输入法设置里面的切换英文状态时，保留输入窗口
关闭窗口：SUPER + Q
切换最大化状态：SUPER + 下
在右侧查看分割：SUPER + 右
在左侧查看分割：SUPER + 左
隐藏窗口：SUPER + S
显示全部应用程序：SUPER + A
显示通知列表：SUPER + V
注销：CTRL + ALT + DELETE
锁定屏幕：SUPER + L
清屏：CTRL + L

Terminal：
以新窗口中打开新终端：SUPER + T
关闭终端：SUPER + Q
关闭全部终端：CTRL + ALT + Q
复制: CTRL + SHIFT + C
粘贴: CTRL + SHIFT + V 
全选：CTRL + SHIFT + A
隐藏显示菜单：CTRL + SHIFT + S
字体大小：10
窗口大小：60 20
关闭类型：underline
透明背景：开启至最大，之后点击图标就能最小化窗口了，是不是很赞呢。

Blog creation time:[2017-09-04 一 22:17]
*** ubuntu
原则：不使用任何插件
启动终端：Ctrl + Alt + T；    自定义shell：gnome-terminal
退出终端：Ctrl + Alt + Q；
最小化窗口：Ctrl + Alt + S

切换运用程序：Alt + Tab
调整窗口大小：Ctrl + Alt + x
移动窗口：Ctrl + Alt + c

浏览器：Ctrl + Alt + B
家目录：Ctrl + Alt + H
计算器：Ctrl + Alt + C
邮件：Ctrl + Alt +  E
显示全部应用程序：SUPER + A
锁定屏幕：SUPER + L

清屏：CTRL + L
注销：CTRL + ALT + DELETE
** DONE [#D] theme:linux基础概念							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:40]
*** 计算机系统：
1.硬件<-->内核<--->系统调用（shell）<--->应用程序
*** Linx简史：
    时间      人物                      事件                    意义					
-->196x年     MIT                      分时操作系统（CTSS）      一台主机可以提供多个（30台以内）终端机，近代操作系统的鼻祖，划时代
-->1965年     Bell＋MIT＋GE（通用电器）   Multics项目             计划实现一台主机提供300台以上的终端机
-->1969年     Bell                     退出Multics项目          UNIX萌芽期，Multics项目培养了出相当优秀的人才，Ken Thompson退出该项目之后有了一些想法
-->1969年     Ken Thompson             在PDP－7上用编写UNIX内核   实现UNIX的雏形
-->1973年     K&R                      发明C语言并重写了UNIX内核  UNIX正式诞生
...           ...                      ...                     ...
-->1979年     谭宁邦                    写了一个UNIX Like：Minix  用于教育，但是Linux的诞生奠基者
-->1984年     Richard Mathew Stallman  发起GNU项目              不可磨灭
-->1984年     Richard Mathew Stallman  Emacs诞生                神器
-->1984年     Richard Mathew Stallman  GCC Bash诞生             意义重大
-->1985年     Richard Mathew Stallman  GPL（通用公共许可证）       自由软件
-->1988年     MIT                      XFree86项目              GUI 
-->1988年     Linus Torvalds           学习Minix，捣鼓inter 386   Linux萌芽
-->1991年     Linus Torvalds           在BBS上宣称自己写了一个小内核 Linux诞生
*** 查看内核版本：
uname -r:4.10.17
备注：主次版本为奇数，开发中版本
     主次版本为偶数，稳定版本
*** 几个专有名词
1.GPL：通用公共许可证，GNU的版权声明
2.POSIX：可携式操作系统接口，目的在于规范内核与应用程序的接口，由IEEE发布
3.LSB：Linux标准规范，厂商征对Linux的内核设计不同distributions时的参考标准
4.FHS：目录架构规范，厂商征对Linux的内核设计不同distributions时的参考标准
5.BSD：开源的一种授权模式
6.Linux distributions安装软件的两大系统：
6-1:RPM，RedHat  Fedora  SUSE属于此类  
6-2:DPKG，Debian Unbuntu 属于此类
*** 磁盘介绍
1.磁盘的物理组成：磁片、磁头、主轴马达、机械手臂
2.磁盘的工作原理：控制主轴马达让磁片转动，控制机械手臂，带动磁头在磁片上进行读写
3.详细剖析：
3-1:磁头：磁头是用线圈缠绕在磁芯上制作而成的，磁头可以在磁片上读写数据，其依据的原理是，盘片的电阻值会随着磁场的变化而变化
    磁头读数据的原理：通过感应旋转盘片上磁场的变化来读数据
    磁头写数据的原理：通过改变盘片上的磁场来写入数据
    工作时，磁头悬浮在高速旋转的盘片的上方而不与之接触，两者之间的间隙是0.1~0.3um，不工作时，磁头自动落回盘片上，此位置作为盘片的起始位置
3-2:磁头数：每个盘片有一个磁头，所以，盘片数总等于磁头数
3-3:盘片：在铝合金或者玻璃基底上涂磁性材料和其他多种材料加工制成
3-4:圆盘数：就是盘片的数量        
3-5:磁道：当磁头在磁片圆心到半径长度的范围内的某一位置禁止不动，磁片旋转，则磁头会在磁片上产生一个以当前位置到圆心距离为半径的圆形轨迹，
	   这样的一个轨迹称为磁道，显然，可以在圆心到半径的范围内有若干这样的磁道；
3-6:磁柱：磁盘通常由多个盘片构成，而且每个盘片都被划分成数目相等的磁道并从外向内编号，如此，各个盘片编号相等的磁道构成一个柱面
3-7:磁道数：磁道是从盘片外圈往内圈编号0磁道，1磁道...，靠近主轴的同心圆用于停靠磁头，不存储数据；
3-8:扇面：由磁盘圆心以放射状的方式分割整个盘片，称，由相邻量条射线半径、圆心以及盘片外边圆轮廓所围成的区域为一个扇面
3-9:扇区：相邻两条射线，相邻两个磁道围成的四边曲边梯形，称为一个扇区。扇区是磁盘读写擦出的最小单位，每个扇区大小固定为512B，每个扇区的两端都有一些特定的数据，这些数据构成扇区的界限标志

*** 磁盘的第一个扇区：
1.磁盘的第一个扇区是非常重要的，它记录了该磁盘的两个重要信息，分别是：
1-1.MBR：Master Boot Record,主引导加载分区，该分区有446B，里面安装最基本的引导加载程序，系统开机时，会主动去读取该区的内容
1-2.分区表：Partition table,有64B，用来记录整块硬盘的分区状态
*** 分区表：partition table
1.分区表： 
有时我们需要对磁盘进行分区，而分区的状态就被记录在了分区表里面，分区是以磁道（柱面）为参考标准的，其最小单位是柱面，64B的分区表被分为4组，每组16B，记录了
该区段的起始与结束的柱面号码，如，假设有400个柱面，1~100柱面为第一主分区，200~300柱面为第二主分区，300~400柱面为第三主分区，则，第一组的16B就为1~100,依次类推。
需要注意的是，第一个扇区里面的分区表记录的是主分区或扩展分区。
2.结论：
2-1:所谓的“分区”，只是针对那64B字节的分区表进行设置而已；
2-2:磁盘的默认分区表总共只能写入4组主分区或者扩展分区信息；
2-3:分区的最小单位是柱面；
2-4:利用那64字节来扩展更多的分区：
	上面2-2提到，磁盘分区表只能写入4组分区信息，但是，如果我们想要分更多个区怎么办，那就使用扩展分区技术，其原理如下：
2-4-1:假定磁盘有400个柱面，有分区表里面第一组标记为主分区，比如1~100柱面为第一主分区；
2-4-2:第二组标记为扩展分区，比如101~400柱面为扩展分区；
2-4-3:第三组和第四组标记为无记录；
2-4-4:对扩展分区所标记的分区号，从101开始的一块区域拿出来比如拿80B，作为扩展分区记录区，这个记录区标记101~160为第一逻辑分区，161~220为第二逻辑分区，221~280
	  为第三逻辑分区，281~340作为第四逻辑分区，340~400作为第五逻辑分区
2-4-5:逻辑分区，扩展分区持续切割就切割出来了一些个逻辑分区
2-4-6主分区，扩展分区，逻辑分区的关系：
	我们说磁盘的第一个扇区中后64个字节用作分区表，这个分区表以柱面单位为参考，要么是全部用来记录主分区的分区情况，要么是用来记录主分区和扩展分区混搭的分区情况，显然，
第二中种情况混搭的情况必然会产生一个针对扩展分区的分区表，该扩展分区的分区表用来记录逻辑分区的分区情况。事实上，我们将按扩展分区表所分的区称为逻辑分区，不要将扩展分区
与逻辑分区搞混，扩展分区受操作系统的限制最多只能有一个，在第一扇区的64字节的第二组中指定，这个扩展分区一般情况下，就是磁盘中除了主分区以外的所有磁盘空间，可以将扩展分
区理解为逻辑分区的一个全集。
备注：扩展分区最多只能有一个，主分区最多只能有4个；
	 逻辑分区是由扩展分区持续切割出来的分区；
	 主分区与逻辑才能被格式化，扩展分区不能；
	 扩展分区被破坏的话，所有逻辑分区都将会被删除；
	 磁盘的第一扇区的MBR与分区表如此重要，所以，硬盘的第一个扇区物理坏掉的话，那么，整个硬盘大概没用了
     逻辑分区的设备文件名号码一定由5号开始
*** CMOS与BIOS：
1.CMOS是一块内存芯片，这块内存用来记录各项硬件参数；
2.BIOS是直接写死到主板芯片中一某一快闪存或者EEPROM芯片上的一套程序；
3.CMOS的主要功能：记录主板上的重要参数，包括系统时间，CPU电压与频率，各项设备的I\O地址，以及IRQ等，记录这些数据需要用电，所以主板上有电池；
4.BIOS的主要功能：开机第一个执行的程序，开机时，BIOS首先加载CMOS中的参数，然后根据在BIOS中设置的启动项去加载相应存储设备里面的操作系统
*** 开机流程：
1.按电源开机；
2.计算机自动加载写死到主板闪存中的BIOS程序；
3.BIOS首先将加载CMOS中的各项参数；
4.BIOS接着去分析计算机中当前有哪些存储设备，然后根据用户设置的开机启动项BOOT尝试去取得存在的硬盘；
5.BIOS到硬盘里去读取硬盘的第一个扇区的MBR，BIOS的任务就完成了，接下来交给MBR去引导；
6.MBR程序里面有一段引导加载程序Boot loader，是操作系统在安装的时候所提供的，所以，这段引导加载程序会去加载操作系统的内核文件，MBR的任务也完成了，接下来交给内核文件；
7.内核文件开始调用操作系统的其他代码开始相关的功能。
*** Boot loader:
1.计算机硬件提供了BIOS和CMOS的支持，而硬盘的物理上提供了MBR，BIOS调用CMOS和MBR，而在我们安装操作系统的时候，操作系统往MBR里面写了一段Boot loader，这个Boot loader去调动
操作系统的内核，操作系统的内核去调用操作系统的其他组件。Boot loader会作三件事：
1-1.提供菜单：用户可以选择不同的开机选项；
1-2.载入内核文件；
1-3.转交其他loader，这句话的意思是，计算机可以有多个loader，这意味着，Boot loader不但可以安装在MBR，还可以安装在每个分区的引导扇区，这意味着每个分区都可以有启动扇区，这意味着多重引导，
     这意味着双系统，多系统的可能性。
1-4.bootloader可以安装的地点有两个：MBR和boot sector
*** 多重引导的流程：
1.MBR里面的Boot loader提供两个菜单，第一个是直接加载Windows内核的菜单，第二个是将加载工作转交给第二分区的启动扇区；
2.选择第二个启动菜单，该分区的引导加载程序只有一个启动菜单Linux
备注：安装双系统时，应当先安装windows再安装Linux，应为Windows在安装时没有提供给我们选择菜单的，它会直接覆盖调MBR以及自己所在分区的启动扇区，而Linux就有提供选项菜单
*** 内核文件：
	当安装操作系统时，内核文件是被安装到各自分区的，比如C盘安装Windows，D盘安装Linux，那么Windows的内核文件是放到C盘，Linux的内核文件放到D盘，loader只会认识自己系统分区里面的内核文件
以及其他loader而已。
*** 关于Linux的命令：
	command [-optional] parameter1 parameter2 ...
1:[-optional]作为参数选项，通常前面都有-,当选项使用全名时，使用--,例如:ls -al 或 ls -al --full-time
2:当命令太长时，使用\来转义会车，然后可以在下一行接着输入
Blog creation time:[2017-09-04 一 22:18]
** DONE [#D] theme:linux分区								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:41]
*** 关于挂载：
	Linux的所有数据都是文件的形式来呈现的，所以，Linux有一个以/为起点的目录树结构来组织磁盘上的所有文件，可是磁盘是存在分区的，我们知道各个分区之间是独立的，
所以要想使用文件系统来操作不同分区，就涉及挂载问题，挂载就是利用一个目录当成进入点，将磁盘分区的数据放置到该目录下面，进入这个目录就可以操作这个分区内的所有数据，
我们称，这个目录为挂载点。
*** 关于分区：
	上面的章节已经介绍过，在硬盘的第一个扇区有一个64字节的分区表，这个分区表描述了如何划分整个硬盘的存储空间，这个分区表被划分4组，每组16字节，有两种分区模式，
主分区和扩展分区，主分区最多4个，扩展分区最多1个。
*** 挂载点与分区的规划：
1.分区的依据：
3-1.分析这台主机的用途，依据用途去分区需要较大容量的目录；
3-2.分析读写较为频繁的目录，将这些目录从/目录中独立出来；

2.分区时我们关注焦点包括：/ /boot /swap /home /usr /var /tmp 空闲，这8个对象。
*** 分区建议：
1./:是目录树结构的根，这里存放的文件与开机、还原、系统修复有关所以，FHS建议，根目录单独挂载在某个分区，且该分区不再放置其他软件，并且这个分区应当越小越好，如此
不但性能好，根目录下的系统文件也不容易发生问题；
2./boot:在某些比较旧的主机中，BIOS可能找不到一些容量较大或者较新的硬盘的MBR，但是linux是能够安装并且将bootloader写入MBR的，在安装完成后开机，这种情况应该
是无法开机的，因为BIOS读不到MBR，无法加载bootloader，解决方案就在于这个/boot目录，这里面有linux的系统启动文件。由于BIOS捕捉到的磁盘容量不对，所以无法加载MBR，
但是，整个磁盘的前面几个扇区是能够被BIOS读取到的，因此，可以在这个磁盘的前面几个扇区分出一个100M左右的分区，并将这个分区挂载到系统启动文件目录下面，开机后BIOS就能
加载到/boot下面的启动文件。
注意：一定要将/boot分区放到整块磁盘带的最前面
3./home：该目录可以说是用户的工作目录，也就是说该目录是使用得最频繁得目录，务必单独分区出来；
4./usr：这个目录相当重要，usr 是 UNIX Software Resources的缩写，系统默认的软件（distribution发布）都安装在这里，该目录类似Windows下面的C：\Program files
所以，系统安装完后，这个目录占用硬盘的容量是最大的，随着安装软件的增多，这个目录会变得越来越大
5./var：这个目录在系统安装完成后，系统运行过程中的一些缓存，日志文件，mysql的一写文件，一些程序文件，email文件等都放在里面，随着系统的使用这个目录会变得越来越大
6./swap：该分区大小设置的规则：当物理内存小于等于4GB时，交换分区至少4GB，当物理内存4-16GB时，交换分区至少8GB，当物理内存16GB－64GB时，交换分区至少16GB，
当物理内存64G－256GB时，交换分区至少32GB。还有一哥原则时，交换分区至少为物理分区的1.5-2倍左右
7.建议预留一块不分区的磁盘容量，作为备份重要的配置文件以及脚本，以及分区练习使用，大小为总容量的1/5
*** 文件系统类型：
1.ext3/ext4:Linux适用的文件系统类型
2.LVM：有弹性调整文件系统大小的机制，可以动态的改变文件系统的大小而不改变文件数据
3.RAID：利用Linux的特性，用软件仿真出磁盘阵列的功能
4.Swap：内存交换空间
5.vfat:能同时被windows和Linux所支持的文件系统
Blog creation time:[2017-09-04 一 22:22]
** DONE [#D] theme:安装fedora25								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:41]
*** 在计算机上安装Fedora
1.下载Fedora-workstation安装包
2.准备U盘，用于制作 Linux U盘启动盘；
3.根据上面提供的网站，下载U盘启动盘制作工具；
4.在U盘上面制作Linux的U盘启动盘；
5.重启电脑，进入BIOS，修改启动项从U盘启动；
6.从U盘启动后在，选择将操作系统安装到硬盘，结束
*** 在U盘上安装Fedora
1.下载Fedora-workstation安装包
2.准备U盘A，用于制作 Linux U盘启动盘；
3.准备U盘B，用于安装U盘操作系统；
4.根据上面提供的网站，下载U盘启动盘制作工具；
5.在U盘A上面制作Linux的U盘启动盘；
6.将两个U盘同时插到电脑上，重启电脑，进入BIOS，修改启动项从U盘A启动；
7.从U盘A启动后在，选择将操作系统安装到U盘B，结束
Blog creation time:[2017-09-04 一 22:24]
** DONE [#D] theme:fedora基础配置							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:41]
*** 更新操作系统
dnf update
*** 配置FZUG源
1.打开上面给出的FZUG网址，选择网页右边的，按Fedora版本浏览，链接
2.找到free->25->x86-64->fzug-release-25-0.1.noarch.rpm
3.复制路径：https://repo.fdzh.org/FZUG/free/25/x86_64/fzug-release-25-0.1.noarch.rpm
4.安装FZUG源：dnf install 路径
5.更新缓存：dnf makecache
*** 配置rpmfusion
1打开上面给出的rpmfusion官方网站，找到 rpmfusion-free-release-25-1
2可以使用dnf install 路径，的方式安装,也可以直接下载，让包管理器自动安装
3.dnf makecache
*** 安装sogoupinyin
1.到FZUG网站上找到sogoupinyin的名字；
2.安装：dnf install sogoupintin
*** 安装kwplayer
1.pwplayer是由rpmfusion发布，所以安装它之前必须先安装rpmfusion
2.安装：dnf install kwplayer
*** 安装VLC视频播放器
dnf install gstreamer-plugins-bad gstreamer-plugins-ugly gstreamer-ffmpeg vlc

Blog creation time:[2017-09-04 一 22:25]
** DONE [#D] theme:fedora基础操作							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:41]
*** 帮助：man
1.man的文档规则：
--第一行：命令（编号），该标记有特殊意义，通常，编号都为1,表示该命令是一个在shell环境中可以操作的命令或可执行文件，这个编号有1-9,代表不同的含义
--NAME：这一行简要的说明了命令的作用
--DESCRIBES：对该命令的详细的介绍
--OPTIONS：列举该命令的所有选项
--SEE ALSO：告诉我们在其它什么地方还可以查到相关资料
2.man的用法：
--翻页符合emacs
--/或？向下查询或向上查询
--n或N向下继续或向上继续查询
--q退出
--man -f 命令：列举出所有与该命令相关的文档源
--man -k 命令：列举出所有含该命令的说明文档
*** 帮助：info
1.info与man的区别：man是UNIX里面的帮助指令，在Linux下还提供了另外一个帮助工具，info，与man一下子输出一堆信息不同的是，info将文件拆分成段落，还有超链接
2.info的文档规则：
--翻页命令符合emacs的基本命令：C v
--？查询info命令
--[Tab]:在节点之间移动
--[Enter]:进入节点
--d: 跳转到info的目录节点
--<: 移动到这个文件的顶层节点
--u：向上移动一层
--l：前进到最近一次访问的历史节点
--r：回退到最近一次访问的历史节点
--n：前往下一节点
--p：前往上一个节点
--q：退出
*** 帮助：/usr/share/doc
/usr目录是Linux的distrution软件都安装在这里，所以，这里面会有一些商家提供的关于软件的说明文档
*** Terminal与X window的切换：
	Fedora默认提供4个tty，1个x window，切换到x window的快捷键是：CTRL＋ALT＋F2,切换tty的快捷键是CTRL＋ALT＋F3  ～  CTRL＋ALT＋F6 
如果是以tty的模式启动Linux，要想使用x window，可以在终端中输入startx。
*** 注销Linux：
exit （等价于CTRL＋d）
*** 关机和重启：
	Linux是多用户操作系统，关机以及重启是个十分严肃的操作，因此有两种情况你能关掉主机：第一，你在主机面前，以x window方式操作系统，来关机和重启（身份不限）；
第二，你远程关机和重启，必须使用root身份。同时，作为root，你在关机或者重启之前要考虑一下别人的感受，你得通知人家，让人家将内存数据同步到硬盘
1.首先查看系统的使用状态：
--查看谁在线：who
--查看网络联机状态：netstat -a
--查看后台的执行程序：ps -aux
2.若有人在线，通知他：
--shutdown -k 11:15 'I will shutdown at 11:15':通知系统将在11:15时刻关机
--shutdown -r 11:15 'I will reboot at 11:15':通知在11:15时刻重启

--shutdown -h 10 'I will shutdown after 10 mins':10分钟后关机
--shutdown -r 10 'I will reboot after 10 mins':10分钟后重启

--shutdown -h 11:15 'I will shutdown at 11:15':在11:15时刻关机
--shutdown -r 11:15 'I will reboot at 11:15':在11:15时刻重启

--shutdown -h +10 :系统再过10分钟关机
--shutdown -r +10 :系统再过10分钟重启

--shutdown -h now：立即关机
--shutdown -r now：立即重启

--shutdown -c:取消
6-3.将内存数据同步到磁盘
--sync
*** 基本命令：
1.查看内核版本：uname -r
2.查找：find / -name a.txt
3.显示时间：date
4.显示日历：cal 7 2008
5.计算器：bc （保留3位小数点：scale＝3; quit 退出）
6.中断程序：CTRL＋c
7.浏览文件：ls -al --full-time
8.创建目录：mkdir -p test1/test2/test3  (-p指定递归创建)
9.进入目录：cd /home/ljj/test1/test2/test3
10.删除文件或目录：rm -rf test1/
9.复制文件：cp -a a.txt ./b.txt   (-a = -rpd:r－递归；p：权限；d：连接文件)
9'.复制文件：cp -a a.txt b.txt /home/ljj  (最后一个必须是目录)
10.备份文件：cp -au a.txt ./   (-u目标?=源)
11.移动文件或目录：mv a.tx ../
11'.移动文件或目录：mv a.tx b.txt ../  (最后一个必须是目录)
12.重命名：mv a.txt ../b.txt
13.查看文件内容：cat -n a.txt
14.查看文件内容：less a.txt (?,/查找)
15.查看第11行到20之间的数据：head -n 20 /home/ljj/a.txt | tail -n 10
14.查看命令的路径：which cd
15.查看当前目录：pwd
16.读取二进制文件：od -t -xxx file
其中：xxx为：
-- -a：利用默认字符输出
-- -c：利用ASCII码输出
-- -d：利用十进制输出
-- -f：利用浮点数输出
-- -x：利用十六进制输出
-- -o：利用八进制输出 
例如：od -t xCc /etc/issue
17.创建一个空文件：emacs 或者 vi  （建议touch只用于修改文件时间）
18.修改文件时间：touch
18-1.文件的三个时间：可信度最高的是ctime
--mtime：修改时间；文件内容最近一次被修改的时间
--ctime：状态时间；文件状态最近一次发生改变的时间，如文件权限与属性最近一次被更改的时间
--atime：访问时间；文件内容最近一次被读取的时间
18-2.查看时间（状态时间）：ls -al --full-time --time=ctime xxx
备注：亲测访问时间可信度不够，不稳定，而修改时间mtime可以使用下面18-3的方法被修改，所以
不建议将mtime和atime作为参考。使用ctime最为妥当。
18-3.修改时间：touch -t 1706050902 xxx
*** 各种查找命令
1.which：查找“执行文件”路径
1-1.命令：which ls  --> /usr/bin/ls
1-2.该命令是依据PATH所规范的路径去查找，所以cd是找不到的，它是bash的内置命令。

2.whereis：查找特定的文件
2-1.命令：whereis -[参数] xxx
2-2.参数:-b：只找二进制文件;-m：只找说明文件;-source：只找源文件
2-3.Linux系统将系统内的所有文件都记录在一个数据库文件(/var/lib/mlocate）里面，该指令是居于数据库查找的，所以速度比find快

3.locate:查找特定文件
2-1.命令：locate -[参数] xxx
2-2.参数:-r：后面接正则表达式的显示方式;-i忽略大小写；
2-3.Linux系统将系统内的所有文件都记录在一个数据库文件(/var/lib/mlocate）里面，该指令是居于数据库查找的，所以速度比find快
2-4.由于是从数据库查找，数据库默认是1天更新一次，所以，你刚创建的文件是找不到，因为它没有更新到数据库
2-5.使用updatedb就可以更新数据库。

4.find：查找指定文件
4-1.find 路径 -mtime 参数
备注：
路径：指明在哪个地方查找；
参数：
-- -mtime n：例举出所有在n天之前的“一天之内”被更改过的文件
-- -mtime +n：例举出所有在n天之前（不含n天的）的被更改过的文件
-- -mtime -n：例举出在n天之内（含n天本身）被更改过的文件
-- -newer xxx：例举出比xxx还要新的文件，用于比较两个文件之间的新旧关系
4-2.find /home -user ljj 找出与用户ljj有关的所有文件
4-3.find / -group ljj 找出与用户组ljj有关的所有文件
4-4.find / -nouser 找出系统中不属于任何人的所有文件
4-5.find / -nogroup 找出系统中不属于任何用户组的所有文件
4-6.find / -name passwd 找出文件名为passwd的这个文件
4-7.find / -type s 找出路径下所有文件类型为s的文件
4-8.find / -size +50k 找出路径下所有比50k还要大的文件
4-9.find / -name passwd -exec ls -al {} \; 
备注:-exec到\；之间的内容为为额外命令。
Blog creation time:[2017-09-04 一 22:26]
*** 进程,端口,服务
1. 查看服务: netstat -tlnp
2. 显示所有进程: ps -aux
3. 杀死进程: kill -9 PID
** DONE [#D] theme:用户与用户组管理							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:41]
*** linux如何辨识系统中的每一个用户
--用户标识:linux依据用户标识来唯一标记系统中的每一个用户,而不是依靠用户名,用户标识是给linux看的,而用户名以及用户组名是给用户看的
--用户标识由用户ID和用户组ID构成,每一个在Linux中注册的用户用户至少取得这两个ID
--用户ID:linux唯一为一个向系统注册的用户分配一个ID,称为UID
--用户组ID:每个用户可以拥有一个自己的用户组,linux为用户的用户组唯一分配一个ID,称为GID
备注:当向linux系统注册一个用户时,可以手动指定用户标识,也可以让系统自己分配,该标识将记录在/etc/passwd文件中

--在linux的终端下面,当你输入su xxx来试图切换到xxx用户时:
-->系统会首先到/etc/passwd下面找是否有xxx账户,如果没有则退出
-->如果有,则将该账号对应的UID与GID从/etc/passwd中找到并读出来,该账号的主文件夹和shell设置也一并读出来
-->进入/etc/shadow里找到对应的账号与UID,然后核对你输入的密码与记录的密码是否相符
-->如果密码相符,则将 /etc/passwd下设置的shell分配给该用户
备注:当用户登录linux主机时,/etc/passwd和/etc/shadow就必须让系统来读取,所以,这两个配置文件是极度重要的,其中的内容也是十分值得考究的,所以
应当对这四个文件做好备份(许多攻击者会将特殊账号写到这/etc/passwd中去,所以,应当做好管理)
*** 剖析/etc/passwd文件
--每一行都代表一个账号,有多少行就表示系统中有多少账号
--里面很多账号都是系统账号:bin daemon adm nobody等,这些账号不可随意删除
--系统账号和用户账号构成了整个文件
--系统账号通常是不可登录的,即分配给它的shell是nologin
--用户如果有特殊需求,也可以自行创建一个系统账号来使用
--该文件的权限:644,文件所有者是root,用户组是root

例子:
系统账号:daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
(1)-->账号名称:
	为了便于用户使用,每个用户都有一个用户名

(2)-->密码:
	x,由于密码放到/etc/shadow中去了,所以显示x,这是有原因的,该文件的权限是644,所有人都可见,这不安全,
密码放到/etc/shadow去,shadow的权限是640,所有者是root,用户组是shadow,即除root和shadow外,任何人都无法查看shadow文件

(3)-->UID:
	用户标识,UID为0代表该用户是系统管理员(root),所以,当你想要其他用户也具有root权限时,将该账号的UID改为0即可,
一个系统上是可以有多个UID为0的用户的,但是不建议多个用户的UID为0;UID为1~499是默认留给系统账号使用的,之后留给用户,UID是给系统使用的;

(4)--GID:
	用户组标识,用来标识该用户自己的用户组,默认情况下,UID号与GID号是相同的;在/etc/group文件的第(3)个字段也有一个用户组GDI,这两个GID必须是对应的,
在用户组管理时,会使用到这个GID来将用户和用户组关联起来,这里的GID叫做初始用户组

(5)--用户信息说明列:
	存储用户的全名,如LJJ,用于解释账号的意义,默认情况下填写用户账号名在这,但是如果开启了finger功能的话,该字段能提供更多的信息,
更多finger的使用参加下面的用户的那些事里面的普通用户章节

(6)--家目录路径
	每个用户账号一般都会有一个自己的家目录,以后该用户账号在系统上的办公文件都放在自己的家目录里面,当然,用户有没有家目录
起决于在执行useradd命令来添加用户的时候,有没有使用-m参数来强制为该用户生成家目录,所以,如果你想修改家目录的路径,可以修改
该字段来实现

(7)--用户shell:
	每个用户在注册时都会为其指派一个shell,该用户在登录成功之后就在指派的shell下来与系统内核通讯,可以配置该字段为该用户
提供登录shell,有一个特殊的shell叫做nologin-shell,如果为该用户指派了nologin-shell,那么该用户就没法登录了,使用该功能可以用来配置
禁止用户登录
	shell程序的路径:
-->/bin/bash
-->/bin/sh
-->/usr/sbin

-->退出shell: exit 

*** 剖析/etc/shadow文件
--每一行都代表一个账号
--该文件主要记录用户的密码
--该文件的权限:640,文件所有者是root,用户组是shadow,即除root和shadow外,任何人都无法查看shadow文件

例子:
系统:daemon:*:17212:0:99999:7:::
用户:ljj:$6$xA8e4EBv$bmGLgROKdUR7btWacgH/CmAN2aZRrPlQ8WLPE.QFq9ZEFZ2C2WLEJKGpSL3fJvGqB6gUYvn.Yd59IeZuFv9uv/:17346:0:99999:7:::
(1)-->账号名称:daemon

(2)-->密码:
	该密码是用户真正的密码,但是是经过加密的,由于规定的编码系统(如MD5)产生的密码长度必须一致,所以当该密码字段的长度发生改变时,密码就无法被编码
系统计算出来,即密码失效,所以root可以在某个用户的密码前面加上!,该用户的密码就会失效

(3)-->最近更改密码的日期:
	该字段记录了最近一次改动密码的日期,从1970年1月1日开始到最近一次修改密码,累加的天数,记录在该字段处

(4)-->密码不可被更改的天数:默认0
	该字段记录了该账号的密码从,最近一次密码更改日期开始算起,的多少天之内不能再次被更改,0,表示随时可以更改;这个设计是用来防止用户对密码一而再再而三的更改,
例如,该字段设置为20,表示,从该用户最近一次更改密码的日期开始算,20天之内该用户都不能再进行更改密码的操作

(5)-->密码需要重新更改的天数:默认99999
	该字段指定了该账号的密码从,最近一次密码更改日期开始算起,的多少天之内必须再次更改密码,如果在限制天数之后还不更改,该密码将会具有过期特性,99999,表示密码的
更改没有强制性之意;这个设计是用来提醒用户树立安全意识,因为经常更改密码是个好习惯.例如,该字段设置为20,表示,从该用户最近一次更改密码的日期开始算,20天之内该用户
需要重新设置自己的密码

(6)-->密码过期前的第多少天发出警告:(5)有效该字段才有效,默认值为7
	当设置了(5)字段之后,密码在(5)字段指示的日期之后会具有过期特性,所以该字段是用来配合(5)的,如上面的(5)给出值20设置之后,从该用户最近一次更改密码的日期开始算,
在20天之后,该用户的密码会具有过期特性,显然,如果(5)配置了而不配置(6),那么,该用户在第20天晚上使用密码登录系统时还一切正常,第二天来使用密码登录系统时,就提示该密码
过期了,这显得很唐突,所以,(6)的作用就是让该用户在配置了(5)的前提下对密码的修改有个缓冲区,比如将(6)字段设置了5,那么,在(5)配置了的前提下,用户在最近一次修改密码
之后的第15天登录系统时,系统会提示该用户,该密码又需要改了,而且再过n天密码就会过期,应当尽快修改为好

(7)-->密码过期后账号的宽限时间:(5)有效该字段才有效,默认值为空
	在(5)字段中配置了,从最近一次密码更改日期开始算起的多少天内密码会具有过期特性,注意,是具有过期特性!而不是真正的过期,一个具有过期特性的密码,还是可以使用的,只不过
当该用户使用过期的密码登录系统时,系统会强制要求你必须重设密码才能取得bash继续工作.那么,该字段(7)的作用是什么呢?那就是如果一个密码过期了,那么再过(7)字段设置的天数之后,
该用户的密码将会失效,即,该账号再也无法使用该密码登录系统了,此时,唯一的办法就是求助管理员,让管理员帮忙重新设置该用户的密码(注意,管理员设置用户的密码是不需要旧密码的)
密码过期后是否失效,0,立即失效,-1永远不失效

(8)-->账号失效日期:(收费计时账号)
	该字段用于指定该账号字段值所示的日期之后将失效,无法再使用,字段值是一个从1970年1月1日开始累加的天数值,注意,该字段多用于"收费服务"的系统中,规定一个日期,日期到了,该
账号就不能再使用了

(9)-->保留:以后扩展使用,默认为空
*** 剖析/etc/group文件
--每一行都代表一个用户组
--该文件就是GID的配置文件
--该文件的权限:644,文件所有者是root,用户组是root

例子:
系统:bin:x:1:root,bin,daemon
用户:ljj:x:1000:
(1)-->用户组名:
	为了便于用户使用,每个用户组都有一个用户组名

(2)-->用户组密码:
	同用户密码一样,用户组也可以有一个密码,这里显示x的原因和/etc/passwd中密码字段显示x的原因是一样的,真正的用户组密码在/etc/gshadow中
gshadow的权限是640,所有者是root,用户组是shadow,即除root和shadow外,任何人都无法查看gshadow文件,还是出于安全考虑

(3)-->用户组GID
	在/etc/passwd下面每个用户的第(4)个字段都有一个GID,该字段同其对应

(4)-->用户组下包含的用户:(同/etc/gshadow的第四个字段)
	每个用户在注册时都产生一个和用户名相同的用户组,并且该用户是自己用户组的组员,一般将之设置为用户组管理员;
该字段记录了用户组下面除了用户组管理员之外,加入该用户组的成员

*** 剖析/etc/gshadow文件
--该文件最大的功能就是创建用户组管理员
--一个用户组最好有一个用户组管理员,一个用户xxx被注册时都会产生一个属于该用户的用户组xxx,该用户组xxx是该用户xxx的初始用户组,对于
该用户组xxx来说,最好将xxx用户作为它的用户组管理员
--每个用户组都创建用户组管理员的好处在于,如果其他用户想要加入该用户组,而系统管理员又很忙,没时间用usermod来帮用户加入用户组时,这些用户可以去
找该用户组的管理员帮忙,让他使用gpasswd命令帮忙加入他所管理的用户组

例子:
系统:daemon:*::
用户:ljj:!::
(1)-->用户组名:
	为了便于用户使用,每个用户组都有一个用户组名

(2)-->用户组真实的密码
	如果该字段为!就表示该用户组不具有用户组管理员,加入该用户组的成员想要使用newgrp切换到该用户组,需要输入该密码才行(用户组管理员除外)

(3)-->用户组管理员账号:
	当使用gpasswd命令来指派用户组的管理员时,指派到的管理员就填充到该字段

(4)-->用户组下面包含的用户:(同/etc/group的第四个字段)
	每个用户在注册时都会有一个自己的用户组,如xxx用户通过useradd命令向系统注册用户,注册成功后就有产生了一个可以登录系统的xxx用户,同时,还产生了一个名为
xxx的用户组,这个xxx用户组的所有者就是xxx用户,此时,其他用户,如yyy,可以加入到xxx用户的用户组xxx里面,成为xxx用户组的成员,xxx用户是xxx用户组的小组长,yyy用户是组员;当然了,
xxx用户也可以加入到yyy用户拥有的用户组yyy里面去,此时yyy用户是yyy用户组的小组长,而xxx用户变成了组员
	该字段记录了用户组下面除了用户组管理员之外,加入该用户组的成员

*** 剖析/etc/default/useradd文件
--useradd命令在缺省选项的情况下也能成功注册用户,那是因为系统定义了在缺省选项的情况下,默认的处理方式
--/etc/default/useradd文件就给出了useradd xxx时的默认值

分析:
# Default values for useradd(8)
#
# The SHELL variable specifies the default login shell on your
# system.
# Similar to DHSELL in adduser. However, we use "sh" here because
# useradd is a low level utility and should be as general
# as possible
SHELL=/bin/sh    //系统默认的shell,假如系统是作为mail server,那么可以设置为/usr/sbin/nologin,不允许用户登录系统
#
# The default group for users
# 100=users on Debian systems
# Same as USERS_GID in adduser
# This argument is used when the -n flag is specified.
# The default behavior (when -n and -g are not specified) is to create a
# primary user group with the same name as the user being added to the
# system.
#GROUP=100     //当系统用户组的类型为公有用户组时,该设置才开启,使用私有用户组时,此项设置应当注释
#
# The default home directory. Same as DHOME for adduser
#HOME=/home    //家目录 
#
# The number of days after a password expires until the account 
# is permanently disabled
#INACTIVE=-1    //密码过期后是否失效,0,立即失效,-1永远不失效,shadow中的第(7)字段
#
# The default expire date
#EXPIRE= 		//账号失效日期,shadow中的第(8)个字段 
#
# The SKEL variable specifies the directory containing "skeletal" user
# files; in other words, files such as a sample .profile that will be
# copied to the new user's home directory when it is created.
#SKEL=/etc/skel    //注册用户完成后,用户的家目录下的问价会从该目录下拷贝过去
#
# Defines whether the mail spool should be created while
# creating the account
#CREATE_MAIL_SPOOL=yes   //是否创建用户的mailbox,如果开启的话,在/var/spool/mail/下面有各个用户的专用邮件信箱
*** 剖析/etc/skel/目录
--该目录是用户主文件夹参考基准目录
--每一个用户在注册时,如果指定了-m参数创建了用户主文件夹,那么,系统会将/etc/skel/目录下的全部文件复制到刚注册的用户的家目录下面,
默认有.bashrc .profile .bash_logout  examples.desktop(ubuntu16.04)
--该文件的权限是755,用户为root,用户组为root
--显然,管理员可以在该文件夹下面加入一些文件,当进行用户注册时,这些文件就会被分发到每一个注册用户的家目录下
-->(1)使用root权限将.emacs.d复制到该目录下; 

*** 剖析/etc/login.defs
--MAIL_DIR /var/mail:用户默认邮件信箱放置路径
--UMASK 027:注册用户时,如果指明生成家目录,则将家目录的默认权限设置为750,用户组里面的成员才允许进入
--PASS_MAX_DAYS   99999:shadow中的第(5)字段
--PASS_MIN_DAYS   0:shadow中的第(4)字段
--PASS_WARN_AGE   7:shadow中的第(6)字段

--UID_MIN				 1000:用户最小的UID,默认每注册一个常规用户自增1,系统用户比它小
--UID_MAX			    60000:用户最大的UID
--GID_MIN                1000:用户组最小的GID,默认每注册一个常规用户组自增1
--GID_MAX               60000:用户组最大的GID

--USERGROUPS_ENAB yes		 :yes意味着使用useradd时,将创建一个与用户名一样的用户组,使用userdel时,如果用户的用户组没有其他成员,将移除该用户组
*** 用户的那些事
**** 系统管理员或超级用户
***** 更改新注册用户家目录的默认权限
--需求:管理员希望为新注册的账户的家目录设置统一的权限(在注册之前设置好),以后注册的账户的家目录都这这个设定值如700
--实现:sudo emacs /etc/login.defs  --> 更改UNMASK 0077
***** 添加新注册用户家目录中的默认文件 
--需求:管理员希望,每个用户在创建之后,这些用户的家目录里面都默认有某些工作的基础文档或者通告之类的
--实现:将希望默认添加的文件加入到/etc/skel/目录下即可
***** 注册用户
	系统用户:useradd -r test    (-r:指定创建的是系统用户)

-->	常规用户:useradd -m -s /bin/bash -G grp_group1,grp_group2 -c "2nd user" test   (除了加入-G指向的组列表,还会创建test用户组)
	*常规用户:useradd -m -s /bin/bash -U -c "3th user" test2
    *常规用户:useradd -m -s /bin/bash -N -g grp_group1 -c "4th user" test3
--> 更改用户组名:groupmod -n grp_test test

建议:
	使用上面箭头给出的方案来创建,之后再使用groupmod改一下用户组名,因为,默认用户组和用户组是同名的,这样
容易对以后的用户组管理造成混乱,我的原则是:用户组名 = "grp_" + 用户名 

原则:
(1)创建用户时不指定UID和GID而让系统自己指定;
(2)创建用户时不考虑对该用户进行配置,配置在后期由管理员或者用户组管理员来进行专业的配置
(3)常规用户都创建家目录,且指定shell为/bin/bash
(4)常规用户都重设用户组名而不是默认与用户组同名,以便后期用户组管理时方便区分

备注:
--m:指定强制为该用户创建家目录
--s指定默认shell
--G指定的是一个已经存在的用户组列表,表示现在新建的这个用户都会加入到-G指定的这些用户组中去
--U指定创建一个和用户同名的组,并将用户添加到组中
--N -g指定不要创建同名组,而是将用户添加到 -g 选项指定的组中去
--查看该系统使用useradd xxx添加用户的默认配置:useradd -D,这些默认值在/etc/default/useradd中配置
--经测试,ubuntu16.04使用useradd xxx时,默认不会创建主文件夹,不会为其分配shell,所以需要使用-m和-s手动指派
--如果使用了-r,则除非使用-m,否则不会为系统账号创建主文件夹

***** 删除用户
    准备工作1:less /etc/groups 看第四个字段是否有其他用户加入该用户的用户组,有则进入准备工作3,没有则进入准备工作2   
	准备工作2:find -/ -user xxx
	准备工作3:gpasswd -A another_user xxx_group  (xxx被罢免了!将他之前的用户组管理员身份转交给另一位在该用户组内的用户)  
	操作:userdel -r xxx 
备注:
--> r选项指示连用户的主文件目录也一起删除
--> 由于待删除的用户可能在系统上工作一阵子了,系统内可能还有该用户的文件(邮件),所以,如果想要完整的删除该用户,在执行删除操作之前
应当先查找出整个系统内该用户的文件删除之后,再执行删除用户操作
--> 由于/etc/login.defs中设置USERGROUPS_ENAB yes,所以使用userdel删除用户时,如果用户的用户组没有其他成员,将移除该用户的用户组
***** 设置用户密码
	用户自己设置:passwd www  --> 提示:输入当前密码 --> 两次提示:输入新密码
	系统管理员设置:passwd www --> 两次提示:输入新密码
备注:
--用户设置自己的密码需要提供以前的旧密码,系统管理员设置某用户的密码则直接设置即可
--当用户忘记密码时可以找管理员帮忙,管理员的密码一定不能忘记
***** 查看用户密码状态
使用passwd命令:
--测试当前用户的密码状态:passwd -S 
--测试系统所有用户的密码状态:passwd -a -S (管理员或超级用户可用)
实例:
	ljj P 06/29/2017 0 99999 7 -1
(1)-->用户的登录名:ljj
(2)-->L:用户密码已经锁定; NP:用户没有密码; P:密码可用
(3)-->最后一次更改密码的日期:2017-06-29
(4)-->shadow中的第(4)字段,最近一次密码更改日期开始算起,的多少天之内不能再次被更改,0,表示随时可以更改
(5)-->shadow中的第(5)字段,最近一次密码更改日期开始算起,的多少天之内必须再次更改密码,如果在限制天数之后还不更改,该密码将会具有过期特性,99999,表示密码的更改没有强制性之意
(6)-->shadow中的第(6)字段,密码过期前的第多少天发出警告,(5)字段配置了的情况下该字段才有效
(7)-->shadow中的第(7)字段,密码过期后是否失效,0,立即失效,-1永远不失效

使用chage命令:(推荐)
ljj@Ubuntu-16:~$ chage -l ljj
最近一次密码修改时间				： 6月 29, 2017
密码过期时间					    ： 从不
密码失效时间					    ： 从不
帐户过期时间						： 从不
两次改变密码之间相距的最小天数		：0
两次改变密码之间相距的最大天数		：99999
在密码过期之前警告的天数        	：7

***** 配置用户密码(shadow文件)
--最近更改密码的日期:<shadow中的第(3)字段>
	修改:chage -d 2017-07-10 www  
	查看:chage -l www

--密码多少天内不可被更改:<shadow中的第(4)字段>
	配置:chage -m 20 www 
	移除:chage -m 0 www  (0,表示无此限制,可在任何时间更改)
    查看:chage -l www
备注:该配置对于管理员或者超级用户来说没有限制作用;以最近一次更改密码的日期为起点开始算

--密码多少天内需要重设:<shadow中的第(5)字段>
	配置:chang -M 20 www 
	恢复:chage -M 99999 www
	移除:chage -M -1 www   (移除密码的有效性检查)
    查看:chage -l www
备注:以最近一次更改密码的日期为起点开始算

--密码过期前的多少天发出警告:<shadow中的第(6)字段>
	配置:chage -W 10 www
    查看:chage -l www
	
--密码过期后宽限都少天密码失效:<shadow中的第(7)字段>
	配置:chage -I 3 www
    查看:chage -l www
备注:以密码过期的那一天的日期为起点开始算;该期限过后还没有更改密码,以后就都进不去了,只能找管理员帮忙

--账号失效时间:<shadow中的第(8)字段>
	配置:chage -E 2017-08-01 www
	上锁:chage -E 0 www    (立即失效)
	移除:chage -E -1 www   (从不失效)
	查看:chage -l www
***** 强制用户首次登录系统时更改密码
--需求:管理员可能想要用户在第一次登录时强制他们一定要更改密码之后才能使用系统资源

--实现:chage -d 0 www

--恢复:chage -d 2017-6-29 www (即重新为www指定一个不为0的密码最近修改日期即可),当然了,也可以重设一次密码

--分析:
	由于-d选项是用来指明最近更改密码的日期,该日期被指定为0,实际上就是1970-01-01,这会有问题,当你这样配置后,你使用
chage -l www指令来查看密码状态,发现密码状态变为:密码必须更改,当你此刻切换到www输入密码登录时,系统会强制要求你重设自己的密码

***** 配置用户账户(passwd文件)
--用户名:<passwd中的第1字段>
	修改:usermod -l newer
	*修改主文件名:mv /home/test1 /home/test2 
	*修改邮件池:mv /var/pool/mail/test1 /var/pool/mail/test2 (备注:邮件目录需要查看/etc/login.defs中给出的定义)
备注:该配置只是将用户名更改为newer,不会更改别的任何东西,所以,用户的主目录名和邮件池需要手动修改以和新登录名对应

--用户UID:<passwd中的第3字段>
	修改:usermod -u 1003 test 

--用户组GID:<passwd中的第4字段>
	修改:usermod -g 1004 test 
备注: 
(1)表示强制使用1004这个用户组作为test这个用户的用户组,其中1004这个用户组必须存在;
(2)用户主目录中,属于原来的主组的文件将转交新组所有,主目录之外的文件所属的组必须手动修改;

--用户信息说明列:<passwd中的第5字段>
	修改:usermod -c "this is test count!" test 

--家目录路径:<passwd中的第6字段>
	修改:usermod -d /home/tmp/test test 

--用户shell:<passwd中的第7字段>
	修改:usermod -s /bin/sh test 
***** 用户密码上锁与解锁
	上锁:passwd -l www  
	解锁:passwd -u www	
备注:
--这两条指令实际上配置的是/etc/shadow中的第(2)密码字段,事实上就是在密码的前面加上!来改变密码的长度,使得密码无法被编码系统解析
--由于shadow的权限是640,所以只有管理员或者超级用户才能执行上面的两条指令
***** 用户账户上锁与解锁
	上锁:chage -E 0 www    (账户立即失效)
	解锁:chang -E -1 www   (恢复账户,且永不失效)
备注:
--本质上,配置的是/etc/shadow中的第8个字段
--如果只是想让该账号暂时不启用,那可以使用该命令将其封锁,以后使用时再解锁,如果真正确定不让该用户在主机上使用任何数据了,那使用userdel删除账号

***** 将某用户设置为超级用户
--添加超级用户:
	(1)切换至root: su root
    (2)为/etc/sudoers文件添加写权限:chmod u+w /etc/sudoers
	(3)使用emacs打开该文件并添加超级用户:
-->如下所示:添加www用户    
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    www             ALL=(ALL:ALL) ALL 
    # Members of the admin group may gain root privileges
    %admin ALL=(ALL) ALL
   (4)减去/etc/sudoers文件的写权限:chmod u-w /etc/sudoers

--使用系统用户创建文件:sudo -u sshd touch /tmp/mysshd
备注:-u参数后面接想要切换的用户,无-u参数则默认为接root
意义:sshd是一个系统账号,其shell是/usr/sbin/nologin,即无法登录,即无法创建文件,此时使用sudo之后可以愉快的创建一个属于sshd用户的文件了

--当前用户为hello,在www用户的家目录下:sudo -u www touch test.txt ---> 输入hello的密码 ---> 在/etc/sudoers中验证hello是否具备超级权限 ---> 是,创建成功,否创建失败
***** 将某用户设置为管理员
--需求:
	在一个大型项目中,系统管理员root可能一个人忙不过来,所以在考虑清楚之后可以将少数几个极其信赖的
人设置为管理员,一般不建议这么干,因为有sudo这个工具

--依据:
	用户UID为0的用户,系统就认为它是管理员,所以,可以注册某用户,指定其UID为0,则该用户和root一样就是系统管理员了

--实现:
-->useradd -r -o -N -g 0 -u 0 -s /bin/bash super 
备注:
	-r:指明是一个系统账户
	-o:指明允许重复UID    (必须有的关键选项)
	-N -g:指明不创建用户组,而是把该用户添加到-g所指定的用户组下面去
    -u:指明

--当这样做以后,有个大问题就是你无法再使用root删除掉super,因为此时super就是root,root就是super(本质上他们还是各是各的,因为他们各自有各自的密码,家目录),
想要删除掉super那只有emacs /etc/passwd,将super的UID和GID改掉,之后就可以使用userdel -r super来删除了

***** 修改用户的UID
	查看:id www ---> uid:1007
	命令:usermod -u 2007 www 
	查看:id www ---> uid:2007
备注:将用户www的UID从1007修改为2007
***** 修改家目录路径
	命令:usermod -d /home/NewUser -m Olduser
备注:将Olduser用户的家目录路径指向/home/Newuser,并将之前家目录里面的文件移动到该路径下
***** 重命名用户名
       usermod -l NewUser -d /home/NewUser -m OldUser
-l 修改用户名
-d 修改登录后使用的路径
-m 修改登录名称的同时将目录名称一同修改

-->用户名重命名之后，注意检查 ~/.local/ 目录下，很多旧文件还是保存着旧用户名作为路径的，使用sed -i 改一改就好
-->如果使用了用户组,一方面需要将该用户从他加入过的用户组中去除,然后将重命名之后的用户名加入到这些用户组里面来,另一方面,
该用户所管辖的用户组最好也改一下名和重命名后的用户名保持一致

备注:系统管理员才能进行该操作,另一方面,一旦用户注册完毕后很不建议重命名,因为该用户可能在系统中有了很多文件,重命名之后这些文件就变成无主的了
**** 常规用户
***** 来回修改默认权限
--需求:
	出于安全的考虑,用户在新建文件时,需要考虑该文件用户具有哪些权限,用户组具有哪些权限,其他人具有哪些权限,通常的做法是
先把文件给touch出来,然后再去修改它的权限,这是很麻烦的,实际上,我们使用系统的环境应该是这样的:某用户会加入许多个用户组进行办公,
该用户在每个用户组里面的职责是不同的,所以,该用户登录系统的第一件事应当是考虑应该切换到哪个用户组去工作,在这之后,我们自然需要
设置默认权限,因为接下来该用户touch的文件都是属于该用户组的,在这个用户组完成工作后,该用户又得切换到其他用户组完成其他工作了,切换
过去之后,该用户发现这个用户组里面完成的工作可能是绝密的,所以他又得修改用户默认权限了

--思想:
	修改默认权限的思想不同于传统的先touch文件,再去修改权限这样的思想,修改默认权限是先考虑权限,再touch文件,在实际工作中,通常修改默认
权限的思想更加高效

--实现:umask 0002,被拿走的权限,详情参考文件与目录管理的默认权限章节
***** 添加用户的个人办公信息
	命令：chfn ljj 
备注：依照提示，会要求你依次输入名字，办公室门牌号，电话
***** 查看用户登录信息和状态信息
	命令:finger　ljj   
备注:该命令返回:用户账号,全名(passwd的第5个字段批注),家目录路径,当前使用的shell,用户登录主机的情况,邮件，电话,门牌号等
***** 查看系统可用的shell
	命令:chsh -l
	*命令:less /etc/shells
备注:chsh -l本质上就是列举出/etc/shells里面的内容,ubuntu16.04的测试中,该命令失效所以可直接查看/etc/shells

***** 查看系统当前shell
   命令:finger www 
***** 切换系统shell
	命令:chsh -s /bin/sh ljj
备注:该修改完成后,需要重启才能生效
***** 查看用户UID和GID
   命令:id www
***** 判断系统中是否有某用户
	命令:id xxx 
备注:如果该用户xxx存在,则返回其用户ID和用户组GID,不存在则显示无此账户
*** 用户组的那些事
**** 用户组知识
--用户组研究的角度:
	显然我们可以有两个视角来研究用户组,第一个视角是用户组yyy下面有哪些用户;第二个视角是用户xxx加入了哪些用户组,实践证明,第二个视角是分析用户组
正确的视角,因为工作模式是这样的,某用户登录了系统,在系统中,该用户需要来回切换用户组,以区分在不同用户组里面干的活

--初始用户组与有效用户组:
	一个用户可以加入多个用户组中,此时,有一个问题来了,如果这个用户使用touch a.txt新建了一个文件,那么使用ls -al a.txt时,
你觉得a.txt的用户组字段应该是谁呢?基于这个问题,就有了初始用户组和有效用户组的概念
	有效用户组:a.txt的用户组字段显示的一定是有效用户组,那如何判断一个用户当前的有效用户组呢?最简单的方法是,使用使用该用户登录系统后,
使用groups命令列出该用户都加入过哪些用户组,排在最前面的那个用户组就是该用户的有效用户组啦,此时,使用touch a.txt新建了一个文件时,文件属性
的用户组字段就是当前的有效用户组;
	初始用户组:在/etc/passwd文件的第(4)个字段所示的GID就是初始用户组
	备注:一个用户可以加入很多个用户组,其中某一时刻只能有一个用户组是该用户的有效用户组,该用户在创建文件时,该文件所属的用户组就是有效用户组;
该用户也唯一有一个初始用户组,在该用户所加入的所有用户组中,除了初始用户组和有效用户组以外,还会有其他的用户组,暂且称为不活跃的用户组,显然,我们
就有这么一种需求,既然该用户加入了这么多的用户组,如果把每个用户组当成一个团队,相当于一个人同属于多个团队,那问题来了,今天我可能需要在这个团队干活,
即在这个用户组内创建文件,明天我可能又需要在另一个团队干活,即在另一个用户组创建文件,那么必然需要做有效用户组的切换

--用户组的两种机制:
(1)私有用户组机制:
	系统为每个注册用户都创建一个与用户名一样的用户组给用户作为该用户的初始用户组,以后其他用户可以加入该用户组,这种方案还规定主文件夹的权限是700
该用户也可以加入其他用户组私有用户组的代表系统有Fedora,RHEL,Centos
(2)公有用户组机制:
	在/etc/default/useradd文件里面,GROUP的值是一个已经存在的用户组的GID,以后向系统注册的所有用户都使用这个GID的用户组作为初始用户组,即注册用户不再
为其单独生成一个自己的用户组,每个用户都加入到GROUP指定的用户组里面去,而且,这种方案还规定主文件夹的权限是755,大家都可以互相分享对方家目录下面的东西
代表性的系统有SuSe
备注:Ubuntu16.04的用户组方案采用私有用户组,但是家目录的权限同公有用户组为755

**** 系统管理员或超级用户
***** 新建用户组
	常规用户组:groupadd -g 1004 grp_techology
	系统用户组:groupadd -r grp_manage   
备注:系统用户组的GID与/etc/login.defs中的GID_MIN有关
***** 删除某用户组
	准备:(1)确保该被删除的用户组不是任何用户的初始用户组,如果是,则是不允许删除的
		 (2)应当先将该用户组内的用户成员剔除
	操作:groupdel grp_test 
备注:删除一个用户组之前,不考虑准备工作会带来一些麻烦,我测试删除用户组的过程中,没有先将用户组的成员踢出去就删除,那以前加入
这个组的用户不知道该用户组已经删除了,在使用id指令查看时,这些用户总会提示被删除的这个用户组找不到,这是不友好的
***** 给某用户组设置一个密码
	命令:gpasswd test1   (其中,test1是一个用户组名)
备注:
-->该命令本质上是在修改/etc/gshadow文件下的第二个字段:用户组密码
-->用户组密码的作用:加入该用户组的成员,在使用newgrp切换到该用户组时,需要提供该密码才允许切入
***** 将某用户组的密码删除
	命令:gpasswd -r grp_www 
备注:将grp_www用户组的密码删除
***** 将某用户组的密码失效
   命令:gpasswd -R grp_www 
***** 将某用户组失效的密码恢复正常
	命令:emacs /etc/gshadow  ---> 将第二个字段,用户组密码前面的!去掉
备注:好像没有提供相应的命令,只能这么干了
***** 给某用户组指派用户组管理员
	命令:gpasswd -A test1,test2 grp_test1   (注意:test1是用户,grp_test1的初始用户组)
备注:
-->建议将用户组的所有者设置为该用户组的管理员
-->用户test1和test2不在用户组grp_test1内,也可以设置为用户组grp_test1的管理员
-->一个用户组可以有多个用户组管理员
***** 查看某用户组中谁是用户组管理员
   命令:less /etc/gshadow  ---->  第三个字段就是用户组管理员,如果该字段为空且第二字段为!,表示该用户组不具有用户组管理员
***** 将一批用户加入到某个用户组中
	命令:gpasswd -M user1,user2,user3 grp_groupname
备注:该指令是管理员操作的,能将一批用户加入到指定的用户组中去
***** 查看某用户组下面都有哪些用户
	命令:less /etc/gshadow的第四个字段
备注:
(1)如果第四个字段为空,则说明,该用户组下面除了用户组管理员之外,再无其他用户
(2)同下面常规用户的查看不同,由于此处是管理员操作,所以可以查看权限为640的gshadow,当然了,也可查看权限为644的group
***** 查看某用户都加入过哪些用户组
***** 系统管理员将某用户加入某用户组
	命令:usermod -G grp_test,grp_www -a ljj 
 备注:
(1)G给出用户加入的用户组列表;
(2)a给出将哪个用户追加至用户组列表
***** 修改用户组GID
方案一:
	查看:id www ---> gid:1007
	命令:usermod -g 2007 grp_www 
	查看:id www ---> gid:2007
备注:将用户组grp_www的GID从1007修改为2007

方案二:
	查看:id www ---> gid:1007
	命令:groupmod -g 2007 grp_www 
	查看:id www ---> gid:2007
备注:将用户组grp_www的GID从1007修改为2007
***** 重命名用户组名
	查看:id www ---> gid=1007(grp_www)
	重命名:groupmod -n my_grp_www  grp_www
	查看:id www ---> gid=1007(my_grp_www)
备注:将用户组grp_www重命名为my_grp_www
**** 用户组管理员
***** 将某位用户加入自己的用户组 
	准备:前提是系统管理员已经为该用户组指派了用户组管理员
	操作:groups -a www grp_ljj
备注:用户组管理员管理自己的用户组时不需要具备超级权限
***** 将某用户从自己的用户组里剔除
   准备:前提是系统管理员已经为该用户组指派了用户组管理员
   命令:groups -d www grp_ljj 
**** 常规用户
***** 查看某用户加入了哪些用户组
方案一:  
      准备:切换到该用户下面;
      命令:groups ljj
备注:列出的第一个是有效用户组

方案二:
	命令: id ljj 
备注:该命令的结果如下:
uid=1000(ljj) gid=1000(ljj) 组=1000(ljj),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),1004(grp_charge)
其中:gid=1000(ljj)表示的是有效用户组;
	 组= ... 表示的是该用户加入的所有用户组

结论:建议使用方案二! 
***** 查看某用户组下面都有哪些用户
      less /etc/group 的第四个字段
备注:
(1)如果第四个字段为空,则说明,该用户组下面除了用户组管理员之外,再无其他用户
(2)同上面系统管理员的查看不同,由于此处是常规用户操作,所以仅可以查看权限为644的group而不可查看权限为640的gshadow
***** 切换用户当前所在的用户组
--用户加入的用户组:
	一个用户可能加入很多个用户组,而任意时刻,该用户只属于其中的一个用户组,可以使用groups来查看用户加入的所有用户组 

--有效用户组:
	用户当前所在的用户组,使用groups命令列出的所有用户组中,位于第一个的用户组就是该用户的当前有效用户组
    id命令列出的gid所示的用户组就是有效用户组

--切换有效用户组:
	(1)必要性:用户加入这这么多的用户组,必然需要经常切换到不同的用户组里面去办公
    (2)条件:如果想要切换进去的用户组添加了密码,需要输入该用户组的密码才能切换到该用户组
	(3)实现:newgrp xxx

--备注:
-->待切换的用户组必须是该用户加入过的用户组;
-->用户组切换是以另一个shell来提供功能的,使用exit退出当前shell后,再次使用groups查看就会发现有效用户组又恢复为初始用户组了
-->默认情况下,有效用户组就是初始用户组
-->加入该用户组的成员想要使用newgrp切换到该用户组,需要输入该密码才行(用户组管理员除外)
**** 用户加入某一用户组:
-->使用usermod:系统管理员root利用usermod帮你加入!
-->使用gpasswd:如果系统管理员root太忙了而且你要加入的用户组有设用户组管理员,可以找该用户组的用户组管理员使用gpasswd命令帮你加入进去他所管理的用户组内
*** 管道数据作为密码
--需求:仅在shell script中使用
--泛型:echo "123456789" | passwd --stdin user 
--描述:标识 | 是一个管道命令,echo "123456789"的结果是流向标准输出流的--stdin的,passwd命令截取到这个标准输出流的内容123456789作为用户user的密码
Blog creation time:[2017-09-04 一 22:27]
** DONE [#D] theme:文件与目录管理							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:42]
*** 文件类型
--基本观念：
在linux下面的一切设备都是文件

--文件种类：
1.普通文件：
--使用ls -al所显示出来的第一个字符为-的文件
2.目录：
--使用ls -al所显示出来的第一个字符为d的文件
3.纯文本文件（ASCII）：
--我们可以直接读到如数字、字母的这样的内容的文件称为纯文本文件，纯文本文件是Linux中最多的一类文件
3.二进制文件（Binary）：
--一些可以执行的文件，也是系统唯一认识的文件，例如/bin/more文件就是一个二进制文件，使用vi或者emacs打开，显示一堆人看不懂但是计算机特别懂的东西 
4.连接文件：
--使用ls -al所显示出来的第一个字符为l的文件，类似于windows上面的快捷方式
5.块设备文件：
--使用ls -al所显示出来的第一个字符为b的文件，这些文件和一些存储设备相关，例如，/dev/sda
6.字符设备文件：
--使用ls -al所显示出来的第一个字符为c的文件，这些文件和一些串行接口如鼠标键盘等相关，例如，/dev下面就有好多这样的文件
7.套接字文件：
--使用ls -al所显示出来的第一个字符为s的文件，这些文件和网络通讯相关，例如 /var下面就有好多这样的文件
8.管道文件：
--使用ls -al所显示出来的第一个字符为p的文件
9.数据格式文件（data）：
--一种特殊的文件，如/var/log/wtmp文件

--查看文件类型
1.使用ls -al查看第一个字符来判别文件的类型；
2.使用file命令：file xxx 
*** 文件扩展名
1.在Linux下文件扩展名对文件的属性没有任何影响，它的价值仅仅在于告诉用户，这个文件可能是个什么东西，什么种类的，什么用途而已
真正的规范，还得需要权限的规范才行。
2.需要注意的是，网络传输后，文件的属性与权限可能会发生改变的
3.文件名长度的限制：单一文件名或目录名允许255个字符，包含全路径名允许4096字符
*** 目录配置标准FHS
--为什么会有FHS：
	利用linux来开发产品或distration的团队或公司实在是太多了，如果每个人都用自己的想法来配置文件放置的目录，那么后果不堪设想
FHS标准给出什么类型的文件放置到什么目录下面。

--下面是规范给出的一些代表性的目录：
-- /:与开机、还原、系统修复操作有关，FHS标准建议，根目录所在的分区越小越好，且应用程序安装不要和它放在同一分区内
-- /usr：软件安装执行相关
-- /var:与系统运作过程有关
-- /boot：开机内核文件
-- /etc：配置文件
-- /opt：第三方软件，如KDE
*** 文件权限
**** 权限的种类：
1.rwx:读、写、可执行、特殊权限;
2.权限对文件和目录有着不同的意义,说到权限首先得看对象是文件还是目录
3.文件所有者对文件具有一切权限，即使修改了文件所有者对该文件的权限
4.root对一切文件具有一切权限

**** 权限对文件的意义：
	值得注意的是，文件的原子组成是文件的内容，对文件的操作有：读文件的内容（r），编辑文件的内容（w），执行文件的内容（x），一定要记得文件的操作的对象是文件的内容。
这句话不是废话，需要深刻理解，理解这句话就能理解删除文件的操作为什么与文件自身的权限无关，而是与所在目录的权限有关，因为删除操作的对象是文件，而非文件的内容，
而文件是文件所在目录的操作对象；你也能理解复制文件的操作为什么与文件自身得权限有关而不是与文件所在目录的权限有关，因为复制操作的对象是文件内容，而非文件。
1-1.r：控制，读文件内容，的权限：cp、cat more less emacs vi
1-2.w：控制，编辑文件内容，的权限:emacs vi
1-3.x：控制，执行文件内容，的权限：./
--备注：
1.需要特别关注cp操作，复制权限受文件的r控制
2.x权限类似于windows下面具有.exe扩展名的文件，只不过linux下面不是以后缀来区分文件类型的，该权限表明该文件是否可以被系统执行。

**** 权限对目录的意义：
1.值得注意的是，目录的原子组成是文件以及子目录，对目录的操作有：进入目录（x），浏览目录（r），在目录下创建、删除、复制、移动、重命名，文件或子目录（w），
一定要记得目录的操作的对象是目录下的文件或子目录。
1-1.r：控制，浏览该目录，的权限：ls
1-2.w：控制，在目录下创建、删除、移动、重命名，文件或子目录，的权限：touch、rm、mv
1-3.x：控制，进入该目录，的权限：cd
--备注：
--对于目录来说，执行权限是放在第一位的，可以说，没有x权限，只有x、w权限是没有什么意义的：连门（目录）都不给人家进(x)，谈什么交流（rw）；
--对于目录来说，有了x权限，一般情况下都会给r权限：给人家进门了（x），肯定就是默许他参观你的家了(r)，但是不一定允许他乱动你家里的东西(w)；
--需要特别关注rm操作，删除权限受目录的w控制。

**** 文件和目录的默认权限
1.文件和目录权限的形态：
--数字形态：umask   --->  0022
--符号形态：unmask -S  --->  u=rwx,g=rx,o=rx
备注：数字形态有四位数字,最高位代表特殊权限,不用管,次高位依次往后代表：用户,用户组,其它人的权限

2.数字形态的含义:
	需要减掉的权限;如0022的含义是,针对用户组和其他人,需要拿走他的写权限,转换为符号形态即: u=rwx,g=rx,o=rx

3.文件和目录的默认权限:
	在默认权限上,文件与目录是不一样的,文件一般不会有执行权限,而执行权限对于目录来说那就十分重要了,所以有如下约定
默认文件权限:最大666,即rw-rw-rw-
默认目录权限:最大777,即rwxrwxrwx

4.更改默认权限: unmask xxx 
实例1: unmask 0022
--文件被更改了什么:用户组和其他人在默认文件权限(rw-rw-rw)的基础上,被拿掉了写权限,所以,新建文件的文件权限应当是:rw-r--r--
--目录被更改了什么:用户组和其他人在默认目录权限(rwxrwxrwx)的基础上,被拿掉了写权限,所以,新建目录目录权限应当是:rwxr-xr-x

实例2:unmask 0077
--文件被更改了什么:用户组和其他人在默认文件权限(rw-rw-rw)的基础上,被拿掉了全部权限,所以,新建文件的文件权限应当是:rw-------
--目录被更改了什么:用户组和其他人在默认目录权限(rwxrwxrwx)的基础上,被拿掉了全部权限,所以,新建目录目录权限应当是:rwx------

备注:更改后的默认权限只在当前shell下有效,重新开启shell后就失效了,

2.探讨文件和目录默认权限之间的区别：
2-1.执行umask 0022,即，默认情况下将用户组和其它人的写权限拿掉：755
2-2.新建一个文件，并查看其权限为：644
2-3.新建一个目录，并查看其权限为：755
----
2-4.执行umask 0002,即，默认情况下将其它人的写权限拿掉：775
2-5.新建一个文件，并查看其权限为：664
2-6.新建一个目录，并查看其权限为：775
结论:上面的操作中，对用户组的写权限进行测试，拿掉用户组的默认写权限后，创建的文件和目录，其用户组都不再具备写权限

3.更改默认权限：
umask 数字形态权限
例如:

4.修改权限
				-rw-r-xr-x www www 0 Jun 1 21:57 test 
1:使用8进制：chmod 754 test  --> -rw-r-xr-- www www 0 Jun 1 21:57 test 
2:使用符号：
2-1.chmod o-x test  --> -rw-r-xr-- www www 0 Jun 1 21:57 test 
2-2.chmod u+x test -->-rwxr-xr-x www www 0 Jun 1 21:57 test 
2-3.chmod u=rwx,g=rx,o=- test -rwxr-x--- www www 0 Jun 1 21:57 test 
2-4.chmod a=rx test -r-xr-xr-x www www 0 Jun 1 21:57 test

--文件和目录的隐藏属性
     去在Linux中，所有的东西都被处理成文件，所以，在Linux中文件的安全性是及其重要的，所以，在权限的基础之上
还有两个十分重要的命令用于加强文件的安全性。
1.chattr [-+=]参数 文件或目录
其中:-删除某一特殊参数，其它参数保持不变；
	+增加某一特殊参数，其它参数保持不变；
	=仅有后面的参数
参数：a：这个文件只能增加数据，不能删除、修改数据；（适合log文件使用）
	 i：该文件不可以被删除，写入数据，重命名等； 
备注：这两个参数威力巨大，只有root才能进行设置，设置完毕后，连root都不能删除文件，必须解除设置才行。

2.设置隐藏属性：chattr +i xxx ；
3.解除隐藏属性：chattr -i xxx ；
4.显示文件的隐藏属性：lsattr [-adR] 文件或目录
参数：a：将隐藏文件的属性显示出来
	 d：如果是目录，仅显示目录
	 R：连同子目录也一起列出来

--特殊权限
1.SUID：待续
2.SGID：待续
3.SBIT：待续

--更改文件所有者及文件所属用户组
--条件：
1.xxx必须存在于/etc/passwd中才行
1.只有root才有权限执行该操作

--命令：
chown -R xxx:yyy file/directory
1. -R参数表示进行递归的持续更改，一般情况下都会带-R参数
2. xxx指代更改后得用户，yyy指代更改后得用户组

--命令变形：
1.只更改文件所属用户：chown -R xxx file/directory
2.只更改文件所属用户组：chown -R :yyy file/directory 
--备注：上面得命令中的 ：也可以用 . 替代，不过还是用 ：好
其实更改文件所属用户组有单独的命令，chgrp -R xxx file/directory，不过我还是习惯用上面的chown
Blog creation time:[2017-09-04 一 22:27]
**** 文件和目录的隐藏属性
	 - State "DONE"       from ""           [2017-09-05 二 10:07]
     去在Linux中，所有的东西都被处理成文件，所以，在Linux中文件的安全性是及其重要的，所以，在权限的基础之上
还有两个十分重要的命令用于加强文件的安全性。
1.chattr [-+=]参数 文件或目录
其中:-删除某一特殊参数，其它参数保持不变；
	+增加某一特殊参数，其它参数保持不变；
	=仅有后面的参数
参数：a：这个文件只能增加数据，不能删除、修改数据；（适合log文件使用）
	 i：该文件不可以被删除，写入数据，重命名等； 
备注：这两个参数威力巨大，只有root才能进行设置，设置完毕后，连root都不能删除文件，必须解除设置才行。

2.设置隐藏属性：chattr +i xxx ；
3.解除隐藏属性：chattr -i xxx ；
4.显示文件的隐藏属性：lsattr [-adR] 文件或目录
参数：a：将隐藏文件的属性显示出来
	 d：如果是目录，仅显示目录
	 R：连同子目录也一起列出来
*** 绝对路径：
1.定义：从根目录开始写起的路径
1.特点：路径较长，但是准确性较高，建议在写shellscript时使用绝对路径
*** 相对路径：
1.定义：从当前目录开使，以 . 或者 .. 来定位某一目录定义出来的路径
1.特点：路径较短
Blog creation time:[2017-09-04 一 22:28]
** DONE [#D] theme:认识shell								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:42]
*** 关系链：
硬件（硬盘，CPU，网卡，显卡等） 
<--> 
操作系统内核（CPU进程，内存管理，I/O资源管理） 
<--> 
接口（Shell，X Window） 
<--> 
运用程序
*** shell初体验：
--基本概念：每一个用户账号，在其用户配置文件：/etc/passwd中，都为其分配了默认shell，当用户登陆时，就能取得这个shell进行工作
1./bin/sh：最早出现的shell，叫做Bourne Shell，简称sh
2./bin/bash：目前的标准shell，简称bash
3./bin/csh：语法类似C语言，称C shell，简称csh
备注：shell是用户与linux系统内核交互的接口，而bash总是被作为标准shell安装；

特别地，有一种shell叫做：/usr/sbin/nologin，这个shell正如其名字，如果一个用户的配置文件中的shell指明为/sbin/nologin，那么
就表示该用户无法登陆系统取得shell，该用户相当于被锁定

--查看shell版本号:/bin/bash --version

--查看系统有哪些shell: less /etc/shells

--切换shell:

--退出shell: exit 
*** 用户登陆流程
1.使用useradd xxx添加一个用户，则系统会在/etc/passwd以及/etc/shadow中注册该用户的信息，包括用户名，密码，值得说明的是还分配了一个登陆shell给该用户。
2.输入用户名，密码，登陆系统成功后，该用户会取得在/etc/passwd里面设定的默认shell；
3.取得shell后，这个shell就是一个独立的进程，接下来在这个shell里面所执行的任何命令就称为shell的子进程；
	比如：用户www在/etc/passwd里面设定的默认shell为/bin/bash,当www输入密码登陆系统后，
就会取得一个叫做bash的shell，这个bash就是一个独立的进程。此时，我们输入命令gnome-terminal打开了另一个bash，
那么新打开的这个bash称为用户默认bash的子进程，这个用户默认的bash称为父进程
4.只有在该子进程bash结束掉后，才能回到原来的父进程bash
5.父进程bash，产生子进程bash后，这个子进程会继承父进程的所有环境变量，而父进程的用户自定义变量则无法继承过来
小结：从登陆流程的分析，不难看出，如果将用户自定义变量转变为环境变量，那么，就可以在子进程中随意使用这些个用户定义的变量了。下面有具体的方法。
Blog creation time:[2017-09-04 一 22:29]
** DONE [#D] theme:变量										   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:42]
*** 认识变量
1.变量有两种类型：环境变量（系统默认变量）；用户自定义变量；
2.环境变量能够被子进程继承引用，因此，可以将环境理解为全局变量；
3.用户自定义变量只能在当前进程中使用，子进程不能继承引用，因此，可以将用户自定义变量理解为局部变量；
4.从硬件的角度理解用户自定义变量和环境变量：
4-1.当启动一个shell时，操作系统分配一块内存给shell，存储在该内存的变量可以被子进程访问到；
4-2.只有环境变量才会被存储到这一内存上，用户自定义的变量不可以；
4-3.使用export命令就可以实现将用户自定义的变量写到这块内存上，所以其子进程就能访问到了；
5.查看系统中所有变量：set >set-info.txt
6.查看系统中的所有环境变量：env >env-info.txt
7.自定义变量转换为环境变量：export
8.环境变量转换为用户自定义变量：declare；

9.事实上，declare是声明变量类型的关键字，可以通过它来指定变量的类型
10.在bash中，默认情况下，变量的类型为字符串
11.在bash中，变量只能指定为字符串类型，整型，常量类型，数组类型；
12.在bash中，变量的作用域有局部和全局两种，局部变量称为用户自定义变量，全局变量称为环境变量；
13.键盘输入：read ---printf
14.输出打印：echo “${a},$(pwd),lin”
*** 变量的规范
1.正确：
1-1:var1=12------>12
1-2:myname="lin jia jun"----->lin jia jun
1-3:var2="lang is $LANG"----->lang is zh_CN.UTF-8
1-4:var3='path is $PATH'----->path is $PATH
1-5:var4="you need pay for \$20"----> you need pay for $20
1-6:PATH="$PATH":/home/bin  export PATH
1-7:通常大写字母为系统变量，小写字母为用户自定义变量
1-8:取消变量：unset myname
1-9:单引号与双引号的区别：
--单引号：1-4所示，内容仅作为纯文本
--双引号：1-5所示，试图解释变量
--不带引号：其内容不能有空格，如paths=/home/ljj
--带引号：其内容需要空格,如myname="lin jia jun"
1-10:花括号与括号的区别：
--花括号：myname="lin jia jun" --- echo ${paths} --- /home/ljj
--括号：pwd=/home/ljj paths="$(pwd)" --- echo ${paths} --- /home/ljj
--结论：${变量}   $(命令),注意，pwd是命令，但是PATH是变量
--建议：为避免混乱，定义变量一律采用：变量="内容的形式",显示一律采用：echo ${变量}的形式

2.错误：
2-1:var1 = 12,等号两边有空格
2-2:var2=lin jia jun,等号右边有空格
2-3:4var=12,数字开头
*** 自定义变量
1.定义，用户自定义变量：a="b c d"  ; lin="$(pwd):lin jia jun"
2.显示，用户自定义变量：echo ${a}  ; echo $(pwd)
3.销毁，用户自定义变量：unset a    ; unset lin
Blog creation time:[2017-09-04 一 22:30]
** DONE [#D] theme:环境变量									   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:42]
*** 认识环境变量：
1.环境变量是特殊的可以理解为全局变量，在子进程和父进程中都能使用；
2.环境变量一定是大写；
3.为了安全起见，不建议将当前目录.加入到环境变量PATH中去；
4.不同身份的用户，默认的PATH是不同的；
2.自定义变量转换为环境变量：export
3.环境变量转换为用户自定义变量：declare
*** 常见的环境变量
1.PATH：该环境变量给出的是执行文件的查找路径；
2.HOME：该环境变量给出用户的家目录路径:/home/ljj
3.LANG：该环境变量给出当前系统的默认语系，如：en_US.UTF-8或者zh_CN.UTF-8或者zh_CN.gb2312
4.SHELL：该环境变量给出当前系统使用的shell，如/bin/bash
5.MAIL：该环境变量给出当我们使用mail命令去收信时，系统会去该路径下读取邮件信箱文件，如/var/spool/mail/ljj
6.HISTSIZE：该环境变量给出系统记录我们执行过命令的条数，默认是1000条
7.RANDOM:这是一个随机数变量，可以当成一个随机数生成器，默认随机范围在（0~32767），也就是/dev/random这个文件。
备注：如果想使用随机数生成器，生成一个任意范围内的数，如（0~9），则可以作如下转换：
--declare -i number=${RANDOM}*10/32768
--显然，可以些一个shell scrip包含该语句，每次执行就能它，就能产生(0~9)范围内的随机数
8.$:当前shell的PID；
9.?:上一条执行命令的回传码，0表示执行成功；
10.PS1:命令提示符，默认PS1='[\u@\h \W]\$ ';
10-1.\d：以“星期月日”的格式显示日期；
10-2.\H：完整主机名
10-3.\h：仅主机名第一个小数点之前的名字
10-4.\T：显示时间，12小时格式
10-5.\t：显示时间，24小时格式
10-6.\u：显示用户名
10-7.\v：显示shell版本
10-8.\w：完整的当前工作目录名称
10-9.\W：当前工作目录最后一个目录的名称
10-10.\＃：执行的第几个命令
10-11.\$:提示符，如果是root时，提示符为＃，否则为$
备注：我的PS1:PS1='<\u@\# \t \w>\$ '
11.OSTYPE:操作系统位数
12.pwd:显示当前路径
*** PATH环境变量的规范：
3-1.例：/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:\
       /home/ljj/.local/bin:/home/ljj/bin
3-2.采用 ：来分隔，与windows里面的 ；作用一样
3-3.在查找命令时，是按照PATH给的路径的顺序来查找，在哪个路径先找到，就先执行哪个路径下的命令
3-4.不同的用户，默认的PATH不同，默认能够随意执行的命令也不同
3-5.当前目录./不要放置到环境变量中去
*** 添加环境变量
1. 将gcc-arm-none-eabi添加进环境变量:
   export PATH="$PATH:$HOME/usr/local/bin:$HOME/stm32/arm-none-eabi-gcc/gcc-arm-none-eabi-5_4-2016q3/bin"
2. 临时添加环境变量： PATH＝"${PATH}":home/ljj   export PATH
3. 永久添加环境变量: emacs /etc/environment
追加：
/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/home/ljj/.local/bin:/home/ljj/bin
:/home/ljj
*** 将用户自定义变量转换为环境变量
1.方法一：export xxx（其中xxx是一个用户定义的变量）
2.方法二：declare -x xxx （其中xxx是一个用户定义的变量）
*** 将环境变量转换为用户自定义变量
--declare +x xxx （其中xxx是一个环境变量）
*** 语系变量
1.Linux默认支持多国的语言，不同的语言有不同的语系，采用a语系书写的文档，采用b语系查看会出现乱码
2.查看所有语系：locale -a，这些语系存放在/usr/lib/locale目录下面
备注：不要与文件查找命令locate xxx 混淆
3.查看当前语系：locale 
4.语系的设置：
原则上，设置语系，就需要逐一的设置使用locale命令所罗列出来的语系变量，但事实上，如果你设置了
LC_ALL和LANG，其它语系都没有设置，那么，其它语系都会被这两个变量所替代。如：
LC_ALL=en_US.UTF-8;LANG=en_US.UTF-8;export LANG；export LC_ALL 
5.整体系统默认的语系定义：/etc/sysconfig/i18n
*** 键盘读取变量：read
1.意义：
1-1.键盘读取变量read的值，由用户从键盘输入给于赋值；
1-2.其重要价值在于能与用户进行交互；
1-3.该变量多用于shell script中；
1-4.read相当于c中的scanf，echo相当于c中的printf；

2.命令：read -p “Please input you name: ” -t 30 named
备注:-p指定后面接提示语句;-t指定超时时间为30s
*** 声明变量的类型：declare
1.意义：
1-1.在bash中，默认情况下，变量的类型为字符串，所以num=300+100,当echo ${num}时，结果是300+100 
1-2.declare可以声明变量的类型以适应不同场合，如：declare -i num=300+100,当echo ${num}时，结果是400

2.命令：
2-0.查看变量的类型：declare -p num 
2-1.定义局部字符串类型变量：declare num=300+100  --- num=300+100 
2-2.定义局部整型变量：declare -i num=300+100    --- num=400 
2-3.定义全局变量(环境变量）：declare -xi num=300+100 --- num=400(全局有效)
2-4.定义局部常量：declare -r num="lin jia jun" （类似于c的const变量，不可更改，不可重设）
备注：常量又叫只读变量，如果你将一个变量声明为只读，那么，只能注销再登陆才能复原该变量的类型了
2-5.定义数组：
2-1.定义：arry[1]="hello"  arry[2]="world"
2-2.打印：echo “${var[1]},${var[2]}” 
2-6.将环境变量转换为用户自定义变量：declare +x sum
*** 资源限制
1.背景：
Linux是多用户操作系统，它允许多个用户同时使用这台计算机，但是存在下面所述的问题：
假设某Linux主机有10个用户，这10个用户同时打开了100个文件，这些文件每个大约有10M，显然，该主机
需要提供10G的内存才行，这显然是不现实的，所以，我们需要对主机的某些资源，如打开文件的数量个，可以
使用的CPU时间，可以使用的内存总量的做出限制。

2.查看当前用户的资源限制情况：ulimit -a

3.限制可创建单一文件的大小：ulimit -f 10240  （默认单位是KB）  限制--10M
备注：
--想要复原ulimit限制最简单的办法就是注销再登陆
Blog creation time:[2017-09-04 一 22:31]
** DONE [#D] theme:shell的环境配置文件						   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:42]
*** bash的环境配置文件介绍：
1.为什么我们刚进入bash就有一堆有用的变量，如pwd，PATH，HOME等？显然，
系统有一些环境配置文件存在，用于规划bash的操作环境；
2.系统的环境配置文件分为全体系统配置文件以及用户个人偏好配置文件；
3.只有写入配置文件中的变量或者环境变量才能永久有效，在当前会话配置的只对本次会话有效，注销重启后配置消失；

*** login shell 与 non-login shell：
1.login shell：取得bash需要完整的登陆流程的（输入账号和密码），称为login shell；
2.non-login shell：取得bash不需要重复登陆，如进入x window界面时输入一次账号和密码，在x window
下面进入bash终端时，不再需要账号和密码，就称，此时的shell为non-login shell；
3.login shell 与 non-login shell取得bash过程中，读取配置文件数据不一致。

*** 配置文件的分类：
**** 从全局和用户个人的角度：
1.系统全局配置文件：/etc/profile  (不可轻易修改)

2.用户个人配置文件：~/.bash_profile或~/.bash_login或~/.profile
备注：之所以会有这么三个文件，是为了照顾从其它shell转换过来的用户，实际系统中只会有一个存在，
bash也只会按照上面的顺序找一个来读取，先找到谁读取谁，我的Linux给出的是~/.bash_profile

**** 从 login shell 与 non-login shell的角度
1.取得login shell后读取的配置文件：
1-1. /etc/profile 
1-2. ~/.bash_profile或~/.bash_login或~/.profile
备注：3-2的三个配置文件我用了或，事实上，bash的login shell只会读取上面三个配置文件中的一个，并且，
读取规则如下：首先查找~/.bash_profile是否存在，存在则读取，且不再去管~/.bash_login或~/.profile
如果不存在~/.bash_profile，接着查找~/.bash_login，若存在则读取，不管~/.profile，若不存在，接着查找
~/.profile。

2.取得non-login shell后读取的配置文件：
2-1.~/.bashrc 
2-2./etc/bashrc
2-3./etc/profile.d/*.sh
备注：non-login shell调用2-1,2-1调用2-2,2-2调用2-3
*** 详解/etc/profile：
1.文件简介：
1-1.该文件是全体系统配置文件；
1-2.该文件不建议轻易修改；
1-3.该文件只会被login shell读取；
1-4.每个用户取得bash后必须去读取该文件；
1-5.该文件除了设置一些环境变量的逻辑之外，还调用其它外部文件。

2.涉及的文件及文件内容：
2-1./etc/profile：bash会去读取的文件；
2-2./etc/inputrc：
--/etc/profile主动判断用户有没有自定义输入按键的行为，决定是否设置INPUTRC这个环境变量；
--该文件内容为bash的热键,[TAB]有无声音等数据，一般用户不用再去配置它；
2-3./etc/profile.d/*.sh：
--在profile.d目录下后缀为sh的且具有r属性的文件都会被/etc/profile调用；
--在profile.d目录下后缀为sh的这些文件规定了bash接口的颜色，语系，命令的别名等；
2-4./etc/sysconfig/i18n：
--这个文件由/etc/profile.d/lang.sh调用；
--该文件决定了bash默认使用的语系，文件里面有LANG这个重要的环境变量；

3.完成工作：
3-1.内部处理路径PATH；
3-2.内部处理默认权限；
3-3.内部处理环境变量：USER、MAIL、HOSTNAME、HISTSIZE；
3-4.外部调用文件:/etc/inputrc   （自动判断是否调用）
3-5.外部调用文件:/etc/profile.d/*.sh  (在profile.d目录下后缀为.sh且具有r权限的文件会被/etc/profile调用) 
3-6.外部调用文件：/etc/sysconfig/i18n  (由profile.d目录下的lang.sh调用) 
*** 详解~/.bash_profile
1.文件简介：
1-1.该文件是用户个人的配置文件，每个用户都有一个；
1-2.该文件只会被login shell读取；
1-3.每个用户取得bash首先读取/etc/profile，然后再读取各自的~/.bash_profile文件；
1-4.该文件会去判断~/.bashrc是否存在，若存在则调用；

2.文件内容：
2-1.判断~/.bashrc是否存在，存在则读取该文件的设置。
2-2.设置PATH这个变量。由于在/etc/profile里面已经设置过，所以，这里的设置会以累加的方式载入；
备注：该文件下的PATH变量在设置完毕后还用export将PATH变量转换为环境变量，所以，一些第三方软件
的可执行文件的路径可以添加到这来，之后随便在哪个地方都可以执行。

3.详解~/.bashrc  （non-login shell会读取的文件）
3-1.该文件是由~/.bash_profile调用；
3-2.该文件还调用了/etc/bashrc;
3-3.该文件还会被non-login shell读取；
3-4.该文件做了两件事：第一，调用/etc/bashrc；第二，配置别名
备注；需要特别注意的是，配置别名的工作主要是在root的~/.bashrc下面进行的，一般用户的~/.bashrc配置的别名是不起作用
3-5./etc/bashrc详解：
3-5-1.依据不同的UID规定了unmask的值；
3-5-2.依据不同的UID规定了PS1的值；
3-5-3.调用/etc/profile.d/*.sh文件；
*** bash配置文件的读入指令source
1.我们要修改bash配置文件的步骤应该是这样的，首先登陆系统取得login shell，然后，修改上面所述的配置文件；
2.由于/etc/profile和~/.bash_profile都是在用户取得login shell后才读取的，所以，这次的修改
当前的login shell是加载不到的，所以得注销后重新登陆，取得login shell；
3.基于上面得解释，我们可能希望当前修改了bash得配置文件，不用注销重新登陆就能生效，那就使用source命令；
4.source命令：source 配置文件名，例如：source ~/.bash_profile；
备注：也可以用：小数点 配置文件，的方式来替代source命令，如：. ~/.bash_profile;
*** 其它相关配置文件
1./etc/man_db.config:该文件里面有一个MANPATH变量，该变量可以指定man指令的查找路径；
2.~/.bash_history：记录该用户上次登陆bash时操作的命令
3.~/bash_logout：可以写一写脚本，要求bash离开后为我们做一些扫尾的工作
Blog creation time:[2017-09-04 一 22:32]
** DONE [#D] theme:通配符与特殊符号							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:43]
*** 常见的通配符
1.*:代表0到无穷多的任意字符
2.?:代表一定有一个字符
3.[]:代表一定有一个在中括号内所列出的字符
4.[-]:代表编码顺序范围内的所有字符
5.[^]:代表除了中括号内给出的字符外，只要存在就接受

*** 常见的通配符运用实例


*** 常见的特殊符号
Blog creation time:[2017-09-04 一 22:32]
** DONE [#D] theme:管道										   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:43]
1:管道操作符：| 可以使用管道操作符来连接进程
2:在linux下，通过管道连接的进程可以同时运行，可以自动协调
3:假设需要打开一个目录并预览：
	正常操作：cd home   ls -al
	使用管道：cd | ls -al home >/home/ljj/info
	备注1：使用cd | ls /home时，会将home目录下面的文件显示在标准输出，但是当前目录不会跳转到home目录去
	例如：ps -xo comm | sort | uniq | grep -v sh | more
	备注2:不要在命令流中使用相同的文件名
	例如：cat mydata.txt | sort | uniq > mydata.txt,将得到一个空文件，原因是在管道操作中，| 连接的进程在得到最终结果之前是同时执行的， >操作符在得到结果之前先覆盖了mydata.txt
4:管道能连接的进程数目没有限制
Blog creation time:[2017-09-04 一 22:33]
** DONE [#D] theme:重定向									   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:43]
1.重定向的对象是标准文件描述符，用0代表标准输入，1代表标准输出，2代表标准错误输出；
    默认情况下不加文件描述符的话就代表对标准输出进行重定向
2.文件描述符都很多，一般情况下，对0,1,2以外的文件描述符重定向是很少见的；
3.输出重定向操作符：
3-1: > 该操作符默认以新建或覆盖的方式将标准输出重定向到一个文件
3-2: >> 该操作符默认以新建或追加的方式将标准输出重定向到一个文件
4.标准输出重定向：ls -al -1 > /home/ljj/info.txt   ls -1 >> /home/ljj/info.txt
5.标准输入重定向：more < /home/ljj/info.txt 标准输入重定向意义不大
6.标准错误重定向：cd /rot >/home/ljj/out.txt 2>/home/ljj/err.txt
Blog creation time:[2017-09-04 一 22:34]
** WAITTING [#D] theme:shell-scripts						   :@Blog:@Linux:
   - State "WAITTING"   from "DONE"       [2017-10-29 日 20:22]
*** 从键盘读取
--read -p -t
Blog creation time:[2017-09-04 一 22:35]
** DONE [#D] theme:打包、压缩、解压							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:43]
*** 压缩：
计算机中的最小单位是bit，实际使用时，最小单位是byte，这个byte总是由8个bit的0和1的形态来构成，显然
这8个bit应该是0和1的排列，通过一些算法，可以将一些重复的1简单记录，比如有100个1,就简单记录100个1
而不是真的有100个1的bit存在；也可以将一些连续的0"丢出来",并将丢出的个数记录在案以备解压，这些被“丢出来的位”
可以用于存储其它数据，这样就可以节省大量的空间。

*** 解压：
压缩后的文件是没有办法直接使用的，因此，根据记录，还原压缩前的文件的过程就称为解压
*** 压缩文件的扩展名：
1.理论上，扩展名在Linux中是不能反映文件的属性的，但是，由于支持压缩的命令非常多，不同的压缩命令所采用的
技术是不一样的，因此彼此间是没有办法兼容的，所以，压缩文件都会提供后缀进行标式，来提示你，应当采用哪种
压缩命令。
2.常见的压缩文件扩展名：
--*.tar*：tar程序打包的数据，并且没有压缩过
--*.gz：gzip程序压缩的文件
--*.bz2:bzip2程序压缩的文件
--*.tar.gz：tar程序打包的数据，并且经过gzip程序压缩的文件
--*.tar.bz2：tar程序打包的数据，并且经过bzip2程序压缩的文件
--*.Z：compress程序压缩的文件 （古老的压缩方法，不再流行，且gzip能解开该类型的压缩文件，不必再关注）
备注：gzip和bzip2是两个压缩程序，这两个压缩程序都只能针对单一的文件进行压缩很烦人，所以就需要tar
这个打包程序，tar能够把很多文件甚至目录给打包在一起，不过tar只能打包不能压缩，所以.tar.gz以及.tar.bzip2
就是结合了二者。

*** tar详解：
1.说明：
--将多个目录或文件打包成一个大文件,不包含压缩功能；
--该命令可以结合gzip或者bzip2程序在打包的同时还进行压缩；
--该命令如此强大，以至于windows上的WinRAR也支持它； 

2.命令：
2-1.tar打包：
--创建打包文件：tar -cvp -f /tmp/c.tar ~/a.txt ~/b.txt
--查看打包文件：tar -tv -f /tmp/c.tar
--解压打包文件：tar -xv -f /tmp/c.tar -C ~/ 

2-2.gzip与bzip2压缩与解压：
--由于这两个命令只能针对单一文件进行压缩与解压，单独使用意义不大，不做单独介绍

2-3.tar打包gzip压缩与解压:  -z
--创建打包压缩文件：tar -czvp -f /tmp/c.tar.gz ~/a.txt ~/b.txt
--查看打包压缩文件：tar -tzv -f /tmp/c.tar.gz
--解压打包压缩文件：tar -xzv -f /tmp/c.tar.gz -C ~/

2-4.tar打包bzip2压缩与解压：
--创建打包压缩文件：tar -cjvp -f /tmp/c.tar.bz2 ~/a.txt ~/b.txt
--查看打包压缩文件：tar -tjv -f /tmp/c.tar.bz2
--解压打包压缩文件：tar -xjv -f /tmp/c.tar.bz2 -C ~/

Blog creation time:[2017-09-04 一 22:35]
** DONE [#D] theme:我的工具收藏								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:43]
1.w:显示谁登陆了系统并做了哪些事，w -h ljj,只关注ljj做了哪些事
2.nmon
3.ncdu:用于分析各个目录所占磁盘的空间
4.dstat:用于监控内存，进程，网络和磁盘性能
5.saidar
Blog creation time:[2017-09-04 一 22:36]
** DONE [#D] theme:安装搜狗输入法							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
--在新出的Ubuntu 16.04上安装sogou输入法的时候，碰到了一些问题，
主要还是依赖包没有正确安装，下面介绍正确的安装步骤；
--在sougou的官网上下载linux版本的安装包
--sudo apt install libopencc1 fcitx-libs fcitx-libs-qt fonts-droid-fallback 
--sudo dpkg -i sogoupinyin_2.0.0.0078_amd64.deb
--安装细胞词库：在官网上下载好词库（.scel）,复制到/home/ljj/.config/SogouPY/scd下面
--勾选安装的细胞词库
--小结：安装依赖需要一次安装完成，切勿单个安装，主要是由于包之间彼此会有一定的依赖关系，这个是你无法准确定位的，
故在 一次安装动作中做完；
Blog creation time:[2017-09-05 二 08:09]
** WAITTING [#C] theme: 安装 google 输入法
https://jingyan.baidu.com/article/eae0782743419c1fed548548.html
** DONE [#D] theme:安装apt源								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]

Blog creation time:[2017-09-05 二 08:10]
** DONE [#D] theme:版本与系统升级							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
apt-get clean 
apt-get update && apt-get upgrade -y && apt-get dist-upgrade -y

内核升级: apt-get install linux-header-${uname -r}
Blog creation time:[2017-09-05 二 08:11]
** DONE [#D] theme:安装有道词典								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
--http://cidian.youdao.com/index-linux.html
--注意，一定要下载deep版本的才行，ubuntu的不行
--第一次安装可能会提示缺少依赖包，输入：sudo apt-get -f install重新配置一下依赖关系
--sudo dpkg -i youdao-dict_1.1.0-0-deepin_amd64.deb 安装
--运行有道：youdao-dict
Blog creation time:[2017-09-05 二 08:12]
** DONE [#D] theme:安装网易云音乐							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
--网易云安装包：http://music.163.com/#/download
--将源换成阿里源；
--重新配置一下依赖关系：sudo apt-get -f install
--安装：sudo dpkg -i netease-cloud-music_1.0.0-2_amd64_ubuntu16.04.deb
--启动：netease-cloud-music
Blog creation time:[2017-09-05 二 08:27]
** DONE [#D] theme:安装QQ									   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:28]
*** kali安装qq
使用的是longene TM2013
下载地址（百度云）：http://pan.baidu.com/s/1dFx8azv
安装：
64位的需要安装32位依赖文件
用这条命令
apt-get install libgtk2.0-0:i386
32位的直接安装就可以了
dpkg -i WineTM2013-20131206-Longene.deb

目前已知的bug：
1.无法用物理键盘输入密码，所以只能用软件盘
2.ibus输入法和wineqq2013有冲突—-（没有测试过）

主要参考了两篇内容
Kali-linux下安装使用QQ：
http://xiao106347.blog.163.com/blog/static/215992078201311512333509/
wine qq 2013 for linux Ubuntu 64位兼容：
http://www.longene.org/forum/viewtopic.php?f=6&t=4700
Blog creation time:[2017-09-05 二 08:28]
** DONE [#D] theme:安装flash插件							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
*** kali安装flash插件
步骤一：
   下载：https://get.adobe.com/flashplayer/
备注:下载的格式为：.tar.gz for linux,下载结果得到：flash_player_npapi_linux.x86_64.tar.gz 

步骤二：
   解压：tar -xzvf flash_player_npapi_linux.x86_64.tar.gz 

步骤三：
   拷贝动态链接库至浏览器所在目录:sudo cp libflashplayer.so /usr/lib/mozilla/plugins/

步骤四：
   修改执行权限：chmod 775 libflashplayer.so
备注；这一步很重要，当时在调试事就是忘记了这一步，结果死活没用

步骤五：重启linux
备注：一定要重启或注销，否则没用

步骤六：测试，在浏览器上打开一个视频
Blog creation time:[2017-09-05 二 08:29]
** DONE [#D] theme:安装lantern								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
下载： 
--deb:https://github.com/getlantern/lantern
--github:git clone https://github.com/getlantern/lantern.git
备注：推荐使用第二种源码包，因为这里是lanten项目在github上托管的源码，这里下载的源码一定是最新的

kali安装：
--cd lantern
--make lantern
./lantern

debian安装：
--下载最新版本的.deb，ubuntu14.04
--sudo dpkg -i xxx.deb
--运行:lantern
--出错，解决方案如下所示

排错：
运行时如果提示/.lantern/bin/lantern: error while loading shared libraries: libappindicator3.so.1: cannot open shared object file: No such file or directory 。
则需要安装一个库：apt-get install libappindicator3-1。还可以配合Tor使用。
Blog creation time:[2017-09-05 二 08:30]
** DONE [#D] theme:安装google浏览器							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
--首先需要安装蓝灯能翻墙到google的官网下载.deb安装包
--下载：http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html
--安装：
-->sudo dpkg -i google-chrome-stable_current_amd64.deb
-->解决依赖关系：sudo apt-get -f install
-->再次安装：sudo dpkg -i google-chrome-stable_current_amd64.deb
-->运行：google-chrome
--添加快捷图标
Blog creation time:[2017-09-05 二 08:32]
** DONE [#D] theme:安装ubuntu16.04							   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
1.使用系统自带的磁盘工具先对磁盘格式化或分区;
2.在分区时尤其需要注意，必须分出一个EFI的分区作为系统引导，500MB就好，否则后面会出错导致安装失败;
3.分区建议：500MB的efi,10GB的Swap,100GB的/，剩下的home,注意，不要在把boot分出去了，那是20年前为了兼容老版本的做法;
4.安装完毕后，修改BIOS为Lengency启动而不是UEFI启动，第一启动项为硬盘，重启
Blog creation time:[2017-09-05 二 09:01]
** DONE [#D] theme:将CAP键与CTRL键互换						   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
1.置换Ctrl键和Caps Lock: sudo vi /usr/share/X11/xkb/keycodes/evdev
2.CTRL + SUPER ...
Blog creation time:[2017-09-05 二 09:04]
** DONE [#D] theme:ubuntu源配置								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
--ubuntu16.04的源已经非常方便，在设置-软件更新下面有一个软件管理器，专门用来管理软件的下载；
--软件管理器下面：ubuntu软件选项，有一个源选择的下拉列表，可以选择下载源
--在软件管理器下面，有一个源代码的复选框，勾选上以后我们就可以从外部添加的源下载软件；
--在软件管理器下面，有一个其他软件选项，这里可以添加外部源的地址

1.首先到软件管理器下面看看是否有已经想要添加的源，有的话，直接切换一下就行；
2.在软件管理器下面查看下拉列表，若没有发现想要的源，可以在其他软件选项直接添加想要的源地址；
3.可以在命令行下面执行：sudo add-apt-repository xxx即可（xxx是源地址）
4.sudo apt update
Blog creation time:[2017-09-05 二 09:05]
** DONE [#D] theme:安装思维导图								   :@Blog:@Linux:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
1.下载包:http://www.xmind.net/download/linux/
2.解压包:unzip -d xmind xmind-8-update2-linux.zip
3.安装依赖文件:sudo ./setup.h
4.进入XMind_amd64,安装xmind思维导图:sudo ./XMind
Blog creation time:[2017-09-05 二 09:10]
** DONE Theme:一键安装常用软件								   :@Blog:@Linux:
	- State "DONE"       from "WAITTING"   [2017-09-07 四 10:49]
	主题的名字可能不是特别的恰当，这里，重新描述一下这篇博客所实现的功能。你可能积累了很多的
常用的软件，而每当你更换操作系统时，你不得不重新一个接着一个的去安装这些软件，显得特别的麻烦，
这里提供一个解决方案，可以轻松实现一键安装：
	首先：将你积累的这些软件全部下载下来（需要全部是.deb格式的）放到一个叫做apt_packs的目录下，
然后，修改/etc/apt/sources.list文件，在下面新增加一行：
deb		file:/xxx/apt_apcks/
	最后，使用命令更新一下软件源：sudo apt-get update就能一键安装apt-packs目录下的所有
软件了
Blog creation time:[2017-09-07 四 10:37]
** DONE [#D] theme:apt-get									   :@Blog:@Linux:
	- State "DONE"       from "DONE"       [2017-09-05 二 09:29]
	- State "DONE"       from "TODO"       [2017-09-05 二 09:29]
--查询某软件在系统中的基本信息：
dpkg -s xxx
(1)是否安装
(2)安装包大小
(3)32位还是64位
(4)版本号
(5)依赖
(6)配置文件

--查询当前apt-source下面，可供安装的指定软件xxx的信息（xxx必须是待安装软件在仓库中的真实名）
apt-cache show xxx
结果：列出源仓库中，软件xxx不同版本的基本信息

--查询当前apt-source下面,与可供安装的指定软件xxx相关的软件（xxx不必是准确的名）
apt-cache search xxx
结果：列出源仓库中，所有与xxx沾边的软件

--安装：
1)dpkg -i xxx.deb
2)apt-get -f install 
3)dpkg -i xxx.deb
备注：上面的这两个语句经常用来解决软件安装过程的存在的依赖关系，首先下载xxx.deb,然后使用dpkg -i xxx.deb
安装，此时，一般情况下会显示有依赖文件找不到，接着在使用apt-get -f install,系统就会去安装那些个找不到
依赖的文件，之后，再使用dpkg -i xxx.deb就能顺利完成xxx.deb的安装了

--删除：
apt-get autoremove --purge xxx
备注：删除，软件包+依赖软件包+配置文件

--更新：
apt-get update && apt-get upgrade && apt-get dist-upgrade
备注：更新源+更新已安装的软件+系统升级

--了解安装包的依赖关系
apt-cache depends xxx

--清理下载文件的存档 && 只清理过时的包
apt-get clean && apt-get autoclean

--检查是否有损坏的依赖
apt-get check

--查看系统中与xxx相关联的包
dpkg -l |grep -i xxx

--查询系统中已安装的软件xxx在系统中的所有路径
dpkg -L xxx

源码包安装
   apt-cache showsrc 查找看源码包的文件信息(在下载之前)
   apt-get source 下载源码包.
   apt-get build-dep +"包名" 构建源码包的编译环境.
Blog creation time:[2017-09-05 二 09:07]
