* blogs-emacs-active
** DONE [#D] Theme:emacs相关网站							   :@Blog:@Emacs:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:53]
1. Emacs 世界级大师 : Steve Purcell  http://www.sanityinc.com/
2. Emacs 官网 : www.gnu.org/software/emacs/
3. MELPA：http://melpa.org/#/
4. 陈斌 : https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org
5. 陈斌的配置 : https://github.com/redguardtoo/emacs.d
6. 国外的emacs视频：http://emacsrocks.com/
7. 大牛的配置：https://github.com/tuhdo/tuhdo.github.io
8. 子龙山人的配置: https://github.com/zilongshanren
9. 经典社区 : https://www.reddit.com/r/emacs/
10. 官方手册：https://www.gnu.org/software/emacs/manual/
11. 牛0的博客 : https://github.com/search?p=1&q=stars%3A%3E20+extension%3Ael+language%3Aelisp&ref=searchresults&type=Repositories
12. 牛1的博客 : http://planet.emacsen.org/
13. 牛2的博客 ： https://www.lunaryorn.com/posts/autoloads-in-emacs-lisp
14. 牛3的博客 ：http://ergoemacs.org/
15. 牛4的博客(超级棒)：https://tuhdo.github.io/
16. melpa镜像源：http://www.4gamers.cn/
17. emacs中国社区：https://github.com/emacs-china
18. 21天学会emacs: https://emacs-china.org/t/21-emacs/55
19. 入门elisp语法：https://learnxinyminutes.com/docs/elisp/
20. evil:https://www.emacswiki.org/emacs/Evil
Blog creation time:[2017-09-04 一 22:04]
** DONE [#D] Theme:spacemacs相关网站						   :@Blog:@Emacs:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:27]
1. 官网：http://spacemacs.org
2. github:https://github.com/syl20bnr/spacemacs
Blog creation time:[2017-09-05 二 08:46]
** DONE [#D] Theme:安装emacs								   :@Blog:@Emacs:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:53]
1. ubuntu16.04使用apt install emacs安装的emacs是emacs24,而我希望能使用emacs25,因为里面有一些高级的函数可以实现，所以采用下面的方式来安装emacs25.2
2. 首先安装核心依赖文件：
	1. sudo apt install build-essential
	2. sudo apt-get build-dep emacs24
	3. 备注:安装build-dep可能会出错，显示E：You must put some 'source' URIs in your source.list此时，我们需要到设置-->软件和更新下面勾选：源代码
3. 下载emacs25.2版本：sudo wget -P 下载/ http://ftp.gnu.org/gnu/emacs/emacs-25.2.tar.xz
4. 解压：由于下载包的格式为.tar.xz,所以:
	1. xz -d emacs-25.2.tar.xz
	2. tar -xvf emacs-25.2.tar
5. 切换到root，进入解压后的包，运行配置文件，且指定安装目录：./configure --prefix=/usr/local
6. 安装emacs：make && make install
7. 运行emacs
Blog creation time:[2017-09-04 一 22:05]
** DONE [#D] Theme:emacs启动流程							   :@Blog:@Emacs:
	- State "DONE"       from "WAITTING"   [2017-09-20 三 10:51]
	Link position:[[info:elisp.info.gz#Startup%20Summary][Operating System Interface (emacs lisp 38)]]
emacs在启动时，会执行下面的操作：
1. 执行subdirs.el文件，给load-path变量赋值
   1. Emacs在安装完成后，会自动生成一个叫做subdirs.el的文件
   2. 在emacs启动的时候，会去执行这个subdirs.el文件
   3. 该文件里的代码会将与emacs有关的文件路径(包括.emacs.d/*,/etc/emacs,/usr/local/share/..,/usr/share/emacs/..等等)，全部加载至load-path中
   4. 该步骤本质上是将emacs正常工作时可能加载到的文件的路径事先写进load-path这个变量中，在工作过程中用到相应的文件时，直接到load-path这个变量列表中提取该文件的绝对路径，就能找到该文件的物理位置并加载了
2. 遍历load-path变量，查找文件leim-list.el，并加载
   1. 该文件是为注册输入法而准备的
   2. 该搜索仅仅是针对你已经创建了的私有文件leim-list.el,因此，会略过standard Emacs libraries目录
   3. 该文件应该是唯一的，它会被编译进Emacs executable中去
   4. 系统保证emacs相关的配置文件(.elc，.el等等)，以及一些系统用到的库文件能被找到，而所做的一个操作，这就保证了
3. 设置时间
   1. 会将变量before-init-time的值设置成current-time
   2. 将after-init-time的值设置成nil,该操作会发信号给lisp programs，然后Emacs将会进行初始化
4. 设置语言环境和终端的编码系统
5. 解析命令行参数的基础语法
6. 初始化窗口系统
   1. 如果不是运行在batch模式，那么，变量initial-window-system的值将会用来初始化窗口系统
   2. 每一个被窗口系统所支持的初始化函数都是由window-system-initialization-alist来指定
   3. 如果initial-window-system的值是WINDOWSYSTEM,则，一个合适的初始化函数在term/WINDOWSYSTEM-win.el中定义
   4. 当进行build时，该文件会被编译进Emacs executable中去
7. 运行一个标准的钩子函数：before-init-hook
8. 创建graphical frame
   1. 如果条件满足，那么会创建一个graphical frame
   2. 如果指定了‘--batch’ or ‘--daemon’就不会创建
9. 初始化字体，菜单栏，工具栏
   1. 如果需要的话，会初始化frame的字体，设置菜单栏，工具栏
   2. 如果支持graphical frame的话，那么即使当前的frame不是一个graphical,也会设置一个工具栏，因为graphical frame在稍后也会被创建
10. 使用custom-reevaluate-setting来重新初始化列表成员custom-delayed-init-variables
11. 加载site-start这个库，如果指定了‘-Q’ or ‘--no-site-file’，该库不会被加载
12. 加载初始化文件init.el
	1. 如果指定了‘-q’, ‘-Q’, or ‘--batch’ ，则不会去加载
13. 加载default这个库
	1. 如果inhibit-default-init是non-nil,或者， ‘-q’, ‘-Q’,or ‘--batch’被指定，这个库就不会去加载
14. 从abbrev-file-name指定的路径加载abbrevs，如果指定了--batch就不会去加载
15. 调用函数：package-initialize来激活任何已经被安装了的package
	1. 当package-enable-at-startup是nil或者指定了选项 ‘-q’, ‘-Q’, or ‘--batch’时，Emacs不会去初始化package，package-initialize这个函数应当明确的被调用
16. 设置after-init-time的值为current-time
	1. 在第3步中，这个变量的值是被设置为nil的,设置该变量为current-time表明初始化已经完成
17. 运行一个标准的钩子函数：after-init-hook
18. 根据initial-major-mode来设置Fundamental mode为major mode
19. 加载terminal-specific Lisp library
	1. 如果开启了一个text terminal，将会加载 terminal-specific Lisp library,然后运行tty-setup-hook这个钩子函数
	2. 如果指定--batch或者term-file-prefix为nil将不会加载
20. 显示初始化过程中打印的区域信息
21. 处理命令行的选项部分
22. 如果指定了--batch，那启动过程到此为止
23. 如果scratch buffer存在，而且是空的，那么将会在该buffer里面插入(substitute-command-keys initial-scratch-message)
24. 解析initial-buffer-choice
	1. 如果initial-buffer-choice是一个字符串，那么会将这个字符串作为文件或者目录来访问
	2. 如果是一个函数，那么将会不传入参数的调用这个函数，并且将该函数的返回值作为选中的缓冲区
	3. 如果一个文件作为命令行参数的形式而给出，那么该文件将会被访问，并且该文件的buffer会显示在initial-buffer-choice里面
	4. 如果超过一个文件被给出，那么所有的文件都会被访问，然后*Buffer List*会被显示在initial-buffer-choice中
25. 运行钩子函数：emacs-startup-hook
26. 调用frame-notice-user-settings，该函数根据初始化文件所指出的内容来修改被选中的frame的参数
27. 运行钩子函数：window-setup-hook
	1. 该函数与emacs-startup-hook唯一的不同之处在于该函数在上面26条提及的对frame参数的修改之后才进行的调用
28. 运行startup screen
	1. 这是一个特殊的buffer，里面包含版权以及emacs的一些基础信息
	2. 如果，inhibit-startup-screen以及initial-buffer-choice设置为non-nil,或者如果‘--no-splash’ or ‘-Q’被指定，将不会去运行
29. 调用server-start
	1. 如果选项--daemon被指定，那么会调用server-start
30. 调用 emacs-session-restore 
	1. 如果开启了X会话管理，那么会调用该函数，并传递上一个会话的ID作为参数
31. 下面的一些选项会影响启动序列的一些方面：
	1. inhibit-startup-screen
	   1. non-nil: 抑制 startup screen ，在该情况下，Emacs会显示*scratch*缓冲区
	   2. inhibit-startup-message’ and ‘inhibit-splash-screen是这个变量的别名
    2. initial-buffer-choice
	   1. non-nil: 该变量是一个字符串，这个字符串指定了一个文件或者目录,这个文件里面所存放的是在Emacs启动之后所显示的内容(替代正常情况下的欢迎界面)
	   2. 函数：该变量的值可以是一个函数，emacs会调用这个函数，这个函数需要返回一个buffer，然后显示这个buffer里面的内容
	   3. t: 显示*scratch*缓冲区
    3. inhibit-startup-echo-area-message
	   1. 该变量控制startup echo area message的显示
	   2. 可以通过添加下面的配置来抑制startup echo area message的显示：
	   (setq inhibit-startup-echo-area-message
       "YOUR-LOGIN-NAME")
    4. initial-scratch-message
	   1. non-nil: 给定一个字符串，在开机后进入*scratch*缓冲区时显示
       2. t:禁止在*scratch*缓冲区显示信息，为空
Case creation time:[2017-09-19 二 15:00]
** DONE [#D] Theme:初始化文件								   :@Blog:@Emacs:
	- State "DONE"       from "WAITTING"   [2017-09-20 三 15:22]
1. .emacs 或 ~/.emacs.d/init.el
	  1. emacs启动完成后，会试图去加载位于家目录下的初始化配置文件，该文件要么是.emacs或者.emacs.el,要么是在.emacs.d目录下的一个名为init.el的文件
	  2. 命令行‘-q’, ‘-Q’, and ‘-u’控制是否加载emacs的初始化文件以及到哪里加载，-q ,-Q,标识，不加载配置文件，-u USER,标识，加载USER的配置文件来替代自己的
	  3. 如果什么选项都没有指定，emacs会使用：LOGNAME环境变量，或者USER(大多数系统常用)，或者USERNAME(MS系统),来查找家目录下面的初始化文件 
2. default.el
	Emacs在安装之后，有一个默认的初始化文件：default.el，这是一个lisp library文件,Emacs会通过load来找到该文件。emacs的distribution没有这个文件，它有意让本地进行定制。如果这个默认的初始化文件存在，那么在emacs启动之后,随便什么时候去加载该文件都可以，但是，如果你自己的初始化文件存在，那么优先加载自己的初始化文件，可以在自己的初始化文件里面将inhibit-default-init设置为non-nil，那么，emacs在这之后都不会去加载default.el文件了，如果指定了-q选项，那么，emacs在启动之后，既不会加载自己的初始化文件，也不会加载default.el

3. site-start.el
   Emacs在加载1所示的用户初始化文件之前，会先加载该文件。可以使用--no-site-file选项来加载该文件,该文件是一个site-customization文件，与该文件相关的有：
   site-run-file，该变量指定了在用户初始化文件之前要加载的site-customization文件，该变量的值一般就是site-start，即指定site-start.el作为site-customization文件
   inhibit-default-init,该变量如果为non-nil，表示阻止emacs加载default initialization library file，默认为nil
   before-init-hook,在所有加载初始化文件（site-start.el，init.el，default.el）之前运行的一个钩子函数
   after-init-hook，在所有加载初始化文件（site-start.el，init.el，default.el）之后运行的一个钩子函数
   emacs-startup-hook,处理完毕命令行参数之后运行的一个钩子函数
   window-setup-hook，同emacs-startup-hook相似，不同之处在于该函数在frame参数设置完毕之后才被调用，调用的时机比emacs-startup-hook晚
   user-init-file,保存用户的初始化文件的路径
   user-emacs-directory，保存.emacs.d目录的路径
Blog creation time:[2017-09-20 三 10:52]
** DONE [#D] Theme:关于require、provide、load、load-file、 autoload、 load-path的解析 :@Blog:@Emacs:
   - State "DONE"       from "WAITTING"   [2017-09-18 一 21:41]
参考网址：http://ergoemacs.org/emacs/elisp_library_system.html
*** features provide require
1. 三者之间的关系
	require函数在被调用时，传递一个参数symbal_name，拿到该symbal_name之后,会到features变量列表中查找是否有symbal_name的存在如果没有，则调用load函数(依据load-path变量中的提供的路径列表),去加载symbal_name.el，并解析该文件的内容，当解析到provide函数时，就将provide后面的标识符(一般就是symbal_name),加入到features这个变量中去；如果有，则直接解析该文件的内容(因为既然在features变量列表中查询到了该symbal_name，那就意味着之前已经调用过load函数，因此也必然是在load-path变量列表的路径下找到的该symbal_name.el,所以路径问题也就不用在考虑了)；

2. provide函数原型：(provide FEATURE &optional SUBFEATURES),其中，SUBFEATURES是FEATURE所支持的比较特别的子特性

3. require函数原型：(require FEATURE &optional FILENAME NOERROR),其中，如果提供了FILENAME，当FEATURE没有在features列表中时，就去加载FILENAME，而如果FILENAME被忽略，则FEATURE被用于作为待加载的文件名，并依附上.el或者.elc后缀，从load-path变量列表中加载FEATURE.el

5. features是一个全局变量列表，其值是elisp符号列表

6. elisp的package通常都会在末尾位置给出(provide 'symbal_name)的形式，当解析器解析到provide这个关键字时，会将symbal_name加入到features这个列表中去

7. 可以使用C-h v来查看该变量的值，里面的很多features是emacs内置的features，还有一些是用户定制的symbal_name

8. 当解析器解析到(require symbal_name)这句语句的时候，会去查询features这个变量列表是否有该symbal_name,如果没有在该列表中，emacs将会基于symbal_name,来猜测文件的名字为symbal_name.elc或者symbal_name.el，然后使用load加载该文件；如果symbal_name在列表中，require函数可能会在第二个参数中指定文件名

9. features的目的是让emacs知道，是否一个package已经被加载

10. features变量和函数{provide,require}时相辅相成的，一个emacs的FEATURE想要加入features这个变量列表，首先必须有FEATURE.el这个文件，且该文件里有语句(provide FEATURE.el),其次，必须有语句(require FEATURE),缺少前者语句，则启动emacs时会报错，缺少后者语句，则FEATURE.el是无法被加载解析的

11. 执行到require函数时，总是先去检查features列表，查看symbal_name是否已经在里面了，如果没有在里面，则调用load函数加载该文件，当然了，load函数会去查找load_path这个变量列表，该列表里面提供了symabl_name.el这个文件的绝对路径
*** load-path
1. 这是一个变量而非函数，该变量里面存放以空格分隔的目录列表或者为nil（这意味着为默认目录:default-directory）
2. load一个文件时，会到该目录列表下面进行搜索
3. 该变量会被require咨询
4. 使用directory-file-name可以增加一个条目到该列表
5. 实例1：(add-to-list 'load-path "~/.emacs.d/lisp")  备注：因为load-path是一个变量列表，所以，往里面添加内容需要使用add-to-list
Blog creation time:[2017-09-18 一 13:49]
*** load-file
1. load-file的函数原型：(load-file FILE)
2. 加载一个名为FILE的Lisp文件
3. 该函数是指定一个具体的.el， .elc文件让emacs来加载，而不是让emacs去猜
*** load
1. load的函数原型：(load FILE &optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX)
2. 该函数会去加载并执行一个名为FILE的文件.首先FILE会被附加.elc或者.el后缀，然后在load-path给定的目录列表中进行搜索
3. 第二个参数 NOERROR 如果设置为non-nil,那么，那么当FILE不存在时，也不会报错
4. 第三个参数 NOMESSAGE 如果设置为non-nil,那么，将不会在加载过程的开始和结束打印信息，但是，force-load-message会覆盖这个参数的设置
5. 第四个参数 NOSUFFIX 如果设置为non-nil，那么，将不会试图为FILE增加.elc或者.el的后缀
6. 第五个参数 MUST-SUFFIX 如果设置为non-nil，那么，一定要为FILE增加.elc或者.el的后缀
7. require，autoload本质上最终都是调用该函数进行工作
8. 该函数查找文件，打开文件，执行文件中的所有代码，最后关闭这个文件
*** autoload
1. 原理：
	当调用package-initialize时,emacs的解析器会遍历elpa目录下面的所有的.el文件,然后提取出注释里面带有autoload关键字的函数声明，然后将这些函数声明写到packagename-autoloads.el中，同时还会将所有路径加到load-path中去(这一步骤的源代码也在packagename-autoloads.el中体现)，emacs在解析packagename-autoloads.el时，文件中有函数路径定义，有函数声明，通过这两个条件，就能实现：当一个autoload的函数被调用时，能根据函数路径以及函数声明立即定位到函数的定义（函数源代码所在的文件）处去执行函数
2. autoload是一个函数
3. 函数的原型：(autoload FUNCTION FILE &optional DOCSTRING INTERACTIVE TYPE)
4. 第一个参数FUNCTION，是一个函数名，该函数在FILE.el或者FILE.elc中定义
5. 第二个参数FILE,是FUNCTION这个函数定义所在的源文件名，这个文件名会传递给load函数
6. 第三个参数DOCSTRINGS,是有关该函数的一些文档信息
7. 第四个参数INTERACTIVE,如果为t,表示该函数是interactive的
8. 第五个参数TYPE,标明FUNCTION的类型：如果为nil或者忽略，则表示FUNCTION是一个函数，如果为keymap,则表明是一个keymap,如果为macro或者t,则表明是一个macro
9. autoload是一个函数，最终该函数调用的还是load函数
10. 有两种方法可以将一个函数标识为autoload类型的函数，第一种是直接调用autoload;第二种是在函数定义处的源文件位置的上一行用魔法注释;;###autoload进行标识，第二种是最常用的方法
11. 一个函数的定义处，如果其前面一行被注释了###autoload，那么，就表示该函数是一个autoload的函数
12. 被标记为autoload类型的函数，能够在第一次被调用时自动加载
** DONE [#D] Theme:快捷键(base+mode+plugin)					   :@Blog:@Emacs:
	- State "DONE"       from "TODO"       [2017-09-04 一 22:53]
*** 我的快捷键：
1. 系统命令：
	- emacs ~/.bashrc:添加别名alias em='emacs'  . ~/bashrc
	- C-h C-h:help-for-help:查看所有的快捷键，函数，变量等.备注：下面的几个以C-h为前缀的命令均可以在该指令下找到
	- M-x:customize-group:定制插件的属性
	- M-x:package-list-packages:插件管理
	- M-x:shell: 打开外部shell
	- C-x e:计算某个变量以及函数的值，可以用eval-buffer来替代会更加高效
	- C-h t:打开基础手册
	- C-h i:阅读安装在系统里的软件包的使用手册
	- C-h m:describe-mode:列出当前打开的所有minor-mode
	- C-h w:where-is:对于一个给定的函数，列出所有关于它的调用者
	- C-h c:decribe-key-briefly:查询快捷键绑定的函数
	- C-h k:descrbie-key:查询快捷键绑定的函数的详细信息
	- C-h f:decribe-function:查询函数
	- C-h v:descrbie-variable:查询变量
	- C-h e:view-echo-area-message: 开辟*message*缓冲区,实时显示操作信息
	- C-h a xxx:搜索所有含有xxx关键字的命令

2. 分屏：
	- C-x 3:split-window-right:在右侧分屏
	- C-x 2:split-window-bottom:在下面分屏
	- C-x 1:delete-other-windows:关闭除当前光标所在窗口之外的所有窗口
	- C-x 0:delete-window:关闭当前光标所在的窗口
	- C-x o:other-window:将光标切换至下一个窗口（没有安装window-numbering这个插件时才使用，因为无法准确定位）
	- M-1:select-window-1:将光标切换至编号为1的窗口（前提是安装了window-numbering这个插件）
	- M-2:select-window-2:将光标切换至编号为2的窗口（前提是安装了window-numbering这个插件）

3. 缓冲区操作：
	- C-x b:switch-to-buffer:切换缓冲区
	- C-x C-b:ibuffer:切换缓冲区(ibuffer)
	- C-x k:kill-buffer:关闭当前缓冲区
	- C-v:向下翻页
	- M-v:向上翻页
	- C-M-v:光标在当前窗口，为上一个缓冲区向下翻页
	- C-M-S-v:光标在当前窗口，为上一个缓冲区向上翻页
--C-l:将当前行重置中央
--C-l C-l:将当前行重置屏幕最上方
--C-p:向上移动一行
--C-n:向下移动一行
--C-f:向前移动一个字符
--M-f:向前移动一个词
--C-b:向后移动一个字符
--M-b:向后移动一个词
--C-a:移动光标到行首
--M-m:移动光标至行首第一个字符
--C-e:移动光标到行尾
--M-a:移动光标到句首
--M-e:移动光标到句尾
--S-M-<:移动光标到文件首
--S-M->:移动光标到文件尾
--M-g g:goto-line:跳转光标到指定行
--C-u 8 C-f:向前移动8个字符
--C-u 8 C-v:向后移动8行（注意是8行不是8页，此处比较特殊）
--C-r:backward-delete-char:删除光标后面1个字符
--M-r:backward-kill-word:删除光标后面的1个单词
--C-d:hungry-delete-forward:删除光标前面的1个字符
--M-d:kill-word:删除光标前面的1个单词
--C-M-d:kill-whole-line:删除光标所在行
--C-x l:显示文件行数以及当前行
--C-g:终止命令
--C-c n:在光标所在行的前面一行插入一个空行

编辑：
--C-x C-f:打开/新建文件
--C-x 4 C-f:在另外一个窗口中打开/新建文件  
--C-Shift-@:set-mark-command:区域选择1
--C-+/-:er/expand-region:区域选择2
--C-x h:mark-whole-buffer:全选
--C-w：kill-region:剪切
--M-w:kill-ring-save:复制
--C-y:org-yank:召回最近一次移除的项
--M-y:召回之前移除过的项中的某一项，首先使用C-y召回最近一次移除的项，这不是我想召回的，所以
使用M-y继续往移除历史记录的上沿查找
--C-x u:undo:撤销
--C-x C-s:save-buffer:保存当前
--C-x s:save-some-buffers:保存所有
--C-x C-w:write-file: 另存为
--C-x C-c:save-buffers-kill-terminal:保存所有被修改的buffer并关闭emacs
--C-s:搜索，再按C-s往前递推

--<s-Tab:eclisp 宏（只能在org-mode中使用）
--C-c ':在窗口的右边显示eclisp宏内的代码
--Tab:收缩eclisp内部的宏代码

排版与缩进：
1. 排版:在加入定制的两个函数：indent-buffer以及indent-region-or-buffer之后，对当前buffer进行排版时，不用再选中，直接按TAB键即可
2. 缩进：TAB q

增强补全：M-/

Ace跳转：M-SPC

跳转到某一行：M-g M-g 
Blog creation time:[2017-09-04 一 22:10]
*** 快捷键操作
1. 解除快捷键: (global-unset-key "you key")
2. 绑定快捷键
   1. global-set-key
	  1. 让emacs告诉你绑定的格式：
	  	 我们经常需要绑定各种各样的快捷键，可是有的时候，我们不知道如何去绑定一些复杂的快捷键，比如f1的格式，比如shift怎么写，比如像 ‘ 之类的符号怎么描述，再比如像 \ 这个具有特殊意义的字符格式是怎样的，这里介绍一种万能的方法，让emacs告诉你这个绑定的代码是什么：
 	举个例子来说，我需要将M-S-<RET>绑定到(org-insert-todo-heading)这个函数:
-->M-x global-set-key RET 
-->在键盘上按下你打算绑定的按键组合(会在小缓冲区中实时显示)：Set key <M-s-return> to command:
-->输入你想要绑定到该快捷键的命令：org-insert-todo-heading 回车
-->查看绑定代码：C-x ESC ESC:(global-set-key [M-s-return] (quote org-insert-todo-heading))
-->将这条源代码添加到自己的配置文件中去(不添加的话，刚刚绑定的快捷键只会在本次环境中生效)
** DONE [#D] Theme:插件(plugin-in)管理						   :@Blog:@Emacs:
	- State "DONE"       from "WAITTING"   [2017-09-18 一 09:16]
*** 安装与卸载插件:
方案一：(推荐)
安装：在配置源码的包管理器函数：linjiajun/package下面添加对应包的名字，重启emacs，即可自动安装
卸载：在配置源码的包管理器函数：linjiajun/package下面去除对应包的名字，然后M-x:package-autoremove,即可卸载

方案二：
安装：M-x：package-install:xxx
	 将xxx这个包写入包管理器函数linjiajun/package下面

卸载：在配置源码的包管理器函数：linjiajun/package下面去除对应包的名字，然后M-x:package-autoremove,即可卸载

方案二：
安装：M-x:package-list-packages
	 C-s:xxx :查找package
	 i:标记安装 
	 u:撤销标记
	 x:执行
	 U:更新所有包至最新
	 将xxx这个包写入包管理器函数linjiajun/package下面
卸载：在配置源码的包管理器函数：linjiajun/package下面去除对应包的名字，然后M-x:package-autoremove,即可卸载

备注：http://melpa.org 该网站存放了emacs的plugin,用户从该网站下下载插件进行安装，该网站上的插件有最新版
和稳定版之分，稳定版在Getting started下面有介绍，用户只需要将包管理器中的地址换成：
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives
             '("melpa-stable" . "https://stable.melpa.org/packages/") t)
#+END_SRC
注意：在windows下，https要换成http，否则会有问题
Blog creation time:[2017-09-17 日 16:15]
*** 插件学习
***** monokai-theme
--功能：一个经典的主题
--相关快捷键：无
***** company
--功能：补全代码
--相关快捷键：C-n , C-p , C-f , C-b
***** hungry-delete
功能：一次性删除从光标位置到字串之间的空格
快捷键：backspace
***** swiper+counsel
功能：在小缓冲区弹出可预览可供选择的窗口，提供更好的用户体验
被改善的快捷键：
--M-x:
--C-s:
--C-x C-f:
--C-h f:
--C-h v:
--C-c g: 所有被git管理的文件都会在小缓冲区内显示出来
--M-s i:
***** smartparens
功能：当输入“ ’ （ { 等符号时，会自动补全 ” ‘ ） } 
触发：输入符号
***** helm-ag
1. 安装: linux用户需要安装 apt-get install silversearcher-ag,然后安装helm-ag插件

2. 搜索:
-- 基础搜索: helm-do-ag-project-root: init pack  (基于git仓库,搜索所有含有关键字init以及pack的行)
-- 过滤搜索: helm-do-ag-project-root: init pack !set  (基于git仓库,搜索所有含有关键字init以及pack,但是不含有set的行)
-- 编辑搜索结果: C-c C-e 进入 helm-ag-edit 模式, 结合 M-s e 的标记功能,可以进行批量修改
** DONE [#D] Theme:org-mode									   :@Blog:@Emacs:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:27]
*** org-mode快捷键
--C-c a:org-agenda
--C-c l:org-store-link
--C-c c:capture
--C-c b:org-iswitchb

--全局大纲之间移动光标：C-c C-p/n
--同级别大纲之间移动光标：C-c C-b/f
--跳转到上一级大纲：C-c C-u
--切换到大纲浏览状态：C-c C-j

--M-<RET>:在光标位置插入一个同级标题
--C-<RET>:在尾端 插入一个同级标题
--M-S-<RET>:在光标位置插入一个同级TODO标题:(global-set-key [M-s-return] (quote org-insert-todo-heading))
--C-S-<RET>:在尾端插入一个同级的TODO标题：(global-set-key [C-s-return] (quote org-insert-todo-heading-respect-content))
--<TAB>:循环切换光标所在大纲的状态
--M-LEFT/RIGHT:将当前标题升级/降级
--M-S-LEFT/RIGHT:
--M-UP/DOWN：将子树上升/下降

++C-x C-f : open file;
++C-x C-s : save file;
++C-x C-c : close file;

++C-h t : tutorials

++C-h-f : find function
++C-h f : describes function;

++C-h-v : find variable
++C-h v : describes variable

++C-h-k : find bingdingkey
++C-h k : describes bingdingkey

--C-c C-e:导出pdf
*** org-mode基础
--要使用org-mode buffer就需要将font-lock开启，emacs默认是开启的

--在org-mode下面，需要重点关注这四个org命令：org-store-link;org-capture;org-agenda;org-iswitchb

--org-mode主要使用三种类型的关键字：TODO keywords，tags, property name

--常见的tags关键字：boss,

--property name关键字：Release

--可选关键字：
--> #+TITLE:用于设置title
--> #+BEGIN_HTML:用于开启一个HTML环境
Blog creation time:[2017-09-05 二 08:40]
*** org-mode时间戳的组成
一、时间戳
	 时间戳由尖括号 <> 或方括号 [] 表示，前者为激活时间，后者为非激活时间（不加入日程
表的时间）。括号内可以包括以下内容组成（按先后顺序）：
	(1)日期，如 2013-6-1
	(2)时间或时间范围，如 2:30pm 或 10:00-12:00
	(3)表示周期重复的字符串，如 +1w 表示每周重复
	(4)其他附加信息和特殊符号：
		符号意义
		+0 今天
		. 今天
		+4d 今天算起，第4天
		+4 同上
		+2w 今天算起，第2周
		++5 默认日期开始，5天后
		+2tue今天算起，第2个Tuesday
注意“今天”和“默认日期”所表示的意义是不同的，例如：
'2013-06-20 周四 .+1w' 表示这是一个周期性重复任务，每周四执行；但是如果某次任务的实
际完成日期（ DONE 状态产生日期）是星期一，那么下一次任务就是一周后的星期一
'2013-06-20 周四 ++1w' 同样表示一个周期性重复任务，每周四执行；但不管任务实际完成日
期是星期几，下一次任务的时间都固定为下个星期四由两个断线“–”连接起来的两个时间戳表示时
间段，如： '2013-06-25 周二'--'2013-06-26 周三'
	除以上标准用法外，一些不规则时间戳可以使用Emacs日志风格的字符串表示，同样放在方括
号或尖括号中。常用的有：
周年纪念，如毛泽东诞辰： %%(diary-anniversary 12 26 1893)
周期重复，如从6月1日开始每隔10天重复： %%(diary-cyclic 10 6 1 2013)
某些日期，用于组合不同的月、日、年，例如每年的3-5月的10号可以这么表示（t表示所有数值，
这里表示所有年度）： %%(diary-date '(3 4 5) 10 t)
某月的第几个星期几，用浮动日期格式字符串 %%(diary-float month dayname index) 表
示。其中 month 为表示月份的整数（同样可以使用t表示所有月份）， dayname 表示星期几（0为
Sunday）， index 为正数表示从前往后数，复数则相反。如5月的最后一个星期三表示为： %%
(diary-float 5 3 -1)

二、 产生时间戳
	时间戳可以直接输入，但最好使用快捷命令（期间要调用Emacs日历）产生：
快捷命令动作
C-c . 通过日历选择计划日期，如果在一个时间戳后面使用将产生一个日期段
C-c ! 同上，但产生非激活日期
C-u C c . 产生计划时间或时间段
C-u C c ! 同上，但产生非激活日期
C-c C-c 在时间戳上使用该命令将对该时间戳进行格式补全和校对
C-c < 插入Emacs日历中光标所在处的日期（或当前日期）作为时间戳
C-c > 访问Emacs日历上当前日期；如果光标处有时间戳就访问该日期
C-c C-o 在日程表上访问光标时间戳表示的日期/时间
S-UP/DOWN/LEFT/RIGHT前/后移日期或时间（小时/分），具体情况由光标所在位置而定

三、预约任务时间
3.1 安排开始时间（SCHEDUALED）
	表示任务将在指定的时间开始。计划时间通过 C-c C-s 命令输入，例如
SCHEDUsLED: '2013-06-25 周二'
一个任务在计划时间到达时将在每天的日程表上出现，直到任务标记为 DONE 。也可以延迟计划任
务在日程表上显示的时间，如延迟2天：
SCHEDULsED: <2013-06-25 周二 -2d
注意这里“计划时间”和通常所说的安排一个任务的时间不一样。如果要指定一个任务在确切的时间开
始，直接输入时间戳就可以了。

3.2 设定截止时间（DEADLINE）
	任务应该设置完成的截止时间。截止时间通过 C-c C-d 命令输入，例如：
DEADLIsNE: ’2013-06-26 周三 -5d‘
日期后面的 -5d 表示截止时间前5天开始在 today 日程表上提醒。如果不设置提醒开始时间则按
照 org-deadline-warning-days 的设置进行提醒。日程提醒将一直持续（即使任务过期），直
到任务标记为 DONE 状态。如果一个任务既安排了开始时间又设定了截止时间，日程表上的提醒将
有重复，可以选择显示哪个。忽略截止时间提醒的设置为：
(setq org-agenda-skip-deadline-prewarning-if-scheduled t)
忽略开始时间提醒的设置为：
(setq org-agenda-skip-scheduled-delay-if-deadline t)

3.3 安排周期重复任务的时间
	和前面的重复任务时间戳没什么不同，只不过要注意表示重复和表示提醒安排的字符串的顺序，
表示重复的在前，如：
DEADsLINE: '2013-11-01 周五 ++1w -3d'
*** org-mode实现gtd管理
**** 研究在org-mode下如何实现gtd管理的文档搬家
	 org-mode做为gtd时，有一个好用的功能，可以实现将一个TODO条目转移到gtd管理的任意文档下面，不过需要做
一些配置，其主要起作用的是一个变量：org-refile-target,可以对该变量进行定制，当定制完毕之后，一般会绑定
到一个快捷键：C-c w,就能实现将该条目移动至指定的文档下面
**** 关于如何调整agenda的默认显示窗口为全屏
	修改agenda默认显示窗口为全屏，需要customize-group变量org-agenda-windows中
Org Agenda Window Setup:current window即可
**** 关于删除一个被收录的条目的思考
	 理论上，一个idear被收录后，说明它曾经是有一定价值的，所以，即使后来不想去完成这个任务了
也应当留有痕迹，以便在以后需要时能随时找到，最好的方法是将其设置为Abort状态，应当给出终止的原
因，以后如果又觉得该任务又有价值了，可以将其设置为TODO并修改时间戳,然后该任务就能在日程表中出
现了，此时，可以去完成该任务！
	然而，有时我们可能因为某些原因添加了一个事项，然后突然发现该事项写错了或者重复了，此时，
我们需要真正的去删除该任务，将光标移动到该条目，使用快捷键C-k就能将该条目从源文件中移除，
注意了，是从xxx.org文件中删除，一旦删除之后你就再也找不回来了！
**** 解决emacs重启后无法加载到gtd所管理的文档的问题
今天注定难忘的一天，因为在折腾了一个周之后，终于成功的用上了emacs的gtd功能，有点
小激动。这是我的第一个博客，为了纪念这一天，就描述一个我在hack我的emacs的gtd工具过程中
遇到的一个困扰我长时间让我即将崩溃的问题吧！
     变量org-agenda-files配置了关于我所有被gtd管理的文件，在init-org-mode.el中配置
好以后，发现每次关闭emacs重启后C-c C-a快捷键对应的agenda-mode竟然找不到文件路径，总是
为空，必须使用eval-buffer之后才能找到文件的路径，我是用list函数来包含目录下的所有org
文件的，这有些说不通，我甚至用了eval-after-load函数来包裹我的代码都不行，我一度怀疑是
不是这个list函数有bug，后来证明还是我的问题，解决方案如下：
    需要C-h v一下org-agenda-files变量，最后一行有一个customize,点击进去之后配置该
变量的文件加载路径添加，保存之后会在custom-set-variables函数下面生成该语句
'(org-agenda-files (quote ("~/my-agenda")))，之后每次启动emacs，路径就能生效了！
如此，问题得到完美解决，my-agenda目录下的所有org文件都能被gtd访问到了
	总结：曾几度因为我自己配置的代码访问不了my-agenda目录下所有的org文件而放弃org
模式下这么好用的gtd工具，好在最终折腾许久，终于在手册中找到了解决方案，所以说，多研究
emacs的说明手册，是很重要的！
**** 创建归档文件
	 当我们使用gtd工具管理日程安排时，随着时间的推移，记录越来越多，相关的文件会越来越大，同时，
这些陈旧的记录干扰我们的视线，删除它们是不大合适的，因为以后我们可能还会去查询这些记录，所以，
我们需要将这些陈旧的日程安排归档到其他文件中去，可以通过命令：C-C C-x a 实现，调用该命令之后，
光标所在的条目将会被移至以该条目所在文件的文件名为前缀，加上archievd的文件中去，该文件不是.org
结尾，所以，在即使在gtd目录下，但我们使用org-agenda进行查询时，不会去遍历里面的内容，这就有效
的屏蔽了这些陈旧记录的干扰，同时还保留下了它们！
**** 如何创建和使用周期性任务
	 (1)每天的某个时间段重复：在添加的时间段的SCHEDULED<>最后添加++1d
	 (2)每周的某天的某个时间段重复：在添加的时间段的SCHEDULED<>最后添加++1w
Case creation time:[2017-08-07 一 14:06]
**** 如何打印将日程表打印成PDF
命令：C-x C-w
*** org-mode实现排版
1. 支持的列表符号: * - + 1. 
2. 示例
   1. 标题一
	  1. 条目一
		 - 事项1
		 - 事项2
		 - 事项3
	  2. 条目二
		 - 事项1
		 - 事项2
		   - 事项3
	  3. 条目三
		 - 事项1
		 - 事项2
		 - 事项3
   2. 标题二
	  1. 条目一
		 - 事项1
		 - 事项2
		 - 事项3
	  2. 条目二
		 - 事项1
		 - 事项2
		 - 事项3
	  3. 条目三
		 - 事项1
		 - 事项2
		 - 事项3
3. 快捷键：
   1. 排版：M-TAB
   2. 对齐：TAB
   3. 缩进：TAB q
*** org-mode表格
1. 名词解释:
   1. field: 指代单元格
   2. row: 行
2. 基础操作:
   1. 创建一个m列n行的表格: C-c |  mxn : org-table-create-or-convert-from-region
   2. 表格对齐: C-c C-c: org-table-align: 光标保持在该单元格内,但是会移动到该单元格内容的首部
   3. 将光标所在列向左边移动: M-righ
   4. 将光标所在列向右边移动: M-left
   5. 将光标所在行向上面移动: M-up
   6. 将光标所在行向下面移动: M-down

   7. 光标向右边移动一个单元格: <tab>: org-table-next-field: 移动到最后一列边界时,自动跳转至下一行的行首单元格;移动到表格的最后一个单元格时,新建一行,光标定位至该新行首
   8. 光标向左边移动一个单元格: S-<tab>: org-table-previous-field: 移动到第一列列边界时,自动跳转至上一行的行尾单元格;移动到表格的第一个单元格时,终止移动
   9. 在光标所在行的下面新建一行: RET: org-table-next-row: 创建新行并将光标跳转至其正下方

   10. 在光标所在行的下面一行插入分隔线: C-c -: org-table-insert-hline
   11. 在光标所在行的下面插入一个新行: C-c <RET>: org-table-hline-and-move
   12. 在光标所在行的上面插入一个新行: M-S-<up>: org-table-insert-row
   13. 在光标所在行的左边插入一个新列: M-S-<left>: org-table-insert-column
   14. 删除光标所在行: M-S-<down>: org-table-kill-row
   15. 删除光标所在列: M-S-<right>: org-table-delete-column
** DONE [#D] Theme:abbrev-mode								   :@Blog:@Emacs:
	- State "DONE"       from "WAITTING"   [2017-09-19 二 11:27]
1. 功能：定制缩略词
2. 使用方法：缩略词+空格
Blog creation time:[2017-09-19 二 10:49]
** WAITTING [#D] Theme:evil-mode							   :@Blog:@Emacs:
*** vim基本概念
1. vim的作者Bram Moolenaar
2. vim是在vi的基础上改进，以及增加很多特性之后，发展而来的一个文本编辑器
3. vim的四种模式
   1. 正常模式 (Normal-mode)
	  - 按ESC从任意模式切换至该模式
	  - 该模式是vim启动后的默认模式
   2. 插入模式 (Insert-mode)
	  - i：insert,插入(前),在方形光标，标记字符的前面插入
	  - a: append,追加(后)，在方形光标，标记字符的后面追加
	  - I: 在方形光标，所在行的行首插入
	  - A: 在方形光标，所在行的行尾插入
   3. 命令模式 (Command-mode)：
	  - 按‘：’会进入该模式
	  - 可以执行一些输入并执行一些vim或插件提供的指令
	  - 这些指令包括设置环境、文件操作、调用某个功能等
   4. 可视模式 (Visual-mode)：
	  - 在正常模式中按v会进入该模式,光标经过的地方会被选中
	  - 在正常模式中按V会进入该模式，光标经过的行都会被选中
	  - 在正常模式中按C-v进入该模式,光标定位的一个矩形区块会被选中
      - 备注：可以用i来阻止空格
4. vim的设计理念：命令的组合，该组合基本模型为：光标初始位置+操作+光标终止位置，其中光标初始位置可以缺省，缺省之后，光标的初始位置就是光标的当前位置
5. vim中最重要的概念：motion，译为“跨过”,指光标从初始位置移动到结束位置，这两个位置之间的选区称为一个motion，就实际运用而言，这个选区的有效范围还是取决于“光标初始位置+操作+光标终止位置”模型中的操作，比如，d表示删除行，
6. motion之所以重要，是因为vim的设计理念是命令组合,看下面的例子：
   - d: 删除, j: 移动到下一行，所以，dj: 删除前行和下一行
   - d: 删除, dd: 删除当前行，2: 两次 >> 2dd: 连续两次删除当前行（效果同dj）
   - d: 删除， $: 行尾 >> d$: 删除光标到行尾部之间的内容
   - d: 删除， G：文件尾部 >> dG: 删除光标位置
   - gg: 文件首部，y: 拷贝，G: 文件尾部 >> ggyG:先移动到文件首部，紧接着执行拷贝命令，再移动到文件尾部，所以拷贝的内容就是光标两次移动的motion，即拷贝整个文件
*** vim命令
1. cmd{motion}中的cmd
   - d: 触发剪切这个动作
	 例：dd: 两个d的含义是不一样的，第一个d是cmd,含义是触发剪切这个动作，第二个d是motion，含义是，跨过当前行），组合起来就是剪切当前行的内容到剪切板
   - c：触发剪切这个动作，并进入插入模式
	 例：cw: 剪切光标后面的一个单词到剪切板
   - y： 触发拷贝这个动作
	 例：yw: 拷贝光标后面的一个单词到剪切板
   - 备注：这三个命令都有的一个特点是，命令输入之后，方形光标的变成一个矮方形的模样，这意味着需要用户继续给出一个motion
2. normal-mode：ESC
3. insert-mode：i
4. command-mode: ':'
5. 显示行号: :set number
6. 向前移动一个字符：l
7. 向后移动一个字符：h
8. 向上移动一行：k
9. 向下移动一行：j
10. 行首：^
11. 行末尾：$
12. 文件首：gg
13. 文件尾部：G
14. 移动到第88行：88G
15. 向后移动一个词： w
16. 向前移动一个词： b
17. 向下翻页：C-f
18. 向下翻半页：C-d
19. 向上翻页：C-b
20. 向上翻半页：C-u
21. 剪切： d
22. 拷贝： y
23. 剪切字符： x
24. 选区：在normal-mode下按v或者V
25. 删除选区之间的内容：选中，d
26. 向后删除一个字符：x
27. 向前删除一个字符：X
28. 向后删除一个单词：dw (diw，保留待删除的单词后面的空格)
29. 向前删除一个单词：db
30. 删除光标到行首之间的内容：d^
31. 删除光标到行尾部之间的内容: d$
32. 删除当前行：dd
33. 全选：ggVG
34. 黏贴： p
35. 撤销上一步：u
36. 恢复上一步撤销：C-r
37. fx:向后查找，最近的一个x字符，并移动光标到x的前面
38. Fz:向前查找，最近的一个z字符,并移动光标到z的前面
39. /:查找，n查找下一个
40. 剪切板:
    1. 说明: Vim 有12个粘贴板依次编号为：0, 1, 2, ... 9, a, ", +, 其中 + 号为系统粘贴板, ” 为临时粘贴板
	2. "nyw: 复制当前单词到 n 号剪切板
	3. "np : 粘贴 n 号剪切板内容到当前位置
	4. "+Y : 复制当前行到系统剪切板
	5. "+ny: 复制当前行加下面 n 行到系统剪切板
	6. "+p : 粘贴系统剪切板内容到当前位置后
Blog creation time:[2017-09-22 五 07:46]
*** evil的基本概念
1. evil的6种模式：
   1. evil-normal-state
   2. evil-insert-state
   3. evil-visual-state
   4. evil-motion-state
   5. evil-emacs-state
	  - 在正常模式中按C-z会进入到该模式
	  - 再次按C-z会进入到normal-mode 
   6. evil-operator-state
** WAITTING [#D] Theme:搭建C/C++的IDE						   :@Blog:@Emacs:
   - State "WAITTING"   from "DONE"       [2017-08-08 二 09:50] \\
	 技术条件还不成熟！
	- State "DONE"       from "TODO"       [2017-08-08 二 09:22]
功能：	
	1.Tab缩进:4字符
	1.跳转到函数定义：Gtags   ycmd
	2.自动补全：
	3.语法检查：flycheck-ycmd
	4.查找:find-file-in-project and projectile
	5.编译:cmake
	6.调试
Blog creation time:[2017-08-07 一 13:05]
** ABORT [#D] Theme:研究包管理Cask							   :@Blog:@Emacs:
   - State "ABORT"      from "DONE"       [2017-09-18 一 09:45] \\
	 由于使用Cask和pallet来管理插件，个人认为显得比较麻烦，不能做到从github上
	 克隆下来源代码直接就能使用，还得配置cask,以及安装pallet，同时配置了cask以后，
	 不仅在家目录下面产生.cask文件，而且在.emacs.d中也生成.Cask文件，这反而使得
	 emacs变得不简洁了，因此，在用了一段时间的cask以后，决定回退到以前的包管理方案
	- State "DONE"       from "TODO"       [2017-09-04 一 22:53]
--安装cask:sudo curl -fsSL https://raw.githubusercontent.com/cask/cask/master/go | python
--设置cask的环境变量
--安装pallet:package-install --- pallet
--M-x:pallet-init:此时，在.emacs.d目录下有一个Cask的文件，列出了所有之前使用package-install
安装的包的别名
--M-x:pallet-install:此时，在.emacs.d目录下的elpa目录将会被复制到.emacs.d/.cask/下面
Blog creation time:[2017-09-04 一 22:
** DONE [#D] Theme:调节序号的小技巧							   :@Blog:@Emacs:
    SCHEDULED:<2017-09-18 一>
	- State "DONE"       from "WAITTING"   [2017-09-18 一 10:51]
说明：
	在编辑文档时，我们经常会给一些条目列出序号，但是，出于逻辑上或者排版的的考虑,经常
会打乱之前的编号，通常情况下，编号被打乱以后我们只得手动重新排序，然而，emacs提供了一个
自动重排编号的功能，只要满足前提所描述的格式即可

前提：该技巧必须要求条目的格式是：数字+点+空格+串

实现：
--M-RET:调整序号
1. hahhs
2. asda
3. asda
4. asdads
5. gfdgd#
备注：将当前光标定位到序号为8的#位置，按下M-RET，上面的序号就会变为：  
1. hahhs
2. asda
3. asda
4. asdads
5. gfdgd#
6.

备注： 以该格式书写的条目，还可以实现类似org-mode的收缩，使用十分方便
Blog creation time:[2017-09-18 一 10:43]
** DONE [#D] Theme:解决apt-get安装emacs后使用C-h i发现文档不全的问题 :@Blog:@Emacs:
    SCHEDULED:<2017-09-18 一>
	- State "DONE"       from "WAITTING"   [2017-09-18 一 14:53]
	使用apt-get来安装emacs,好像没有提供完整的info文档，因此，我们需要自己去gnu的官网上
下载info.gz结尾的手册，将其放到/usr/share/info/emacs-25下面，打开emacs,C-h i,然后按
g,在小缓冲区出现Go to node,切换到刚刚下载的那个手册即可
	一般情况下，安装完毕emacs之后，都需要到官方网站(https://www.gnu.org/software/emacs/manual/)
下载GNU Emacs manual,GNU Emacs Lisp reference manual,An Introduction to Programming in Emacs Lisp
的info document，将其移动至/usr/share/info/emacs-25下面，以备实时查询
	要经常使用g来切换node，而且在切换前应当C-x k 先将当前的info缓冲区给kill掉再重新打开进行切换
Blog creation time:[2017-09-18 一 14:47]
** DONE [#D] Theme:设置org-mode的文本的宽度，在超过宽度的位置自动换行 :@Blog:@Emacs:
    SCHEDULED:<2017-09-18 一>
	- State "DONE"       from "WAITTING"   [2017-09-19 二 07:57]
(global-set-key [f5] 'toggle-truncate-lines)
Blog creation time:[2017-09-18 一 15:28]
** WAITTING [#D] Theme:解决org-mode下无法使用org-capture和org-agenda的问题 :@Blog:@Emacs:

Blog creation time:[2017-10-17 二 15:52]
** WAITTING [#D] Theme:在shell下开启emacs		       :@Blog:@Emacs:
1. 命令: emacs -nw
2. 设置别名: vi ~/.bashrc   alias em='emacs -nw'  source .bashrc
Blog creation time:[2017-11-13 一 08:54]

