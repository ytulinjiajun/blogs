* blogs-tcp-ip-active
** DONE [#D] theme:网址收藏										 :@Blog:@TCP:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:32]
--IEEE中国:http://cn.ieee.org 
Blog creation time:[2017-09-05 二 08:54]
** DONE [#D] theme:基础概念与发展史								 :@Blog:@TCP:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:32]
*** 基本概念
--网络:计算机网络,电信网络,有限电视网络三者的统称,在不做特殊说明的情下,我们说网络,只得就是计算机网络

--结点和连接结点的链路构成网络

--结点:称计算机终端,集线器,交换机,路由器等为结点

--互联网(internet):网络和网络通过路由器互连起来就构成一个覆盖范围更广的网络,称之为互联网

--因特网(Internet):世界上最大的互联网,它是一个广域网,是一个采用TCP/IP协议族作为通信规则的计算机网络,前身是ARPANET网络

--万维网(WWW):使用因特网来通讯的一个具体运用

--电信网络:基于交换机的来电话通讯线路的电路交换的一种网络,即所有电话机连接在一台交换机上,这些电话机互相就可以通讯

--电路交换:电信网络中使用的交换技术,经过建立连接(占用通讯资源)--->通话(一直占用通讯资源)---->释放连接(归还通讯资源)三个步骤的交换方式称为电路交换

--分组交换:计算机网络中使用的交换技术

--主机:称连接在因特网上的计算机为主机,主机为用户进行信息处理

--路由器:路由器也是计算机,路由器用在核心网络之中,用于互连多个网络,并在多个网络之间转发分组

--网络把许多计算机连接在一起,而因特网把许多网络连接在一起

--IEEE:电气和电子工程师协会,一个国际性的,全球最大的,非盈利性质的致力于电气,电子,计算机,工程和科学等领域的学术组织

--广域网:WAN (Wide Area Net),广域网的范围较广,通常是跨国家,跨省这样的,因特网就是一个广域网,广域网之间的连接一般是高速链路

--局域网:LAN (Local Area Net),局域网的范围较窄,一个公司就能搭建一个局域网,当前最流行的局域网是以太网

--802.3有线局域网(以太网):原始的以太网帧格式被称为DIX格式或者EthernetII格式,这种格式由IEEE标准化为CSMA/CD网络,就称为802.3网络,实际上认为802.3就是以太网,以太网就是802.3

--无线局域网:WLAN,称为WI-FI,也称无线以太网,或者802.11

--802.11无线局域网(WLAN/WI-FI):,这个标准虽然与有线以太网标准不同,但是帧格式和通用接口大部分来自802.3,因此TCP/IP用于以太网的大部分功能也可用于WI-FI网络

--上面给出的802前缀定义了局域网和城域网的工作过程

--公网:由电信公司出资建造的大型网络,只要愿意缴纳一定费用给电信公司的人都可以使用这种网络

--专用网:某些部门为特殊业务建造的网络,这种网络不想单位以外提供服务,例如,军队,铁路,电力系统等

--接入网:AN,接入网本身既不属于因特网的核心部分,也不属于因特网的边缘部分,接入网的目的是把用户接入到因特网的网络,比如ISP就提供了接入网服务,使得用户能够接入到因特网

--协议数据单元(PDU):物理层称为比特流,数据链路层称为MAC帧,网络层称为分组,传输层称为段

--在网络中,数据总是以IP数据报(分组)的形式传输,这句话的意思是,网络和传输层的那些个ICMP,IGMP,TCP,UDP协议的分组都是封装在IP数据报(分组)里面的

--标识系统模型:who(MAC地址)<-->where(IP地址)<-->how(路由表)<--->which(哪一个进程) 

--IP地址是以网络号和主机号来标示网络上的主机的，只有在一个网络号下的计算机之间才能"直接"互通，不同网络号的计算机要通过网关（Gateway）才能互通

--子网标识:IP号同子网掩码的位与操作生成的子网IP就称为子网标识

--子网掩码的作用:用来判断任意两个IP地址是否属于同一子网络，这时只有在同一子网的计算机才能"直接"互通

--同一网段IP:子网标识相同的两个IP就称,这两个IP在同一网段

--网关地址:我们经常需要配置一个网关地址,当IP数据报传输到某设备,如果在该设备上的所有网络接口中都找不到与IP数据报携带的IP地址在同一网段的IP,则该IP数据报会被转发到网关地址去

--因特网中的网络数量:在因特网内,一个网段之内的所有IP地址构成一个网络,因特网中总共有可以接入多少个网络:A类(2^8) + B类(2^16) + C类(2^24) =  211.3664万个

--IP地址和MAC地址唯一标识哪个地方的哪台主机,而端口号却可以标识这台主机上的哪个进程
*** 网络的发展史
**** 网络的三大阶段：
--第一阶段:
-1969年美国国防部创建的第一个分组交换网,ARPANET,该网络只是单个网络的分组交换网而不是互连的网络
-70年代中期,人们意识到单独的网络不可能满足所有通讯问题,于是ARPA开始研究多种网络互联的技术,这就导致互联网的出现,因特网开始有了雏形
-1983年,TCP/IP协议成为了ARPANET上的标准协议,使得所有使用TCP/IP协议的计算机都能利用互连网相互通讯,所以1983年称因特网诞生年
-1900年ARPANET功成身退,正式宣布关闭

--第二阶段:
-1985年,美国国家科学基金会NSF围绕六个大型计算机中心建设计算机网络,即国家科学基金网络:NFSNET,这是一个三级网络,主干网,地区网,校园网,这三种网络在但是成为因特网中的主要组成成分
-1991年,NSF和政府机构意识到,因特网不应当仅仅局限与大学网络和科研机构,应当扩大范围,此时世界上许多公司纷纷接入到因特网,因特网使用量剧增,政府决定将因特网的主干网转交给私人公司来经营,并开始收费
-1992年因特网上的主机超过100万台
-1993年因特网主干网速率提高到45M/s(T3速率)

--第三阶段:
-1993年开始:由政府资助的NSFNET逐渐被若干商用的因特网主干网替代,政府不再负责因特网的运营
-1993年,出现了一个新的名词:ISP,因特网服务提供商,这些提供商拥有从因特网管理机构申请到的多个IP地址以及通讯线路以及路由器等联网设备,任何机构或个人缴纳规定的费用,就可以从ISP得到所需的IP
-因特网管理机构把一批IP有偿的分配给经审查合格的ISP,个人付费从ISP获得网址,然后就可以上网
-ISP也有不同的规模,实力强的ISP能够获得高速主干网,能获得大块的"蛋糕",覆盖国家范围的服务面积,而实力若的ISP只拥有本地范围的服务
-1994年,创建了四个网络接入点NAP,由四个电信公司经营,NAP用来交换因特网上的流量,它主要向各ISP提供交换设施,使他们能互相通讯,一些实力强大的ISP能够绕过NAP直接通过高速通讯线路和其他实力强大的ISP交换数据
-只要某个用户能够接入到因特网,那么他就能够成为一个ISP,他需要购买一些调制解调器或路由器这样的设备,让其他用户和他互联,不过好像不能收费,万恶的垄断啊!
-20世纪90年代初,欧洲原子核研究组织CERN开发了万维网WWW,大大方便了非专业人员对网络的使用
-1996年,由于因特网存在技术和功能的不足,加上用户急剧增加,因特网不堪重负,美国的一些研究机构和34所大学提出构建下一代因特网的计划NGI计划
**** 网络标准化工作
--RFC:TCP/IP协议的标准文档,所有因特网标准都是以RFC的形式在因特网上发表,到目前为止,里面有4000多个协议的定义,而最常用的也就十几个而已,并且这4000多个协议最终只有一小部分能成为因特网标准

--1992年,因特网不再归美国政府管辖,成立了一个国际性的组织,因特网协会(ISOC)

--ISOC下面有一个技术组织叫做因特网体系结构委员会IAB,负责管理因特网有关协议的开发

--IAB下面有两个工程部:因特网工程部IETF,因特网研究部IRTF

--IETF是由许多工作组组成的论坛,具体工作由因特网工程指导小组IESG管理,他们的工作主要是针对协议的开发和标准化

--IRTF是由许多研究组组成的论坛,具体工作由因特网研究指导小组IRSG管理,他们的工作主要是进行理论方面的研究和开发一些需要长期考虑的问题

--制定因特网的标准要经过四个阶段:

-因特网草案:这个阶段还不是RFC,有效期只有6个月

-建议标准:这个阶段就是RFC

-草案标准

-因特网标准
*** 因特网介绍
**** 概述
--因特网由边缘部分和核心部分两大块组成;

--边缘部分:由连接在因特网上的主机组成,这些主机又称为端系统

--核心部分:由网络构成
**** 边缘部分 
--边缘部分之间的通讯有两类通讯方式:客户服务器方式,对等方式

--边缘部分的通讯方式在工作过程中需要使用因特网核心部分的功能,边缘部分的主机到核心部分的连接通常以相对低速的数据链路相连接,
不同于核心部分多个网络之间的连接是通过路由器使用高速链路来连接

--客户服务器方式:

-描述通讯中所涉及的两个进程(两台计算机进程)之间的服务与被服务的关系,客户和服务器是指计算机进程,是软件

-最主要的特征是,客户是服务请求方,服务器是服务提供方

-服务请求方和服务提供方都要使用因特网的核心部分

-客户程序在被用户调用后会主动向服务器方发起请求服务

-客户程序必须知道服务器的地址

-客户程序不需要特殊的硬件和很复杂的操作系统

-服务程序在系统启用后自动调用并一直不断运行,被动等待并接受来自客户端的请求

-服务器可同时处理多个客户请求

-服务器一般需要强大的硬件和高级的操作系统

--对等连接方式:

-对等连接又称P2P,这种连接方式在两个主机通讯时,并不区分哪个是服务请求方,哪个是服务提供方

-只要两个主机进行了P2P连接,他们就可以进行平等的,对等的通讯

-该连接方式下,通讯双方都可以下载对方已经存储在硬盘中的共享文档,因此,该连接方式也叫PSP文件共享

-对等连接方式本质上看还是客户服务器模式,只是,通讯双方的主机既是客户端又是服务器

-对等连接可以支持上百万个对等用户同时工作
**** 核心部分
--因特网中最复杂的部分就是核心部分,因为核心部分要向网络边缘的大量主机提供通讯的实现细节
--网络核心部分起特殊作用的设备是路由器,路由器通过高速链路将许多网络互联起来构成了网络的核心部分
--路由器是一种专用的计算机,没有路由器,再多的网络也无法构建因特网
--路由器是实现分组交换的关键构建,其主要任务是转发收到的分组
--转发分组是网络核心部分最重要的功能
**** 电路交换
--电路交换技术起源于电话通讯,其目的在于解决N部电话相互连接时,电话线数量庞大的问题
--电路交换的内容是:正常情况下,N部电话互连需要N(N-1)/2对电线,而使用电路交换技术,让N部电话连接到1个交换机上,只需要N对电话线
--电信网络:N部电话连接到1个交换机上构成一个小型电话网络,将连有N部电话的N个交换机连接起来就构成了电信网网络
--电路交换:称经过建立连接(占用通讯资源)--->通话(一直占用连接)--->释放连接(归还通讯资源)三个步骤的交换方式为电路交换
--电路交换的特点是:在通话全部时间范围内,通话的两个用户时钟占用端到端的通信资源
--电路交换技术是电信网络中始终使用的方式,一百多年以来,交换机发生了多次更新换代,但是电路交互技术一直是电话通信领域数据的交换方式
--电路交换在电信网络中混得风生水起,如鱼得水,但是在计算机网络中就十分狼狈了,其传输效率往往很低,因为电路交换的通讯方式显得霸道,在释放连接时,通讯资源一直被占用,而计算机
网络传输数据是突发式的传输,真正传输数据的时间往往不到10%甚至1%,即,用电路交换传输计算机网络数据的话,所占用的通讯线路的绝大部分时间都是空闲的,宝贵的通讯资源就被白白浪费了
**** 分组交换
--由于电路交换在计算机网络中占用通讯线路的缺陷,所以在计算机网络中采用的是分组交换技术
--分组交换采用存储转发技术
--报文:称要发送的整块数据为一个报文
--分组:将一个报文等长度的划分为一个个数据段,在这些个数据段之前加入一些必要的控制信息(称这些控制信息为首部)之后,就构成了分组
--包:分组又称为包,分组的首部称为包头
--分组是因特网中传输的数据单元
--分组中的首部非常重要,正是因为一个分组有首部的存在,一个分组才能在因特网中独立选择传输路径,不用担心顺序,不用担心丢包问题,
因为在网络层处理分组时总能根据分组的首部信息来重组包,来鉴别是否丢包,丢了哪个包,然后要求重发丢掉的包等
--分组交换的工具:路由器
--分组交换的原理:存储转发
-路由器收到一个分组,先暂时存储下来
-路由器去检查分组的首部,并查找路由表,按照首部中的目的地址,找到合适的链路将该分组转发给下一个合适的路由器
-经过N个路由器后,分组被交付到目的主机
-在路由器交换分组期间,各个路由器会经常交换路由信息,各自更新自己的路由转发表,下一次同样目的地址的分组到达该路由器时,路由器就不用再计算,直接查路由表即可
-当讨论因特网的核心部分中路由器转发分组的过程时,往往把单个网络简化为一条链路,将路由器当做结点
-假定主机A向主机D发送数据,中间经过结点N1,N3,N6,尽管数据的完整传输线路是A->N1->N3->N6->D,但是不像电路交换那样一直占用整条线路,假设分组在N1->N3进行传输时,
A->N1,N3->N6->D是可以被其他分组使用的,即分组在传输之前不必占用一条完整的通讯链路,分组在哪段链路上传输才占用这段链路的资源
-假定在A->N1传输链路上传输某一分组,而此时该链路上的信息量特别大,那么路由器会寻找另一条链路传输该分组
-需要注意的是,我们说路由器具有存储分组的功能,这里说的存储是指存储分组而不是存储完整的数据报文
-路由器强调了一个存储转发的功能,尤其是这个存储,为什么要存储呢,那是因为从当前路由器向其他路由器转发当一个分组时,有可能因为某些结点或链路故障而导致丢掉分组
或者分组损坏,此时,各路由器中运行着的路由选择协议就能找到其他其他链路来重发该分组
-分组交换可以在传输过程中动态的分配传输带宽
-以分组作为传输单位,可以不用先建立连接就就能向其他主机发送分组
-分组交换也有缺点,分组在各路由器存储转发时需要排队,这会造成一定延时;每个分组必须都带有首部,这会造成一定开销
*** 计算机网络的性能参数
**** 性能指标
--速率:指连接在计算机网络上的主机在数字信道上传输数据的速率,单位是b/s或者bps(比特每秒)
还有kb/s,Mb/s,Gb/s,Tb/s,其中kb/s = 10^3 b/s,以此类推
--带宽:用于表示通讯线路所能传输数据的能力,即单位时间内从网络中的一点到另一点所能通过的最高数据速率,单位是b/s
--吞吐量:单位时间内通过某个信道的数据量,单位是b/s
--时延:报文,分组,比特从链路的一端传输到另一端所用的时间,时延分为:发送时延,传播时延,处理时延,排队时延
--时延带宽积:传播时延和带宽的乘积,假定从A到B连续发送数据,若A到B的传播时延是20ms,A到B的带宽是10Mb/s,延时带宽积为2*10e5b/s,
这就意味着,当A发送的第一个比特到达B时,发送端已经发送了20万个比特且这20万个比特正在A到B的链路中向前移动
--往返时间:RTT,表示从发送方发送数据开始,到发送方收到来自接收方确认消息,总共经历的这段时间,卫星通讯时,往返时间RTT比较长,是一个很重要的指标
--信道利用率:指某信道有百分之几的时间是被利用的,空闲信道的利用率是0
--网络的利用率:全网络的信道利用率的加权平均值
备注:信道利用率和网络利用率并非越高越好,因为这两个利用率过高会产生非常大的时延,分组交换有个缺点就是在路由器处理当前分组期间,其他分组需要排队等候
当信道利用率过大,分组就会更多,在路由器处排队的时间就更长,相应的传输延时就加长,因此信道的利用率不应超过50%
*** 数据报
--数据报起源与CYCLADES系统
--数据报是一个特定类型的分组,源和目的地的识别信息都位于分组中而不是分组交换机中
--以数据报的形式传输数据,就不再需要在交换机中维护连接状态,所以数据报的传输可以建立无连接的网络
--

*** 端到端论点
--TCP/IP协议族设计的一个重要原则是端到端论点
--端到端论点是关于协议是否保留消息边界的论点
--端到端论点认为,重要的功能,例如差错控制,加密,交付确认等通常不会出现在大型系统的低层,即低层不应以完美为目标
--端到端论点认为,诸如:保证数据不丢失,发送方控制发送速率等功能,应当在端主机的运用程序中实现
--TCP在端主机实现速率控制
*** 命运共享原则
--命运共享原则认为选择使用哪些功能,应当在同一计算机,网络或是软件栈中实现
--命运共享原则建议将所有必要的状态放在通讯端点,这些状态用于维护一个活动的通讯关联
--命运共享是一种通过虚拟(由TCP实现)连接维持活动的的设计理念
--尽力而为的交付方案在网络基础设施中有些单元失效的情况下,只要有些通讯路径仍然可用,就不会影响网络设备的通讯能力
*** 差错控制
--在网络中存在由于各种原因,硬件问题,数据传输中被修改,在无线网络中超出范围等,导致数据损坏或丢失的情况,对这种错误进行处理称为差错控制
--端到端论点和命运共享原则建议应当在运用程序附近或内部实现差错控制
--当只有少数位出错时,有一些数学算法可以检测到并修复这种位差错,这个过程通常在网络中实现
--当一个分组中的更多的数据发生严重损坏时,整个分组通常会被重新发送,这个过程在网络内部实现
--分组损坏重发这样的方案对于那些顺序要求严格和无差错交付的运用是有用的,但是,诸如建立连接以及重新传输延迟较为苛刻的场合,这种功能可能是不希望的
--数据报的传输并不关心交付数据块的顺序,因为程序最后会将所有无差错的数据按照原来的顺序组合起来
--网络中,可靠交付,按顺序交付,协议采用一种尽力而为的交付方式,即,在交付过程中,协议不会花费很大的努力来确保数据没有差错,一些差错通常使用差错检验码
或者校验来检测,当检测到这种差错时,出错数据报2仅仅会被丢弃而没有进一步行动
--在尽力而为的交付中,如果交付成功,发送方能以超过接收方处理能力的速度生成信息
--在尽力而为的交付中,降低发送方发送速度可以通过流量控制机制实现
*** 参考模型
**** 模型简史
--OSI模型：开放系统互连标准的简称,由国际标准化组织ISO定义
--TCP/IP模型:来源与实践
**** OSI七层参考模型
---物理层
--数据链路层
--网络层
--传输层
--会话层
--表示层
--运用层
**** TCP/IP四层参考模型
--网络接口层:网卡驱动
--网络层:IP协议,ICMP协议,ARP协议,RARP协议,BOOTP协议
--传输层:TCP协议,UDP协议 
--运用层:DNS协议,FTP协议,HTTP协议,TELNET协议,SMIP协议
Blog creation time:[2017-09-05 二 08:54]
** DONE [#D] theme:实现数据传输									 :@Blog:@TCP:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:32]
*** 概述
--TCP/IP协议栈采用4层分层模型:网络接口层,网络层,传输层,运用层,每层之间相互独立,单独实现,每层都提供了和
其他层交互的接口,但是这种严格的分层必然会有大量的内存拷贝的问题存在,这会降低系统的总体性能,所以,LWIP并
没有采用完整的分层结构,它会假设各层之间的部分数据和结构赫尔实现原理在其他层之间是可见的,这样,数据包在递交
过程中各层协议可以直接对数据包中属于其他层协议的字段进行操作,这将会使得整个协议栈的操作变得更加灵活

--LWIP在实现时,参考了TCP/IP的分层思想,即每层都在一个单独的模块中实现,每层都会为其他层提供一些输入输出接口函数,每个
模块都在单独的文件中实现

--除了实现TCP/IP的基本功能(IP,ICMP,UDP,TCP)模块之外,还有许多支持这些基本模块实现的附加模块:操作系统模拟层,数据包和内存管理机制
网络结构管理层,数据校验和计算模块的API

--所以,严格上讲,LWIP并没有遵守严格的分层机制,因为LWIP是运用于嵌入式的场合,为了节省时间和空间上的开销,各个层次之间可能存在交叉存取的现象

--在操作系统中,TCP/IP协议栈往往被设计为内核的一部分,用户可以使用的只是操作系统提供的几个操作TCP/IP协议栈的API接口函数而已,所以,运用程序并不知道
协议栈内部使用的数据包的管理机制,也就无法避免内存的拷贝

--在嵌入式系统中,用户可以直接访问到TCP/IP协议栈内部的数据包,也就可以和协议栈共同使用内存区域,从而可以避免内存的拷贝带来的时间上的开销和空间上
的开销,这也是嵌入式系统极力避免的,所以有了对TCP/IP协议的变种LWIP

--总结:LWIP协议栈是以TCP/IP协议栈为基础,改进了分层(避免内存复制)结构,增加了一些模块后,形成的更加适合嵌入式系统的一个网络协议栈

--两种进程模型:单进程模型和协议栈驻留操作系统模型

--单进程模型:TCP/IP协议栈将分层中的每个模块都独立为一个单独的进程,各模块进程之间有明显的界限分隔,接口定义也十分清晰,这种模型的优点是协议的代码组织更加灵活
协议栈代码的编写和调试轻松,但是缺点是频繁的进程切换会占据掉一部分时间,造成很大开销,使得协议栈的效率降低

--协议栈驻留操作系统模型:将协议栈驻留在操作系统当中,使之成为操作系统的一部分,用户进程与协议栈内核之间的交互就通过操作系统提供的
系统函数来实现,这中方法的特点是协议栈内部的执行效率将会提高,但是需要使用交叉编程技术,协议栈的实现较为复杂,各层之间不会有明显的界限

--LWIP进程模型:协议栈的内核同操作系统分离,但是,将整个LWIP协议栈作为操作系统中的一个单独的进程而存在,用户运用程序可以驻留在协议栈内核的进程中,也可以实现为一个
单独的进程,这样的模型最大的优点是,协议栈可以在任何操作系统上移植,缺点是协议栈的运行需要操作系统的任务调度,协议栈的响应会受操作系统的实时性的影响,所以,应当将
LWIP进程优先级设置高一点

--当用户运用程序驻留在协议栈的内核进程中时,实际上,用户与协议栈之间的通讯是通过回调函数实现,即raw/callback API(原生态回调函数的API)

--当用户程序作为一个单独的进程时,用户与协议栈之间的通讯是通过操作系统系统的信号量与邮箱机制,并调用sequential API(连续的API)或者socket API(套接字API),
来实现用户进程和协议栈内核之间的数据交互,目前用的是用sequential API

--STM32F4依照IEEE 802.3-2002标准,通过以太网,发送和接收数据

--STM32通过以太网DMA,跟以太网专用收发FIFO打交道:以太网DMA的一端连接到STM32的总线矩阵,
另一端连接到两个专用FIFO(TX FIFO和RX FIFO),大小均为固定2KB,即,配置好以太网DMA之后,在配置中指定的
STM32总线矩阵上的外设或存储器就会按照以太网DMA配置的规律将数据发送到专用发送FIFO中,或者专用接收FIFO
中的数据会依据以太网DMA的配置将数据传送到预先在DMA中配置好的STM32总线矩阵上的外设或存储器中去
 
--专用FIFO跟MAC内核打交道:STM32指挥发送数据时,MAC内核总是去TX FIFO中取得待发送的数据,STM32指挥接收数据时
MAC内核总是将数据交付给RX FIFO 

--需要注意的是,上面两点给出的过程是数据传输的过程,所以,必然得有个指挥中心在操控这些行为,这个工作由AHB从
接口承担,STM32的控制中心通过AHB从接口发出指挥指令,指挥DMA控制状态寄存器,以及FIFO工作模式寄存器,同时同MAC内核
进行协商;事情是这样的,STM32配置DMA寄存器,FIFO寄存器,以及同MAC内核协商,而以太网DMA依据DMA寄存器的配置进行工作,
MAC和STM32协商之后,会配置好自己的MAC控制寄存器来向FIFO取得数据或交付数据

--到目前为止,数据已经交付到了MAC内核(数据链路层),现在该聊一聊MAC内核如何同物理层PHY打交道的问题了,那就是通过 
IEEE802.3规范中定义的两个接口:介质独立接口(MII,RMII),站管理接口(SIM),其中,介质独立接口可以大有来头,由一个叫做
RMIII联盟的组织专门负责维护它,为他制定规范,目前的许多领域如交换机,网络接口卡等用的都是该接口规范

--通过介质独立接口(MII,RMII)以及站管理接口,就将MAC内核与物理层PHY建立起了连接,当然,数据也就能从MAC内核交付到PHY
了,下面的问题就是如何将数据从PHY发送出去的问题,显然,通过RJ45口,PHY芯片提供了RJ45接口规范的引脚,所以通过该引脚,
数据就顺利从PHY发送出去了,至此,功德圆满
*** 收发数据:
-->STM32F4控制器在内存地址0X8700 0010处开始之后的1k的空间为待发送的数据
-->这1k的数据由系统存储器通过以太网的DMA发送至以太网专用2K的TX FIFO缓冲去进行缓冲
-->MAC内核再从这2k的TX FIFO中取得待发送的数据,并封装成MAC帧
-->ARP协议拿着目的IP在子网内内广播ARP请求,目的IP对应的主机收到ARP请求后,会响应该ARP请求,地址映射完毕
-->依据ARP缓存,从预先准备好的MAC帧中提取出IP数据报,IP数据报将在子网的各路由之间穿梭
-->在到达接收方之前,将IP数据报封装成MAC帧,接收方的MAC内核将该MAC帧中的数据取出来,放到2K的RX FIFO中
-->STM32的以太网DMA读取RX FIFO中的数据

*** LWIP源码包介绍
****** api文件夹
--包括了LWIP的sequential API和stocket API两类接口函数及实现的源码,要使用这个文件夹下面的api函数,需要操作系统的支持

****** core文件夹
--LWIP内核源代码,可以单独运行,且不需要操作系统的支持
--包含了IP,ICMP,IGMP,TCP,UDP等核心协议,以及运用层的DNS,DHCP,SNMP协议
--ipv4文件夹:
-autoip.c:当主机从DHCP服务器获取IP地址失败,则此时,主机可以选择启动autoip功能来配置自身ip地址,并提供一套机制来避免ip地址冲突
-icmp.c:网络控制报文协议ICMP的实现源码,提供ping运用
-igmp.c:网络组管理协议IGMP的实现源码
-inet.c:包含IP层使用到的一些功能函数的定义,如IP地址转换,网络字节序与主机字节序转换等
-inet_chksum.c:包含IP数据包校验的相关函数
-ip.c:包含IPV4协议实现的相关函数,如数据包的接收,递交,发送等
-ip.addr.c:包含判断ip地址是否为广播地址的函数
-ip_frag.c:提供了报文在IP层分片为分组的函数,以及重组分组为报文的函数

--snmp文件夹
-包含了简单网络管理协议SNMP的实现

--dhcp.c:动态主机配置协议的实现源码
--dns.c:域名系统的实现源码
--init.c:LWIP协议栈初始化相关的函数,以及一些协议栈配置信息的检查与输出
--mem.c:包括协议栈内存堆管理函数的实现
--netif.c:协议栈网络管理接口相关函数,协议栈支持多个网络接口,如以太网接口,回环接口,这里统一管理
--pbuf.c:协议栈内核使用的数据包管理函数
--raw.c:该文件为运用层提供一种直接和IP数据包交互的方式,类似于socket编程中的原始套接字,同TCP和UDP同一级别,享受IP层提供的服务
--stats.c:包含协议栈内部数据统计与显示相关的函数,如内存使用情况,邮箱,信号量等信息
--sys.c:实现对操作系统模拟层的封装,为协议栈统一提供邮箱,信号量等操作函数,前面提到如果需要使用api文件夹下面的函数,需要操作系统的支持,
这时内核要求移植者提供一个sys_arch.c的操作系统模拟层的文件,完成操作系统中信号量和邮箱的封装,而sys.c有进一步对sys_arch.c中的文件进行封装
以得到具有lwip协议栈特色的邮箱,信号量,如果部不使用操作系统,那么api文件夹下面的函数就不能用,那么sys_arch.c就不需要再实现,那么sys.c就没用了
--tcp.c:包含对TCP控制块操作的函数
--tcp_in.c:包含tcp协议中数据的接收,处理等相关函数,以及tcp状态机
--tcp_out.c:包含数据包的发送以及超时重传函数
--udp.c:包含udp协议的实现

****** include文件夹
--包含了整个协议栈使用的头文件
****** netif文件夹
--包含了与底层网络接口相关的文件
--ppp文件夹:包含点对点传输协议
--etharp.c:包含了地址解析协议ARP实现的相关函数
--ethernetif.c:包含与以太网网卡密切相关的初始化,发送,接收等函数的实现,该文件下的函数只是一个框架性质的,不能直接使用,
移植者需要根据自己的网卡特性来移植这些函数
--slipif.c:SLIP即串行链路IP,移植者需要根据自己使用的串行线路特性,如串口来实现这些函数

*** NETCONN编程接口
**** 基础
***** netbuf
--netbuf:区别于pbuf,netbuf是NETCONN接口API描述数据包的形式,而pbuf是LWIP内核描述数据包的形式,运用程序使用netbuf来管理发送和接收的数据

--netbuf在netbuf.c和netbuf.h中定义,其结构原型如下:
struct netbuf{
	struct pbuf *p,*ptr;
	ip_addr_t addr;
	u16_t port;
}
-->p:指向pbuf链表第一个pbuf结点的指针(头指针)
-->ptr:指向pbuf链表任意pbuf结点的指针(活动指针)
-->addr:发送方的ip地址
-->port:发送方的端口号

-->注意:一个netbuf在使用buf = netbuf_new申请后,用来管理一个使用pt = netbuf_alloc(buf,10)申请的PBUF_RAM类型的pbuf,p指针指向这个被管理的pbuf,pbuf的payload字段指向数据存储区;
但是,如果紧接着又使用netbuf_ref(buf,10)来申请一个PBUF_REF类型的pbuf,而且传递给netbuf_ref的形参和netbuf_alloc一样时,netbuf_alloc申请的数据区将被删除

--无论是tcp连接还是udp连接,协议栈接收到数据包后,会将数据封装在一个netbuf中,并递交给运用程序

--TCP连接:用户只需要提供待发送数据的起始地址和长度,内核会根据实际情况将数据封装在合适的数据包中,并放入发送队列

--UDP连接:用户需要自行将数据封装在netbuf结构中,当发送函数被调用时,内核直接将该数据包中的数据发送出去

--在基于raw/callback API编程时,不同的连接,使用两套互不相关的编程函数,udp_xxx和tcp_xxx,而使用NETCONN API的话,已经对两种不同的连接做了封装,所以
用户可以忽略掉连接类型的差异性,使用统一的连接结构和编程函数即可
***** netconn 
--回调函数是与内核实现交互的唯一方式

--raw/callback API编程时,用户编程的方法就是向内核注册各种自定义的回调函数

--NETCONN API编程时,与内核交互的方式也只能通过回调函数,因此,在api_msg.c中实现了几个默认的回调函数,当,为新的连接创建内核控制块时,这些函数会被默认注册到控制块
中的相关字段,为API与内核协议栈交互提供了保证

--netconn编程接口提供了用户最终调用的函数,一共有21个需要掌握的函数

--netconn在api.h中定义,其结构原型如下:
用于描述连接类型:
enum netconn_type{
	NETCONN_INVALID	= 0,		//无效数据类型
	NETCONN_TCP	= 0x10,		//TCP
	NETCONN_UDP	= 0x20,		//UDP
	NETCONN_UDPLITE = 0x21,		//UDPLite
	NETCONN_UDPNOCHKSUM = 0x22,	//无校验UDP
	NETCONN_RAW	=0x40		//原始连接
}
用于描述连接状态,主要在TCP连接中使用
enum netconn_state{
	NETCONN_NONE,		//不处于任何状态
	NETCONN_WRITE,		//正在发送数据
	NETCONN_LISTEN,		//侦听状态(等待接收)
	NETCONN_CONNECT,	//连接状态
	NETCONN_CLOSE,		//关闭状态
}
NETCONN结构体
struct netconn{
	enum netconn_type type;
	enum netconn_state state;
	union{
		struct ip_pcb *ip;
		struct tcp_pcb *tcp;
		struct udp_pcb *udp;
		struct raw_pcb *raw;
	} pcb;
	err_t err;
	sys_sem_t op_completed;
	sys_mbox_t recvmbox;
	sys_mbox_t acceptmbox;
	int socket;			//实现socket API时使用到
	s16_t recv_avail;
	struct api_msg_msg *write_msg;
	size_t write_offset;
	netconn_callback callback;	//实现socket API时使用到
};
-->上面注释出来的两个变量:socket和callback时提供给socket API编程时使用的,因为socket API基于sequential AP来实现,
所以这两个字段主要为socket API实现提供支持,除了这两个字段之外,其他字段在NETCONN 编程中都扮演着重要角色
-->type:描述了当前的连接类型,可以是TCP,UDP,RAW三种中的一种,根据这个字段的值,来判断调用的是哪类内核函数,如tcp_bind,udp_bind,raw_bind
-->state:描述当前的连接状态,注意,state只是简单的抽象三种类型连接的共有属性,差异性属性需要在各自类型所在的相关函数中处理,同时state不同于TCP状态机中的状态
-->pcb:共用体类型,用来记录 连接相关的内核控制块,包括IP控制块,TCP控制块,UDP控制块,RAW控制块,根据type的不同,pcb中的有效字段也不同
-->err:记录当前连接上,函数调用的结果,用于错误的记录与处理
-->op_completed:由于netconn_xxx函数在投递完毕消息后,便会阻塞掉在连接的这个信号量上,当内核的do_xxx执行完毕后便会释放这个信号量,所以该变量的功能是,
用于两部分API实现同步
-->recvmbox:当前连接的数据接收邮箱,也叫缓冲队列,内核会把所有属于该连接的数据包封装在netbuf里面,然后投递到该邮箱,运用程序调用数据接收函数时,从该邮箱中等待并取得数据包
可能会出现这样的情况,内核将许多数据包投递到该邮箱,但是上层没有调用任何数据接收函数,此时这些数据会一直保存在该邮箱中
-->acceptmbox:在一个TCP连接中,服务器端会使用到该字段 ,内核把所有新建立好的连接结构netconn投递到该邮箱中,服务器端的程序调用netconn_accept函数便会得到一个新的连接结构,
之后就可以在这个新的连接结构上进行通讯操作
-->recv_avail记录当前recvmbox邮箱中已经缓冲好的数据总长度
-->write_msg
-->write_offset:这两个函数主要用在TCP连接上,在数据发送时,如果发送缓冲区不足,则数据会延迟发送,未发送的数据被记录在这两个字段中,在TCP的周期处理函数poll中,或者当TCP在连接上
成功发送数据后,内核会再次尝试发送这些未发送的数据
**** netbuf操作函数(9个)
***** netbuf_new
--函数原型:struct netbuf* netbuf_new(void)
--功能:创建一个netbuf结构
--返回值:返回一个netbuf结构指针,指向创建成功的netbuf结构
--备注:该函数只是创建了一个netbuf结构,为这个结构体分配了一个内存空间而已,并没有为这个netbuf结构体下,p指向的pbuf分配存储空间,真正分配内存空间的是netbuf_alloc函数
--备注2:使用内存池的方式申请
--总结:真正注册一个可用的netbuf需要两步:为netbuf结构体申请空间+为netbuf结构体下面指针指向的数据存储区分配存储空间
--实例:
-> struct netbuf* buf;      //定义一个netbuf结构指针
-> buf = netbuf_new();	    //为netbuf结构体申请内存空间,并返回一个netbuf类型的结构指针	
-> netbuf_alloc(buf,200);   //根据netbuf_new返回的netbuf类型的结构指针,为该netbuf结构下面p指向的数据存储区申请一个200字节用来存储报文
....      		    //完成相关工作
***** netbuf_alloc
--函数原型:void *netbuf_alloc(struct netbuf* buf,u16_t size)
-->buf:netbuf结构指针,该指针应当是netbuf_new函数返回的指针
-->size:打算为netbuf结构下面p指向的数据存储区分配的字节数
--功能:为netbuf结构体下面p指向的数据存储区分配内存
--返回值:返回一个void类型的指针,指向pbuf下面payload指向的地址
--备注:该函数是为netbuf的数据存储区分配内存,为netbuf结构体分配内存需要调用netbuf_new来实现,事实上,应当先调用netbuf_new,再调用netbuf_alloc才能注册到一个可用的netbuf
--备注2:该函数申请的pbuf类型是PBUF_RAM,且分层是PBUF_TRANSPORT,这意味着,该函数在堆上申请数据包存储空间,该函数申请的数据包内存一定有54字节的首部(offset)空间, 该函数
申请的pbuf链表,只有一个pbuf节点,即所有的数据包都存储在一个pbuf上,这是由内存堆分配策略决定的(可分配任意大小的空间),所以netbuf的p和ptr都指向同一个pbuf
--实例:
-> struct netbuf* buf;      //定义一个netbuf结构指针
->char* data;
-> buf = netbuf_new();	    //为netbuf结构体申请内存空间,并返回一个netbuf类型的结构指针	
-> data = netbuf_alloc(buf,200);   //根据netbuf_new返回的netbuf类型的结构指针,为该netbuf结构下面p指向的数据存储区申请一个200字节用来存储报文
....      		    //完成相关工作
->netbuf_delete(buf);      //删除netbuf结构(释放数据存储区以及netbuf结构体所占用的空间) 
***** netbuf_ref
--函数原型:err_t netbuf_ref(struct netbuf* buf,const void* dataptr,u16_t size)
-->buf:netbuf结构指针,该指针应当是netbuf_new函数返回的指针
-->dataptr:用户在任意地址的RAM上自定义的数据存储区
-->size:RAM上这段数据存储区的大小
--功能:为netbuf结构体下面p指向的PBUF_REF类型的pbuf结构申请存储空间
--备注:netbuf下面p指向的pbuf为PBUF_REF类型时,我们知道这种pbuf的特点是,存储区只有pbuf结构体字段,真正的数据字段在pbuf->payload指向的RAM数据存储区,然后内存申请的方式内存池策略
--备注2:该函数申请的pbuf类型是PBUF_REF(MEMP_PBUF),分层为PBUF_TRANSPORT,这意味着,pbuf结构体是在内存池上申请的,pbuf结构体下面的payload指针,需要用户指定,该函数就是通过形参dataptr
来指定数据包存储区的地址的,然后就是, 理论上,数据存储区还会有54字节的首部offset,但是呢,该函数中,虽然分层为PBUF_TRANSPORT,但是并没有根据分层在数据包存储区给出这54字节
实例:
-> struct netbuf* buf;      		//定义一个netbuf结构指针
-> char str[] = "hello world!";  	//在RAM上定义一个字符数组
-> buf = netbuf_new();	    		//为netbuf结构体申请内存空间,并返回一个netbuf类型的结构指针
-> netbuf_ref(buf,str,sizeof(str)); 	//根据netbuf_new返回的netbuf类型的结构指针,为该netbuf结构下面p指向的数据存储区申请一个200字节用来存储报文
....      		    		//完成相关工作
->netbuf_delete(buf);		        //删除netbuf结构(释放数据存储区以及netbuf结构体所占用的空间) 
***** netbuf_free
--函数原型:void netbuf_free(struct netbuf* buf)
-->buf:netbuf结构类型的指针,该指针应当是调用netbuf_new以后返回的指针
--功能:释放掉netbuf结构体下面p指向的数据存储区所占用的内存空间,netbuf结构体占用的内存空间没有被释放
--备注:这意味着buf指针还能使用
***** netbuf_delete
--函数原型:void netbuf_delete(struct netbuf* buf)
-->buf:netbuf结构类型的指针,该指针应当是调用netbuf_new以后返回的指针
--功能:释放掉netbuf结构下面p所指向的数据存储区,同时,释放掉netbuf这个结构体占用的存储区
--备注:该函数是对netbuf真正的释放,不同于netbuf_free只释放数据存储区,而netbuf结构还在,这意味着调用netbuf_delete之后,buf就没法再使用了
***** netbuf_chain
--函数原型:void netbuf_chain(struct netbuf* head,struct netbuf* tail);
-->head:netbuf类型的结构指针
-->tail:netbuf类型的结构指针
--功能:用户注册了两个netbuf,该函数将tail下面的pbuf连接到head下面的pbuf后面,然后将tail删除,简单讲,就是拼包功能
***** netbuf_data
--函数原型:err_t netbuf_data(struct netbuf* buf,void **dataptr,u16_t* len)
-->buf:netbuf结构类型的指针,该指针应当是调用netbuf_new以后返回的指针
-->dataptr:函数调用后,会将netbuf结构下面的ptr指向的pbuf下面的payload指针复制给dataptr,即使,得dataptr也指向当前pbuf下面的数据存储区
-->len:函数调用后,会将netbuf结构下面的ptr指向的pbuf下面的len值复制给len
--功能:读取netbuf结构下面ptr指向的pbuf下面数据存储区的地址,以及pbuf下面数据存储区的字节数
--备注:需要注意,ptr是netbuf结构中的活动指针,可以指向pbuf链表中的任意pbuf,所以,该函数返回的dataptr以及len只是当前(ptr指向)pbuf的数据存储区的地址以及字节数
如果要对pbuf链表中的其他pbuf进行操作,那就需要使用netbuf_next或者netbuf_first来调整ptr指向下一个pbuf节点或者上一个pbuf节点,这通常是必要的,因为我们说一个pbuf
链表才是对一个完整数据包的描述,而一个pbuf节点只是这个数据包中的一部分,尤其是pbuf的存储类型为PBUF_POOL时以及混合类型时,调用net_buf_first和netbuff_first来
调整ptr基本上必须的
***** netbuf_next
--函数原型:s8_t netbuf_next(struct netbuf *buf);
-->buf:netbuf结构类型的指针,该指针应当是调用netbuf_new以后返回的指针
--返回值:当返回小于0时,表示调整失败,因为当前pbuf已经在pbuf链表的尾部,当返回值等于0,表示调整成功,且当前pbuf后面还有pbuf,当返回值大于0时,表示调整成功,且当前pbuf已经是pbuf链表的最后一个pbuf
--功能:我们说一个数据包如果采用PBUF_POOL类型的pbuf时,是用一个pbuf链表来描述这个数据包的,也就是说,一个数据包太大的话会存储在pbuf链表的多个pbuf节点中去
这就意味着需要具备在pbuf链表的各个pbuf节点之间移动的功能
--实例:
do{
	char* data;
	int len;

	netbuf_data(buf,&data,&len);            //获取当前ptr指向的pbuf下面payload指针指向的数据存储区的地址以及该数据存储区的长度  
	....					//对数据进行相关的处理		
} while(netbuf_next(buf) >=0);                  //调整ptr,指向下一个pbuf节点
***** netbuf_first
--函数原型:s8_t netbuf_first(struct netbuf *buf);
--功能:将netbuf结构的ptr指针指向第一个pbuf,即p指向的pbuf,在用户未调用netbuf_next的情况下,ptr与p默认都是指向第一个pbuf的
**** netconn操作函数(13个)
***** netconn_new
--函数原型:struct netconn* netconn_new(enum netconn_type t)
-->t:指明了新连接的的类型,通常为:NETCONN_TCP和NETCONN_UDP,分别代表了tcp连接和udp连接 
--功能:为一个新连接申请一个连接结构netconn空间
--返回值:返回申请到的新的连接的netconn空间的地址
--备注:该函数被调用时,只是新建了一个netconn结构并初始化该结构中的相关字段,并不会有任何连接建立
***** netconn_getaddr
--函数原型:err_t netconn_getaddr(struct netconn* conn,struct ip_addr* addr,u16_t* port,u8_t loacl);
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
-->ip_addr:存储获取到的源ip地址或者目的ip地址
-->port:存储获取到的源端口号或者目的端口号
-->local:标识获取的是源还是目的
--功能:获得一个连接结构netconn中的源IP地址和源端口号或者目的IP地址和目的端口号,是源还是目的,由参数local指定,将获取的结果存储在ip_addr以及addr中
***** netconn_bind
--函数原型:err_t netconn_bind(struct netconn *conn,struct ip_addr* addr,u16_t port);
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
-->ip_addr:本地 ip地址
-->port:本地端口号 
--功能:将连接结构,本地ip地址,本地端口号三者进行绑定,此时本机是作为服务器运行的
--备注:注意绑定的是本地的ip地址和本地的端口号而不是远端的,这个函数的操作是必要的,必须进行端口和ip的绑定后,才能接收客户端的连接请求
--备注2:若要将本机作为服务器,则必须调用该函数进行绑定
***** netconn_connect (供客户端调用)
--函数原型:err_t netconn_connect(struct netconn* conn,struct ip_addr* addr,u16_t port);
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
--功能:将连接结构,远端ip地址,远端端口号三者进行绑定,此时本机是作为客户端运行的
--备注:注意绑定的是远端的ip地址和远端的端口号而不是本地的
--备注2:本机作为TCP客户端时,调用该函数将产生导致三次握手过程的产生,本机作为UDP客户端事,该函数只是简单的设置一下UDP控制块中的remote_ip和remote_port字段
***** netconn_listen(只能用于TCP服务器模式)
--函数原型:err_t netconn_listen(struct netconn* conn);
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
--功能:本机作为服务器,并配置了TCP连接模式,该函数将连接结构netconn置为侦听状态,时刻准备着被客户端连接
--备注:为了接收新连接,调用该函数后,内核会创建一个acceptmbox的邮箱,当有TCP客户端连接本机服务器时,该邮箱会收到一则消息以告知本机服务器,有TCP客户端对我发起了新连接
***** netconn_accept(只能用于TCP服务器模式)
--函数原型:struct netconn* netconn_accept(struct netconn* conn,struct netconn **newconn);
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
--功能:本机作为服务器,并配置了TCP连接模式,本机服务器调用该函数可以从acceptmbox中获得一个新连接,如果邮箱为空,则函数会一直阻塞,直到有新连接的到来
--返回值:当本机服务器调用该函数从acceptmbox获得一个新连接之后,会返回这个新连接的netconn结构地址
--备注:使用该函数之前必须确保已经调用了netconn_listen将本机服务器配置为侦听状态
--实例:
struct netconn *conn,*newconn;
conn = netconn_new(NETCONN_TCP);	//创建一个连接结构
netconn_bind(conn,NULL,80);		//将本地80端口与连接结构绑定
netconn_listen(conn);			//本机TCP服务器开启侦听状态,侦听被TCP客户端连接
newconn = netconn_accept(conn);		//从邮箱中检索新连接,阻塞等待直到检索到新连接
process_connection(newconn);		//使用新连接完成通讯工作
netconn_delete(newconn);		//断开新连接并删除新连接结构
netconn_delete(conn);			//删除conn连接结构
***** netconn_recv
--函数原型:struct netbuf* netconn_recv(struct netconn* conn);
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
--功能:从连接的recvmbox邮箱中接收数据包,接收到的数据包都封装在netbuf中
--返回值:如果从recvmbox邮箱中接收到一个封装在netbuf结构中的数据包,则返回一个指向该netbuf结构的指针
	 如果从邮箱中返回一条空消息(NULL),就表示对方已经关闭了当前连接,此时,运用程序也应当关闭掉这个无效的连接
--备注:该函数被调用后会一直阻塞,直到从邮箱中获取到数据消息,
--实例:
process_connection(struct netconn *conn)
{
	struct netbuf* buf;
	//阻塞,直到接收到非空数据
	while(buf=netconn_recv(conn) != NULL){		//返回值不为NULL,则说明有收到netbuf结构体(数据)
		do_something(buf);
	}
	netconn_close(conn);				//返回值为 NULL,说明对方断开了连接,则本地也执行断开操作
}
***** netconn_send(只能用于UDP的发送)
--函数原型:err_t netconn_send(struct netconn* conn,struct netbuf* buf)
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
-->buf:指出封装在netbuf中需要发送的数据包
--功能:用于已经绑定好远端IP和端口号的UDP连接上发送数据(已经建立意味着UDP控制块里面已经记录了目的IP地址和目的端口号)
--备注:如果分片功能没有开启的话,netbuf中的数据不能超过MTU值,建议不能超过1000字节,如果开启了分片功能则可以忽略数据包的大小
--实例:完成向主机192.168.19.78主机上的7000端口发送2个UDP数据报
struct netconn* netconn;
struct netbuf* buf;
struct ip_addr addr;
char *data;
char text[]="A static text"
int i;

conn = netconn_new(NETCONN_UDP);
IP4_ADDR(&addr,192.168.19.78);		//构造目的IP地址
netconn_connect(conn,&addr,7000);       //由于conn的连接类型是NETCONN_UDP,所以,调用该函数后只是简单的设置一下UDP控制块中的remote_ip和remote_port字段

buf = netbuf_new();
data = netbuf_alloc(buf,10);		//为netbuf结构下数据存储区分配10字节的存储空间
for(i = 0;i < 10;i++){
	data[i] = i;
}	
netconn_send(conn,buf);			//在连接上发送数据

netbuf_ref(buf,text,sizeof(text));	//注意,重新引用了buf,所以netbuf_alloc申请的数据区将会被删除
netconn_send(conn,buf)

netconn_delete(conn)			//删除连接结构
netbuf_delete(buf)			//删除netbuf结构

***** netconn_sendto(只能用于UDP的发送,和netconn_send作用一样,推荐使用该函数,实例未验证!!)
--函数原型:err_t netconn_sendto(struct netconn *conn,struct netbuf* buf,struct ip_add* addr,u16_t port);
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
-->buf:指出封装在netbuf中需要发送的数据包
-->ip_addr:远端ip地址
-->port:远端端口号
--功能:用于未绑定好远端IP和端口号的UDP连接上发送数据
--备注:与netconn_send相比,共同点是都是都用于UDP发送数据,区别是该函数不用再使用netbuf_connect来绑定远端ip和远端端口号,
事实上,使用该函数比使用netconn_send好,因为UDP是无连接的,该函数不用调用netbuf_connect函数,更加能体现出无连接
--实例:
struct netconn* netconn;
struct netbuf* buf;
struct ip_addr addr;
char *data;

conn = netconn_new(NETCONN_UDP);
IP4_ADDR(&addr,192.168.19.78);		//构造目的IP地址

buf = netbuf_new();
data = netbuf_alloc(buf,10);		//为netbuf结构下数据存储区分配10字节的存储空间
for(i = 0;i < 10;i++){
	data[i] = i;
}	
netconn_sendto(conn,buf,&addr,7000);			//在连接上发送数据

netconn_delete(conn)			//删除连接结构
netbuf_delete(buf)			//删除netbuf结构
***** netconn_write(只能用于TCP的发送)
--函数原型:err_t netconn_write(struct netconn* conn,const void *dataptr,size_t size,u8_t apiflags)
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
-->dataptr:待发送数据的起始地址
-->size:待发送数据的字节数
-->apiflags:指出对发送数据采取的处理类型
#define ENTCONN_NOFLAG  0x00
#define NETCONN_COPY    0X01
#define NETCONN_MORE    0x02
-->NETCONN_NOFLAG:内核构造发送数据包时,会引用这些发送数据的内存区域,这种情况下,用户进程不能再对这些数据进行修改,这种方式通常用在静态数据ROM的发送当中
-->NETCONN_COPY:该标志告诉协议栈,将待发送数据拷贝到内核进程所属的内存空间,这种情况下,会消耗系统部分时间和内存资源,但是用户进程可以在向内核递交数据后
立即重新使用这些数据区域,甚至删除这些数据区域,而不必等内核是否完全正确发送.对于非ROM数据的发送,用户应当尽量设置成NETCONN_COPY标志
备注:该函数不要求用户将数据封装在netbuf中,对数据的长度也没有限制,内核将直接处理这些数据,将他们封装在pbuf中,并挂接到发送队列中去
-->NETCON_MORE:组装这些数据的最后一个TCP报文段首部PSH标志将被设置,这样,数据将会在接收端尽快递交给上层而不会缓冲等待
--功能:完成TCP连接上数据的发送
--实例:
process_connection(struct netconn* conn)
{
	char data[10];
	char text[]="static data";
	int i;

	for(i = 0;i < 10;i++){
		data[i] = i;
	}
	netconn_write(conn,data,10,NETCON_COPY);		 //发送data,拷贝
	netconn_write(conn,text,sizeof(text),NETCONN_NOFLAG);    //发送静态数据,不拷贝
	for(i = 0;i < 10;i++){
		data[i] = 10 - i;	//因为内核进程已经拷贝了一份该数据,所以这里可以修改data
	}
	netconn_close(conn);		//关闭连接
}
***** netconn_close(只能用于TCP,关闭一个TCP连接)
--函数原型:err_t netconn_close(struct netconn* conn)
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
--功能:关闭一个TCP连接
--备注:该函数会引起一个FIN握手包的发送,发送成功后函数就返回,剩余的断开握手操作由内核自动完成,用户程序不必关心
--备注2:注意该函数只是断开一个TCP连接,但不会删除连接结构netconn,用户应当调用函数netconn_delete来删除连接结构所占用的
内存空间,否则会造成内存泄露
***** netconn_disconnect(只能用于UDP中断开与服务器的连接)
--函数原型:err_t netconn_disconnect(struct netconn* conn);
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
--功能:该函数将调用udp_disconnect执行UDP的断开操作,所以该函数的功能是在一次与UDP服务器的连接中,断开与该服务器的连接
***** netconn_delete
--函数原型:err_t netconn_delete(struct netconn* conn) 
-->conn:netconn结构类型的结构指针,用于标识操作的是哪个netconn连接,该参数一般是netconn_new函数调用后返回的指针
--功能:如果函数调用时,双方仍然处于连接状态,则相应的连接被关闭
--备注:对于UDP,连接立即被关闭,UDP控制块被删除;对于TCP,函数执行主动关闭,内核完成剩余的断开握手操作,所以,对于TCP来说,执行该函数之后,
内核中的TCP控制块并没有立即被删除,内核将在连接完全断开或者超时后删除
Blog creation time:[2017-09-05 二 08:56]
** DONE [#D] theme:物理层										 :@Blog:@TCP:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:32]
*** 物理层研究的问题
--研究如何屏蔽掉五花八门的硬件形态和通讯形态的差异性,使得比特流在通过这些硬件之后递交到上层数据链路层时,数据链路层感受不到物理层的差异,它就可以专心完成链路层该干的事
--基于上面的目标,物理层的任务就是确定传输媒体(网卡)的规范,如机械特性,电气特性,功能特性,过程特性等,这些规范规定好以后,各大网卡厂商就按照这个规范来定制有自己风格的网卡,
只要符合物理层的规范,那么数据链路层就能承认通过网卡的比特流
--比如本次系统使用的网卡LAN8720就是一个物理层的PHY芯片,依照规范,给出的RJ45引脚用于向外收发数据:发出的数据经过网线,网线的规范也是物理层定义,什么双绞线,同轴电缆,光缆,
T型接头,调制解调器等等都是属于物理层的范畴,对方的网卡RTL8019AS通过RJ45口接收到数据,由于LAN8720与RTL8019AS都符合物理层规范定制的RJ45口,所以RTL8019AS可以接收网线上的数据
--码元传输的速率越高,或者信号传输距离越远,或噪声干扰越大,或传输媒体质量越差,在接收端的波形失真就越严重
*** PHY芯片LAN8720相当于物理层
**** 基础
1.10M/100M以太网PHY层芯片；
2.IO引脚符合IEEE802.3-2005标准；
3.通过RMII接口和SMI接口和STM32F4内置的MAC802.3通讯；
4.内置10-BASE-T/100-BASE-TX全双工传输模块；
5.采用10M还是100M，采用全双工还是半双工，是由LAN8720通过与目的主机自协商来确定，确定出来以后会写到一个寄存器里面，我们可以去读取这个值；
6.支持HP Auto-MDIX自动翻转功能，也就是说当一端的接线接错了，另一端会检测到，然后自动更改已迎合当前接线方式；
7.支持SMI串行管理接口；
8.通过RMII接口和SMI接口和STM32F4内置的MAC802.3通讯；
**** 以太网PHY芯片详解
--PHY是由IEEE802.3定义的，通过SMI接口读写PHY内部的寄存器，从而达到对PHY的管理和控制；
--PHY寄存器的地址空间为5位，2的5次方可以定义共32个寄存器，但是随着PHY芯片功能的增加，寄存器功能不够用，采用分页技术来扩展寄存器，我们不讨论；
--IEEE802.3定义了前16个寄存器的功能，后面16个留给芯片制造厂家自己定义；所有的PHY前16个寄存器的内容是一模一样的，非常重要。
--PHY的初始化内部自己完成，不需要用户自己操作；
--三个重要的寄存器：BCR、BSR、LAN8720厂家自定义的一个特殊功能寄存器（31），这三个寄存器的内容查看STM32F4 LWIP开发手册
--其中，BCR和BSR寄存器中的每一个bit都在在固件库的stm32f4x7_eth.h中定义好了
--LAN8720厂家自定义的一个特殊功能寄存器：在stm32fx7_eth_conf.h里面定义，里面提供了PHY_SR、PHY_SPEED_STATUS、PHY_DUPLEX_STATUS的定义，目的
是用来获取当前网络的连接速度

--MAC只是一个以太网的内核，该内核要想实现物理层和数据链路层的功能，需要外加以太网PHY芯片；
--以太网PHY芯片型号：LAN8720；
--LAN8720作为一个PHY芯片，需要有一个自己的地址，以便能够被SMI接口找到，所以LAN8720有一个引脚：RXER/PHYAD0，该引脚接高电平时，
确定LAN8720这个PHY的地址为0x01,该引脚接低电平时，确定PHY地址0x00,所以，将该引脚悬空不接，就确定了PHY的地址为0x00;
--nINTSEL引脚：
REF_CLK_Out模式：当该引脚为低电平时，则确定nINT/REFCLKO引脚作为REF_CLK时钟源，用于和RMII接口的REF_CLK连接；
REF_CLK_In模式：当该引脚为高电平时，该引脚作为中断引脚；
我们使用的是作为REF_CLK，所以该引脚为低电平；
--LAN8720的时钟：采用的是外接晶振的方式而不是从STM32F4的时钟树上分频而来，外接25MHZ，内部倍频以后达到50MHZ送给nINT/REFCLKO引脚
--LAN8720提供了和RJ45连接的引脚；

MAC内核和PHY之间的通讯：
--SMI接口和RMII接口连线合并起来就构成了MAC和PHY之间的互连接线；
--MII接口和RMII接口的作用是等效的；
--STM32F4的移植中使用SMI接口和RMII接口来实现MAC和PHY的通讯；

SMI接口：站管理接口，用于配置PHY寄存器，最多支持32个PHY的访问
--MDC线:时钟线，最大2.5MHZ，空闲时，为低电平
--MDIO线：数据线，向PHY传输配置数据
备注： 由于SMI站管理接口可以支持管理32个PHY，所以需要一个寄存器来存储PHY的地址，不同的PHY通过不同的地址来选择，LAN8720只是众多PHY中的一个

MII接口：介质独立接口，定义了10Mbit/s或100Mbit/s的数据传输速率下，PHY与MAC的接线规范，有14个引脚
--TX_CLK线:
->这个时钟是由PHY芯片向MAC芯片发送时钟;
->该时钟为10Mbit/s或者100Mbit/s;
->PHY要想在这条线上产生10Mbit/s或者100Mbit/s的时钟，则外部必须先为PHY提供25MHZ的晶振频率，在PHY内部倍频或分频之后产生10/100MHZ；
->这25MHZ的晶振频率可以由STM32F4的MCO引脚输出，也可以给PHY外接晶振产生 
--TXD[3:0]线：
--TX_EN线：
--RX_CLK线：同TX-CLK 
--RXD[3:0]线：
--RX_ER线：
--RX_DV线：
--CRS线:
--COL线：

RMII接口：精简介质独立接口，比起MII，降低了PHY与MAC的接线引脚数，只有7个引脚
--TXD[1:0]
--TX_EN
--RXD[1:0]
--CRS_DV
--REF_CLOCK
备注：
--RMII接口的参考时钟必须是50MHZ
--由STM32F4的MCO引脚输出或者外接晶振25MHZ的晶振到PHY，在PHY内部倍频产生50MHZ给参考时钟
**** 以太网DMA描述符
1.STM32F407有一个专用的以太网DMA；
2.以太网DMA在CPU完全不干预的情况下，通过DMA描述符，将数据从源传输到目标；
3.DMA描述符链表的本质：单向回环链表；
4.DMA描述符链表有两个，一个用于发送以太网数据包，一个用于接收以太网数据包；
5.DMA描述符回环链表的头指针被写入ETH_DMATDLAR寄存器和ETH_DMARDLAR寄存器中；
4.描述符：称DMA描述符链表上的节点为描述符；
5.描述符的作用：描述符用来定义以太网数据包；
6.描述符成分：每个描述符是链表的一个节点，每个节点占用4个字16个字节，第一个字存放状态，
第二个字存放buffer的大小，第三个字存buffer的首地址，第四个字存放下一个描述符节点的地址；
这四个字的bit位信息参看STM32F4xx中文参考手册，注意发送描述符和接受描述符的bit位信息是不同的；
7.描述符中使用buffer count来标记该描述符所定义存储以太网数据包的buffer的大小，所以，当一个
以太网数据包很大，无法被此描述符的buffer存储时，该以太网数据包将跨越到下一个描述符；
8.一个DMA描述符只能用于一个以太网数据包，所以当一个以太网数据包很小，而当前描述符定义的
buffer又很大，该以太网数据包将会独占整个buffer，剩下的buffer，下一个以太网数据包是不能用的；
9.描述符的分类：描述符有常规描述符和增强描述符，这两种描述符又有发送描述符和接受描述符；

*** 动态内存管理
**** 概述
--TCP/IP协议栈需要处理大量的数据,这些数据需要有一种机制来组织管理
--LWIP提供了两种基本的内存管理机制:动态内存池管理;动态内存堆管理
--内存分配的本质:对于一块给定的内存池,提供一种管理机制,能够描述,记录该内存池里面哪些内存空间已经被分配,哪些空间未使用,当调用者需要某一大小的内存空间时,
该机制能够合理的从内存池里面划出一块空间给调用者,当用户不需要某一内存块时,机制能将该内存块放回内存池
--内存管理的指标:分配时间和分配效率

--内存分配的两种机制:
-系统每次从内存池的高地址的空闲块中进行分配,而不理会已经分配给用户的内存区是否已经释放,当分配无法进行,即从高地址已经找不到用户指定大小的
空间时,系统才逐渐去检查以前分配给用户的空间是否已经释放,同时系统将已经释放的内存再重新组织成一个大的可用空闲块,以满足用户的内存分配请求;
-一旦用户释放之前申请的内存空间,系统便将已经释放的内存空间标记为空闲,每当用户申请内存时,系统就会依次遍历整个系统中的空闲块,找出一个符合用户申请大小的块,并返回
该块的首地址给用户
备注:常见的分配策略是第二种,LWIP的内存管理使用的也是该方法

--内存分配的三种策略:
第一种:动态内存池分配策略
-系统规定好,用户在申请内存时必须为某几个固定值大小,如4B,8B,16B,32B,64B,128B 256B,1K,2K,16K,128K等,否则系统不给分配
-系统将内存池按照预设的给定大小类型进行划分,每种大小类型的划分给定的数目
-用链表将不同大小类型的给定数目的内存块链接起来,比如16B类型的划分了7块,这7块16B的内存块被链表链接起来就构成了16B这种类型的链表,其他大小的类型的也用同样的方法
这样就有了很多个不同大小类型的链表,每个链表之间都是独立的
-用户可使用的那几个固定大小的类型与系统划分内存时给出的链表类型是保持一致的
-分配内存时,根据用户指定的类型,直接到该类型的链表下取出链表的第一个结点的地址返回给用户即可
-释放内存时,直接将需要释放的内存空间插入到对应链表的首部即可
特点:分配时间短,分配效率高,但是由于用户能分配的大小只能是固定给出的那几个类型,所以显得很拘束,同时内存浪费比较严重,但是这种策略在LWIP中其实是比较实用的,因为
LWIP中如TCP,UDP等这样的协议的数据报首部的字节数都是固定的,用来存储他们,既高效又实用

第二种:
-内存池的划分同第一种的策略一样,当然程序稍微有一些独特的优化
-用户申请内存的大小不必与内存池划分以后所组织的各个不同链表的结点大小保持一致
-分配内存:用户提出任意大小字节的内存申请时,系统去查找各个链表的大小类型,找出一个最接近用户申请大小且能满足需求的这么一个链表,从里面取内存空间
-释放内存时,直接将需要释放的内存空间插入到对应链表的首部即可
特点:分配时间短,效率高,用户申请内存的大小随意,但是内存浪费越加严重

第三种:可变长度的内存分配,有首次拟合,最佳拟合,最差拟合三种策略
**** 动态内存池分配策略
--动态内存分配的策略是一种简单,高效的策略,其最大的优点是申请内存和释放内存的速度较快,且不产生内存碎片,缺点是只能申请固定大小空间
--TCP/IP协议栈中数据报的特点是:数据报具有确定的格式,报头字节数固定,传输数据报对时间要求极度苛刻
--TCP/IP协议栈数据报的特点决定了应在协议中使用动态内存分配策略

--源文件:memp.c和memp.h提供了动态内存分配策略的具体实现

--LWIP内核在初始化时就已经为每种数据结构类型都初始化了一定数量的POOL

--LWIP中常见的POOL的数据结构类型:
-MEMP_UDP_TCB:当opt.h中的宏LWIP_UDP置1时,在编译程序时,就会建立与UDP控制块数据结构相关的内存池POOL
-MEMP_TCP_TCB,MEMP_TCP_SEG:当opt.h中的宏LWIP_TCP置1时,在编译程序时,就会建立与TCP数据结构相关的内存池POOL
-MEMP_PEASSDATA:当opt.h中的宏IP_REASSEMBLY置1时,在编译程序时,就会建立与IP分片,重装j数据结构相关的的内存池POOL
-MEMP_PBUFF_POOL:专门存放网络数据包的POOL
-MEMP_CUSTOM_POOLS:动态内存堆分配策略借助动态内存池分配策略时需要用到的POOL
备注:对于上面这些数据结构类型的POOL,其单个大小是固定的,但是用户可以根据实际的使用情况在lwipopts.h中进行配置,若不配置,则使用opt.h中的默认选项

--动态内存池分配策略的物理分布规律:a个A数据结构类型的POOL链接在一起存放在内存池的开始,紧接着,b个B数据结构类型的POOL链接在一起存放在其后,依次类推,直到瓜分完整个内存池为止

--与LWIP内存池相关的6个全局变量:
-memp_t:枚举类型变量,用来给每种数据结构类型的POOL链表取一个名字,在memp.h中定义
typedef enum{
	#define LWIP_MEMPOOL(name,num,size,desc) MEMP_##name,     //既定义LWIP_MEMPOOL函数,又描述了memp_t枚举成员,
	#include "lwip/memp_std.h",    //该头文件下,当满足各种条件宏时,将调用LWIP_MEMPOOL()函数并传递具体参数,具体的形参传递函数时,在调用函数的同时,还构建了NEMP_##NAME,以形成memp_t枚举 
	MEMP_MAX    //该类型不代表任何数据结构类型的POOL,但是由于枚举类型的值是自动递增1的,所以该变量代表一共开启了多少种"数据结构类型"的POOL链表
} memp_t;
-------->展开结果:
typedef enum{
	MEMP_RAW_PCB,
	MEMP_UDP_PCB,
	MEMP_TCP_PCB,
	MEMP_TCP_PCB_LISTEN,
	MEMP_TCP_SEG,
	......
	MEMP_MAX
} memp_t;

-memp_tab[]:全局指针数组,指向每种数据结构类型的POOL链表的第一个POOL,在memp.c中定义
static struct memp* memp_tab[MEMP_MAX];  //每种数据结构类型的POOL链表都有好几个该类型的POOL组成,其中POOL链表的第一个POOL的地址存放在这里 

-memp_sizes[]:全局数组,用来记录每种数据结构类型的POOL链表中,每个POOL的大小
const u16_t memp_sizes[MEMP_MAX]={
	#define LWIP_MEMPOOL(name,num,size,desc) LWIP_MEM_ALIGN_SIZE(size),	//定义了函数LWIP_MEMPOOL,该函数被调用时,将构建LWIP_MEM_ALIGN_SIZE函数的size,并调用该函数,取得返回值,作为数组memp_sizes[]的成员
	#include "lwip/memp_std.h"   //该头文件下,当满足各种条件宏时,将调用LWIP_MEMPOOL()函数并传递具体参数,具体的形参传递给函数时,还构建了LWIP_MEM_ALIGN_SIZE函数
}
-------->展开结果:
const u16_t memp_sizes[MEMP_MAX]={
	LWIP_MEM_ALIGN_SIZE(sizeof(struct raw_pcb)),
	LWIP_MEM_ALIGN_SIZE(sizeof(struct udp_pcb)),
	LWIP_MEM_ALIGN_SIZE(sizeof(struct tcp_pcb)),
	LWIP_MEM_ALIGN_SIZE(sizeof(struct tcp_pcb_listen)),
	LWIP_MEM_ALIGN_SIZE(sizeof(struct tcb_seg)),
	......
}
备注: LWIP_MEM_ALIGN_SIZE用来进行内存对齐,对齐到4的倍数上去

-memp_num[]:全局数组,用来记录每种数据结构POOL链表中,POOL结点的个数,可在lwipopts.h中由用户自定义,在opt.h中有默认值
const u16_t memp_num[MEMP_MAX]={
	#define LWIP_MEMPOOL(name,num,size,desc) (num),   //定义了函数LWIP_MEMPOOL,该函数被调用时构建(num)
	#include "lwip/memp_std.h"    //该头文件下,当满足各种条件宏时,将调用LWIP_MEMPOOL()函数并传递具体参数,具体的形参传递给函数时,还构建了(num)
}
-------->展开结果:
const u16_t memp_num[MEMP_MAX]={
	(MEMP_NUM_RAW_PCB),
	(MEMP_NUM_UDP_PCB),
	(MEMP_NUM_TCP_PCB),
	(MEMP_NUM_TCP_PCB_LISTEN),
	(MEMP_NUM_UDP_SEG),
	......
}

-memp_desc[]:全局指针数组,用来指向每种数据结构POOL链表中POOL结点的描述符,在memp.c中定义,只有使能LWIP_DEBUG功能才有效
static const char memp_desc[MEMP_MAX]={
	#define LWIP_MEMPOOL(name,num,size,desc) (desc),   //定义了函数LWIP_MEMPOOL,该函数被调用时构建(desc)
	#include "lwip/memp_std.h"    //该头文件下,当满足各种条件宏时,将调用LWIP_MEMPOOL()函数并传递具体参数,具体的形参传递给函数时,还构建了(desc)
}
-------->展开结果:
static const char memp_desc[MEMP_MAX]={
	("RAW_PCB"),
	("UDP_PCB"),
	("TCP_PCB"),
	("TCB_PCB_LISTEN"),
	......
};
备注:这些字符串在统计信息中输出时,可能会用得到

-memp_memory[]:真正的内存池,但是使用自己的内存分配sram_alloc替代这个大数组 memp_memory 
static u8_t memp_memory[MEM_ALLGNMENT-1  
#define LWIP_MEMPOOL(name,num,size,desc) (desc)+((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))#include "lwip/memp_std.h"
]
----->替换为:u8_t *memp_memory;

LWIP内存池管理函数
--内存初始化函数:memp_init()
--内存申请:memp_malloc()
--内存释放:memp_free()
备注:这三个函数由LWIP内部内核调用,用户不会调用到,在opt.h里面将MEMP_MEM_MALLOC置1,则与内存池策略相关的代码memp.c就不会被编译,会用内存堆策略来替代
**** 内存堆分配策略
--内存堆策略可以申请任意内存大小的空间

--该方法相比内存池策略,效率较低,频繁申请释放的话会造成严重的内存碎片

--内存堆限制了用户申请内存的最小字节:MIN_SIZE,默认12字节 

--内存堆策略下的内存空间:ram_heap[]

--内存堆策略相关的3个函数:
--内存初始化函数:mem_init()
--内存申请:mem_malloc()
--内存释放:mem_free()
备注:这三个函数由LWIP内部内核调用,用户不会调用到,在opt.h里面将MEM_LIBC_MALLOC置1,会禁用LWIP的内存堆策略而使用ANSI自带的malloc和free来替代,默认是置0的
*** 数据包管理
**** 基础
--TCP/IP协议栈作为一种通讯机制,本质上就是对各层协议的数据包进行处理

--链路层判断接收到的数据包类型,提取数据包中的数据字段,记录主机物理地址信息

--网络层的IP协议根据IP数据报中的IP地址实现数据的存储,转发,根据IP数据报的编号,实现IP数据报的重组,并提取其中的有关数据,向上层递交数据包并记录递交结果

--TCP使用数据包中的信息更新TCP状态机,并向运用层递交数据

--在上面的描述过程都与数据包操作密切相关,数据包管理在整个协议栈的实现中至关重要

--在UNIX中,描述和管理数据包的结构叫做mbuf,在LWIP中,也有一个数据包管理结构叫做pbuf

--数据包管理结构pbuf合理运用了动态内存管理机中的内存池策略和内存堆策略

--pbuf十分重要,因为用户在编写程序时,经常跟它打交道

--LWIP数据包的类型五花八门,如:
-从网卡上接收的原始数据包,可以是TCP报文段,也可以是ARP数据包
-上层可能将千奇百怪,五花八门的数据递交给LWIP内核发送,这些数据可能位于内存,也可能位于FLASH,SD卡,U盘等
备注:核心的问题是,数据在各层之间传递时,应当极力避免数据的拷贝工作,以避免耗费大量的时间开销和空间开销,所以,LWIP必须有一个高效的数据包管理核心,它就像
海纳百川似的,将五花八门的数据包类型收集起来同一管理,同时还能避免内存拷贝问题,读到这里,肯定感受到这个数据包管理结构究竟肩负着怎样的使命了吧,说它怎么重要
都不为过,这个神奇的数据包结构就是:pbuf
 
**** 剖析pbuf结构体
--首先,pbuf是一个管理LWIP里面所有数据包类型的一个高效的,可避免内存拷贝的结构体

--pbuf包管理器在pbuf.c和pbuf.h中实现

--pbuf结构体:
struct pbuf{
	struct pbuf* next;     //pbuf结点的指针域,指向下一个pbuf结点
	void* payload;         //数据指针,指向真实的数据包缓冲区
	u16_t tot_len;         //当前pbuf及后续所有pbuf中管理的数据的总字节数
	u16_t len;	       //当前pbuf中管理的数据的字节数	 
	u8_t type;	       //当前pbuf的类型
	u8_t flags;	       //状态位,没有使用到
	u16_t ref;	       //标识当前pbuf被引用的次数	
}
-->next:实际发送或接收的数据包可能很大,一个pbuf可能存不下,所以,一个数据包可能需要多个pbuf来描述,这些个pbuf链接在一起构成该数据包的pbuf链表,即一个pbuf链表唯一描述一个数据包
-->payload:在RAM或者ROM空间中可能有一块存储区,该存储区用来存储pbuf管理的某数据包类型(由pbuf结构体的type字段决定)的数据,该存储区的地址会被存放在payload字段
-->tot_len:一个数据包可能很大,一个pbuf管理不了,需要多个pbuf管理,构成当前pbuf链表,tot_len描述的是,从当前pbuf开始,到最后一个pbuf(尾结点),所有有效数据字节数之和,
其意义是:包含当前pbuf在内,还剩多少字节的数据没有处理,显然,tot_len等于当前pbuf的len字段和下一个pbuf的tot_len字段之和
-->len:当前pbuf中,payload指向真实的数据包存储区,len就记录了这个存储区中数据包实际的字节数
-->type:LWIP中各种数据包的类型被归结为4类,type就是标记为这四类数据包类型中的哪一类
-->flags:lwip的内核源代码中未使用到,提供给用户使用的,初始化pbuf时,该字段设置为0
-->ref:标识当前pbuf被引用的次数,其他pbuf中的next字段指针可以指向当前pubf,也就是说当前pubf被其他pbuf中的next字段或者头指针引用,所以,初始化pbuf时,ref被设置为1,当然了,
除了头指针以及其他pbuf里面的next字段可以引用该pbuf之外,其他的指针也可以引用该pbuf,只是在每次引用的时候需要将ref的值加1

--pbuf的四类数据包类型:
typedef enum{
	PBUF_RAM,
	PBUF_ROM,
	PBUF_REF,
	PBUF_POOL(实际上是MEMP_PBUF_POOL和MEMP_PBUF的统称,作为参数传递时应该是这两个而不是PBUF_POOL) 
} pbuf_type;

-->PBUF_RAM:pbuf结构+数据包缓冲区,即,数据包缓冲区在pbuf结构之后,且他们两都位于内存堆中,这意味着,在内存堆中为该类型申请空间,其大小应当是pbuf结构体的字节数+待分配数据包缓冲区字节数
数据包缓冲区是通过内存堆的策略分配得到的,由于是在内存堆中分配,所以,可以取得任意大小的空间来满足数据包的需求,该类型的pbuf是协议栈的用得最多的,协议栈以及运用程序待发送数据一般
都采用该类型,下面是源码中分配PBUF_RAM的原型:
p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN(length))
其中:SIZEOF_STRUCT_PBUF是pbuf结构体的字节数,offset是数据包的各种首部字段,如TCP报文首部,IP首部,MAC帧首部等等具体数值是多少,与数据包的申请方式有关,length是待分配的数据包缓冲区字节数
注意:在内存堆的物理空间上,pbuf结构体,offset空间,数据包缓冲区空间是依次有序的连续存储在内存堆中的

-->PBUF_POOL:pbuf结构+数据包缓冲区,即,数据包缓冲区在pbuf结构之后,且他们俩都位于同一内存池中,由于使用的是内存池策略,所以该类型的pbuf可以在极短的时间内申请到,值得一提的是内存池策略
是将a个A数据结构类型的POOL链接在一起放在内存池的开始,紧接着,b个B数据结构类型的POOL链接在一起存放在其后,依次类推,直到瓜分完整个内存池为止,每种数据类型的POOL大小都是固定的,这就是说,
一个给定的数据包,在某数据结构类型的POOL下,一个POOL可能不够存,需要几个POOL才行,该类型的pbuf在网卡接收数据包时使用,下面是源码中分配PBUF_POOL的原型:
p = memp_malloc(MEMP_PBUF_POOL)
注意:这里有两个容易弄错的点,第一,memp_nalloc是内存池申请空间的函数,不像大多数内存申请函数一样传递一个字节数作为参数,该函数传递的是一个类型;第二,这里的类型不是PBUF_POOL
而是,MEMP_PBUF_POOL
一定要注意,系统在初始化时, 会初始化两类与pbuf密切相关的POOL,分别是MEMP_PBUF和MEMP_PBUF_POOL,这两个合起来称为PBUF_POOL,这两个之间是有区别的,MEMP_PBUF_POOL
类型申请到的空间不仅包含pbuf结构体,还包含数据空间,而MEMP_PBUF类型申请到的空间只包含pbuf结构体,MEMP_PBUF类型的大小恰好是一个pbuf结构体大小,这是LWIP专门为PBUF_ROM和PBUF_REF量身打造的
说明:申请MEMP_PBUF_POOL类型的pubf时,协议栈会在内存池中选择一个固定大小的PBUF链表,链表中POOL结点的个数,可在lwipopts.h中由用户自定义,数据包就存在这些POOL结点中,但是存储需要符合下面的
规范:第一个POOL,pbuf结构体+offset+数据包,其余POOL,pbuf结构体+数据包,注意,第一个POOL中,由于数据包是从这个POOL开始存储的,所以数据报的首部需要单独的空间,其余的POOL,是用来存第一个POOL
存不完的数据,所以没有头部,各个POOL使用pbuf中的next字段连接起来,由于每个POOL的长度都是固定的,所以最后一个POOL的空间有一部分可能会浪费掉

-->PBUF_ROM:数据包存储于ROM中,其存储方式是在内存池中申请一个MEMP_PBUF类型的POOL,上面说了,MEM_PBUF类型的POOL空间只包含pbuf结构体,不包含数据包存储区,pbuf结构里面的payload指针指向
ROM空间的某段数据,在发送某些静态数据(static)时,可以使用这种类型,可以大大节省协议栈的空间,下面是源码中分配MEM_PBUF的原型:
p = memp_malloc(MEMP_PBUF)
注意:MEMP_PBUF类型的大小恰好是一个pbuf结构体的大小,这是LWIP专门为PBUF_ROM和PBUF_REF量身打造的

-->PBUF_REF:数据包存储于任意RAM中,与pbuf结构所处的位置无关,其存储方式是在内存池中申请一个MEMP_PBUF类型的POOL,MEM_PBUF类型的POOL空间只包含pbuf结构体,不包含数据包存储区,
pbuf结构里面的payload指针指向RAM空间中的某段存储区,下面是源码中分配MEM_PBUF的原型:
p = memp_malloc(MEMP_PBUF)
注意:MEMP_PBUF类型的大小恰好是一个pbuf结构体的大小,这是LWIP专门为PBUF_ROM和PBUF_REF量身打造的

备注:pbuf这四种数据包的类型,不同的类型规定了pbuf结构体下面payload指针指向的数据包缓冲区的物理存储位置(RAM,ROM),分配方式(内存堆,内存池),上面的四种数据包类型除了单独使用,还可以任意
两个搭配起来组成一种混合的类型,如可以讲PBUF_RAM类型和PBUF_REF组合起来,也可以将PBUF_RAW类型与PBUF_ROM组合起来

友情提示:理论上,接收数据包就使用MEM_PBUF_POOL类型,发送数据包:如果有首部的话(网络层,链路层中内核会用),只能使用PBUF_RAW类型,如果没有首部的话(传输层用户传输数据),还可以用PBUF_REF类型

**** 数据包申请函数
--数据包申请函数在系统的很多地方都会用到,如网卡接收数据时,一般情况下需要申请一个MEMP_PBUF_POOL类型的POOL链表,然后将网卡中的数据填入到POOL链表中各个POOL,
再比如发送数据包,在LWIP的不同的分层中,都需要传输数据包,在相应的层,一般情况下,协议会申请一个PBUF_RAM类型的pbuf,并将这一层的数据报装载到申请到的pbuf的数据区,
这一层的首部信息就被装载到pbuf的offset字段

--不同层中,申请pbuf的细节还不同,主要体现在offset字段,不同层的有不同的协议,不同协议有不同首部,所以需要枚举一下有哪些层,好加以区分:
typedef enum{
	PBUF_TRABSPORT,    //传输层
	PBUF_IP,           //网络层
	PBUF_LINK,         //链路层
        PBUF_RAW,          //原始层,不预留任何首部空间(offset = 0)
} pbuf_layer;

PBUF_TRANSPORT_HLEN;     //典型TCP报文首部长度,20字节
PBUF_IP_HLEN; 		 //不带任何选项字段的IP首部长度,20字节

--数据包申请函数原型:
struct pbuf* pbuf_alloc(pbuf_layer layer,u16_t length,pbuf_type type);
其中:
-->layer:指定为哪个层申请pbuf,分配函数会根据该值在pbuf数据区预留出首部空间;
-->length:指明需要申请pbuf的字节数,如果为PBUF-RAM,则是pbuf结构体字节数+offset+数据域字节数,如果是MEM_PBUF_POOL,则是POOL链表的总字节数
-->type:指出需要申请的pbuf类型,一般有:PBUF_RAW,PBUF_POOL(MEMP_PBUF_POOL),PBUF_REF(MEMP_PBUF),PBUF_ROM(MEMP_PBUF)四种类型
过程解析:首先根据layer来决定pbuf数据区offset字段预留的长度(PBUF_RAW不用预留),然后根据type字段进行空间的申请,值得注意的是如果类型type为PBUF_REF和PBUF_ROM,那么,用户需要自己去
配置pbuf结构中的payload指针,通常在调用完毕该函数之后,接下来应当立即将payload指针指向某个区域

实例1:p = pbuf_alloc(PBUF_RAW,packLength,PBUF_POOL)
解析:该实例的layer使用的是PBUF_RAW,意味着,申请到的pbuf的数据区的前面不会预留任何首部空间,同时pbuf的type是PBUF_POOL,意味着,程序将根据packLength去决定需要为POOL链表申请几个POOL结点
通过p->payload,就可以实现对pbuf中数据区的读取或者写入操作了

实例2:p = pbuf_alloc(PBUF_TRANSPORT,packLength,PBUF_RAM)
解析:该实例的layer使用的是PBUF_RAW,意味着,申请到的pbuf的数据区的前面将会预留出54字节(TCP报文段首部长度20+IP数据报首部长度20+MAC帧首部长度14)首部空间,同时pbuf的type是PBUF_RAM,
意味着,pbuf是在内存堆上申请的,pbuf结构体和offset和数据区连续存储;这里之所以将各个层的offset都预留出来是为了避免内存的拷贝,数据包交付时,直接操作这个pbuf的offset就行而不必复制内存

--数据包释放函数原型:
u8_t pbuf_free(struct pbuf* p)
-->p指向将要被删除的那个pbuf
-->该函数被调用时,会通过p去检查p->type,来判断是那种类型pbuf:内存池还是内存堆,然后决定是调用memp_free还是mem_free来进行释放
备注:当数据包在向上层或下层交付完毕后,释放pbuf是必须的,这样才能保证系统内存不被耗尽

--数据包被释放的前提:
-pbuf的ref字段标识被当前pbuf引用的次数,当pbuf被创建时,该字段的初始值为1,代表被引用一次
-删除pbuf时,函数首先将ref减1
-只有当ref字段为0时,该pbuf才可以被删除
-注意,能被删除的pbuf必然是某个pbuf链表的首结点,或者是在其他地方未被引用过的结点,用户使用数据包释放函数时,必须注意这一点,因为,
如果用户错误的调用数据包释放函数,释放了pbuf链表中,某个未在其他地方被引用的中间结点,可能导致严重的错误,如pbuf_free(p+1)是错误的

--数据包释放的过程
-某个pbuf链表的首结点被删除成功后,该pbuf链表的第二个结点就变成了该链表的首结点,且该pbuf结点的ref值可能变为0(因为没有在其他地方引用,且只是被已经删除的首部结点使用过),
此时,该结点也会被删除,因为LWIP会认为它是和第一个结点一起存储同一个数据包,当第二个pbuf结点被删除之后,又会去查看第三个是否满足删除条件,就这样一直删除下去.当然,如果检查到
某个pbuf结点的ref大于0,那就表示该结点在其他地方还被引用,就不能删除该节点,删除工作至此结束

--数据包释放实例:pbuf链表有A,B,C三个pbuf结点,其ref的值分别如下:
-->1->2->3 调用释放函数后 ..1->3
-->3->3->3 调用释放函数后 2->3->3
*** 网络接口管理
**** 基础
--LWIP嵌入式设备可以有多个网络接口:以太网接口,串行链路接口,环回接口等

--为了实现对不同网络接口的统一管理,LWIP内核使用一个netif的网络接口结构来描述各种网络设备,在UNIX中也有这么一个结构体,不过名字叫ifnet

--网络接口管理属于链路层的部分,其目的主要是实现对具体的网络硬件,软件的统一封装,并为IP层提供统一的接口服务

--netif接口:一个目标系统上,可能同时存在多个网络接口:多个网卡,多个串行网络接口(串口),环形接口等,为了管理这些接口,LWIP会为每一个接口分配一个netif结构,
不同接口的netif结构结构描述不同接口相关的特性,这样看来,netif接口是将所有不同的网络接口进行差异性封装后的产物

--netif接口注册函数:LWIP在每个netif的内部注册了该接口相关的操作函数:数据包发送函数output,数据包接收函数input

--netif_list链表:每个netif结构管理一种接口,LWIP内核将所有的netif结构体组织在一起构成一个netif_list链表,方便内核统一管理

--IP数据包的发送:IP层根据目的IP地址,在netif_list中选择一个合适的netif接口,并调用该netif接口中注册好的数据包发送函数output,将IP数据包从该netif接口发送出去

--IP数据包的接收:netif接口收到一个数据包时,会调用该netif接口中注册好的数据包接收函数input,完成数据包的接收

备注:从数据包的发送和接收,不难看出,netif接口屏蔽掉了1个IP数据包和多个网络接口之间一对多的关系,因为LWIP内核将多个网络硬件集中在一个管理并进行差异化处理,提供一个netif接口
给IP层,IP层是感受不到多个网络硬件的差异性的,IP层只用和netif接口打交道就好
**** 深度剖析netif接口
--netif接口实现的源代码在netif.c和netif.h中

--netif接口原型:
struct netif{
	struct netif* next;
	struct ip_addr ip_addr;
	struct ip_addr netmask;
	struct ip_addr gw;
	err_t (*input)(struct pbuf* p,struct netif* inp);
	err_t (*ouput)(struct netif* netif,struct pbuf* p,ip_addr* ipaddr);
	err_t (*linkoutput)((struct netif* netif,struct pbuf* p);
	void* state;
	u16_t mtu;
	u8_t hwaddr len;
	u8_t hwaddr[NETIF_MAX_HWADDR_LEN];
	u8_t flags;
	char name[2];
	u8_t num;
	struct pbuf* loop_first;
	struct pbuf* loop_last;
}
-->next:LWIP内核维护了一个netif_list链表用来管理所有的netif接口,next指向的是链表中当前netif结点的下一个netif结点
-->ip_addr:该网络接口的IP地址,IP地址是和网络接口一一对应的,即有几个网络接口(netif结点),就得有几个IP地址
-->netmask:该网络接口的子网掩码,每个netif都有一个netmask,用来判断某个目的IP地址是否与当前netif接口的IP地址在同一子网中,如果在同一子网,才去判断IP数据包的目的IP地址是否就是该netif
接口的ip地址
-->gw:该网络接口的网关,每个netif都有一个gw,IP层数据包广播到netif_list时,netif_list在自己所管理的众多netif接口中查找是否有与该IP数据包的目的ip在同一子网的网络接口,如果没有的话,
协议会将该IP数据包转发到该netif接口gw指向的ip地址处去,因为,它认为网关处会对这个ip数据包实现正确的转发
-->input:指向一个函数,这个函数需要解析MAC帧然后从MAC帧中提取IP数据报,然后将网络接口收到的数据包递交给IP层,这个函数有两个类型的参数:pbuf,netif,pbuf指明要递交的数据包,netif指明递交
到哪个网络接口
-->output:指向一个函数,该函数供IP层调用,IP层需要发送数据时,就会去查找netif_list链表, 找到合适的netif接口之后就会调用output来将数据包发送出去
-->linkoutput:指向一个函数,该函数的功能和output差不多,只是更底层一些,在以太网通讯中,该函数被ARP模块调用,用来实现MAC帧的发送,在其他网络中该字段就每什么用了
-->state:记录设备信息,用户可自由发挥
-->mtu:标识该网络接口最大可以传输数据包的字节数,以太网一般设置为1500,在IP层发送数据包时,会使用该参数来判断是否需要将数据包分片,如果IP送过来的数据包没有分片而大于这个参数,
则,网络接口netif可能将数据包丢弃,也可能做底层分包,但是底层分包会打乱ip数据包的内部结构,所以为避免底层分包,IP层必须提供分片机制
-->flags:网络接口的状态,包含许多重要的控制位,例如,当flags字段中的NETIF_FLAG_UP没有使能时,如果收到一个IP数据包,则认为这个数据包是无效的
-->name:用于保存网络接口的名字
-->num:网络接口编号,netif_list中的每个netif接口都有一个编号,用于唯一标识该接口
-->loop_first和loop_last:指向pbuf链表的第一个pbuf和最后一个pbuf,以实现对数据包的管理

--几个重要的网络接口管理函数:
-struct netif* netif_add(struct netif* netif,struct ip_addr* ipaddr,struct ip_addr* netmask,struct ip_addr* gw,void* state,err_t (*init)(struct netif* netif),err_t (*input)(struct pbuf* p,struct netif* netif))
备注:该函数用于向系统注册一个网络接口设备,即向netif_list中加入一个netif结点
-->

Blog creation time:[2017-09-05 二 08:56]
** DONE [#D] theme:数据链路层									 :@Blog:@TCP:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:32]
*** 数据链路层研究的问题
--网卡收通过RJ45网口收到IP数据报之后,在RMII接口的控制下,通过SMI接口将IP数据报交付给MAC内核,MAC内核将IP数据报封装成MAC帧,并将PDU提取出来放置到以太网专用的2k的RX_FIFO中去

--数据链路层完成IP数据报在物理线路的传输时的封装,传递问题

--TCP/IP协议支持多种不同的链路层,依赖于使用的网络硬件类型,如,有线局域网:以太网,城域网:有线电视和DSL连接,有线语音网:电话网,
无线网络:无线局域网WI-FI等等,这里主要研究的是以太网的数据链路层
--在TCP/IP协议中,设计数据链路层的目的是:为IP模块发送和接收数据报
--链路层的协议数据单元(PDU),通常称为帧,这是为了和网络层的PDU,分组,以及传输层的PDU,段,分别开来,帧,分组,端都是PDU在不同层的专用术语
--帧,通常是可变帧,范围从几个字节到几千个字节,称范围的上限为最大传输单元:MTU
--在局域网中,我们说的硬件地址,物理地址,MAC地址,适配器地址,适配器标识符,EUI-48,MAC-48,链路层地址,802地址等,说的是同一个东西 
--标识系统:在所有计算机系统的设计中,标识系统是一个非常种要的问题,地址,就是用来识别一个系统的
--标识系统模型:who <--> where <--> how
--who:MAC地址,告诉我们,哪台主机
--where:IP地址,告诉我们,系统当前的所在地
--how:路由,告诉我们,如何到达该处
*** CSMA/CD协议,即MAC协议
--CSMA/CD:带冲突检测的载波侦听多路访问协议,要理解这种协议记得从下面的以太网的结构说起
--话说在1980年的时候,DEC(美国数字设备),Inter,Xerox(施乐)三大公司首次发布了以太网标准,1982年加以修订
--这就是第一个常见格式的以太网,目前称为10Mb/s以太网或者共享以太网,这套标准专门为身为局域网的以太网量身定做
--IEEE采纳了该标准并收录了这套局域网以太网标标准,并命名为IEEE802.3标准

--这种共享以太网的结构是:
-多个工作站(如计算机)被连接到一个共享的电缆上
-各个站检测目前网络上目前正在发送的信号
-当某个站监听到介质为空闲时,它就发送自己的帧
-如果多个站同时发送,就可能会发生碰撞,当检测到碰撞时,发送站就会等待一个随机时间然后再次尝试(分布式算法),尝试16次后超时
-采用CSMA/CD协议传输数据,要求在任何给定时间内,网络中只能有一个帧传输
-满足上面访问方式的CSMA/CD协议称有一个正式的名,介质访问控制协议,MAC协议,这句话的意思是CSMA/CD协议还有其他访问方式,所以
MAC协议也有很多类型,总之CSMA/CD协议其实就是MAC协议

--随着10Mb/s以太网的发展,基础设施的完善,以太网的速度变得更快,值得一提的是,20世纪90年代初的时候,共享电缆被双绞线替代
--双绞线又叫做10BASE-T
--后来还出现了被称为快速以太网的100BASE-T

--基于竞争的MAC协议不再流行,出现了另一种专用的以太网星型拓扑结构,这种结构的特点是
-各个工作站(如计算机)被连接到一个交换机的端口上
-交换机以双工的方式运行,且不需要使用CSMA/CD算法,即交换机为每个工作站提供同时发送和同时接收数据的能力
-交换机和交换机之间级连,就构成了更大的以太网
*** MAC地址格式
--MAC地址,由802.3帧格式规范,与系统所在地无关,全球统一定义,由IEEE802.3为局域网规定的48位地址,固化在系统适配器的ROM中
--windows下使用ipconfig/all可查看
--硬件地址,物理地址,MAC地址,适配器地址,适配器标识符,EUI-48,MAC-48,链路层地址,802地址等,说的是同一个东西
--802.3标准对MAC地址的记法为:每一个字节的最低位(LSB)放在最左边,最高位(MSB)放在最右边,例如某MAC地址的第一个地址为D8:11011000,LSB为0,次LSB为0
--第一个字节的LSB位:I/G位,当I/G位为0,地址字段表示单个地址,当I/G位为1时,表示组地址,用来进行多播(组播)
--如果一个MAC地址是单个地址类型,那么,说明这个MAC地址与网络上一个特定的站有联系
--如果一个MAC地址是组地址类型,那么,说明这个MAC地址是一个多重地址,它与给定网络上的一个或多个站有联系
--有两种类型的多播地址:多播组地址,广播地址
--第一字节的次LSB位:G/L位:当G/L位为0时是全球管理,保证在全球没有相同的地址,当G/L位为1时,是本地管理,此时,用户可以任意分配网络上的地址,应当指出,以太网几乎不使用这个G/L位
--IEEE的注册管理机构RA是局域网全球MAC地址的法定管理机构(W-IEEERA),它负责分配MAC地址字段的6字节中的前3字节24位,世界上的所有想要生产
局域网适配器的厂家都得向它购买这三个字节构成的号,所以前3个字节称为组织唯一标识符OUI,也叫公司标识符,后面3个字节叫做扩展标识符,厂家
在配置扩展标识符的时候必须保证不能重复,用这种方式得到的地址称为MAC-48或者EUI-48
--网络适配器:也就是我们说的网卡,MAC地址是固化在网卡的RAM里面的,网卡从RJ45口每收到一个MAC帧就先用硬件检查MAC帧中的目的MAC地址,如果是发给自己的,就收下,如果不是,就丢弃
--前面说过,路由器也是计算机,所以路由器内部也有适配器,路由器通过适配器连接到局域网时,适配器上的MAC地址就用来标识该路由器的某个接口
--网卡从RJ45口收到的帧有三种类型:单播帧,广播帧,多播帧
--单播帧:该MAC帧是发送给某个MAC地址的,该MAC帧的目的MAC地址指出要发送给谁
--广播帧:该MAC帧是某个站向整个局域网以广播的形式发出的,局域网里面的每个人都会收到(需配置)
--多播帧:该MAC帧是某个站向整个局域网以广播的形式发出的,局域网里面有一部分人能够收到
--所有的网卡都应当识别单播地址和广播地址,有的网卡可以用编程的方法识别某些多播地址
--网卡还可以设置为混杂模式,网卡工作在混杂模式时,只要监听到局域网上有帧,它就会悄悄的接收下来,这样的方式实际上是在窃听其他站点的通讯而不中断它,黑客常用该方法非法获取网上用户的口令
但是,网络管理员可以用该方法来监视和分析局域网上的流量,比如网络嗅探工具就是居于此原理,所以网络嗅探工具需要网卡工作在混杂模式下来能正常使用

*** 以太网(802.3)帧格式
--以太网由802.3规范定义,所以以太网的帧都是基于802.3规范给出的同一个格式
--在研究以太网帧时,IEEE引进一个新的术语,IEEE分组,所以说以太网帧的时候也就是在说IEEE分组,有时候以太网帧也叫MAC帧
--一个以太网帧的基本大小是64~1518字节,标准将其扩展到64~2000字节(增加了信封帧)
--最小长度:以太网帧的最小帧长是64字节,有效载荷长度在无标签的情况下最下48字节,最小长度是非常重要的一个参数
--MAC帧循环冗余校验(CRC校验)的验证方式:发送方首先使用模2除法将扩展消息除以生成多项式,把余数的补码放到4字节的FCS区,接收方在收到消息之后采用
同样的方法计算出余数的补码,然后与收到的MAC帧里面的FSC比较,若不匹配,则传输过程中帧受损,该MAC帧将被丢弃

--以太网帧格式:(从左到右的顺序)
-前导码:7字节,接收器电路用它确定一个帧到达的时间,并确定编码位之间的时间量,由于以太网是一个异步局域网,即以太网接口卡中不保持精确时钟同步,
所以,从一个接口到另一个接口编码位之间的间隔可能不同,所以,前导码是一个公认的模式,典型值是0xAA,接收器接收到SFD时,就使用这个前导码恢复时钟
-帧起始分隔符:SFD,固定值为0xAB,用于被接收器发现,然后好使用前导码恢复时钟
-目的MAC地址:告知"who",即发送给谁,具体参看MAC地址格式
-源MAC地址:告知"who",即谁发出的帧,具体参见MAC地址格式
-长度或类型:当字段值小于或等于1500,表示长度,当字段值大于或等于1536,表示类型,多数情况下,该字段用来确定头部后面的数据类型,常见类型有:
IPv4:0x0800,IPv6:0x86DD,ARP:0x0806,Q标签帧:0x8100,注意,如果该字段为0x8100,那么表示该帧携带802.1q标准的VALN ID或虚拟局域网
-P/Q标签:略
-其他标签:略
-上层协议有效载荷:放置上层PDU的,如IP数据报,传统上,该数据区的典型大小为1500字节,代表了以太网的MTU,而MAC帧给出的范围是0~1982,
所以,该数据区会被填充数个0,以确保长度符合最小长度的要求
-FCS字段:帧校验序列,存放循环冗余校验(CRC校验)后的校验值,4字节
*** STM32F407自带的MAC内核相当于数据链路层
--MAC一方面和专用FIFO打交道,一方面和物理层的PHY打交道,下面聊一聊MAC内核的那些事
--和物理层PHY通讯时,支持10Mbit/s和100Mbit/s的传输速率
--和物理层PHY通讯时,支持IEEE802.3的MII接口规范
--支持半双工和全双工操作,如半双工操作的CSMA/CD协议,提供背压流量控制,全双工操作的IEEE802.3x流量控制,流量控制输入信号消失时,自动发送零时间片暂存帧,
将接收的暂停控制帧转发到用户运用程序
--在发送路径中插入报头和帧的起始数据(SFD),在接收路径中将其删除
Blog creation time:[2017-09-05 二 08:57]
** DONE [#D] theme:网络层										 :@Blog:@TCP:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:32]
*** 网络层研究的问题
--网络层完成数据包选择和路由,负责将数据包从源主机发送到目标主机

--网络层把网络接口层产生的报文等长度划分为数据段,在将数据段的前面加上首部构成分组
--由于网络层和网络层之后的数据传输都是以分组的形式传输的,在网络层使用了IP协议封装报文划分后的数据段,所以分组也叫IP数据报,或者包
*** IP地址结构
**** IP基础
--连接到Internet上的每一个设备都需要有一个IP地址,该地址指明该设备的物理位置(where),在网络中传输数据时,源IP地址表明数据从哪来,目标IP地址表明数据到哪去
--IP路由器的转发程序使用IP地址来识别流量的去向,IP地址也表示流量的来源
--IP地址在运用层通常被DNS屏蔽在用户视线之外
--一台设备接入全球性的Internet中时,为它分配的IP地址需要具有经过协调,使得该IP地址是全球唯一的
--IP地址由ICANN(因特网名字与号码指派机构)进行分配,该机构把部分地址空间委托给各种区域性的权威机构，然后这些权威机构又将IP地址分配给ISP和其他的公司,
个人用户再向ISP支付费用来获得IP地址和执行路由;
--IP地址目前有两种类型:IPv4和IPv6,其中IPv4是较为流行的
--IPv4地址有4个字节组成,所以IPv4地址有4个组,每个组的范围是0~255,组与组之间用.隔开,显然,这四个字节总共可以描述2^32个IP地址:42.94967亿,也就是说,
全球可以同时使用IPv4地址连接到Internet的设备只能有不到43亿台,一人一个IP都分不到,所以IPv4的地址是不够用的,每个IP都用上,这还是最理想的情况,实际糟糕的情况下面有介绍;
由于IPv4地址不够用,所以才有了后来的IPv6

--IPv4地址类型:单播地址,广播地址,组播地址,任播地址,其中单播地址占据IPv4地址空间的绝大多数
--单播地址:由网络号和主机地址构成,其中网络号标识该IP地址在哪个网络中可以被发现,所以在因特网中,网络号是唯一确定的,主机号:标识网络中特定的主机;
--广播地址:略
--组播地址:高4位为1110标识该地址是一个组播地址,组播地址没有网络号和主机号的划分,整个32bit位构成一个组播地址
--任播地址:略

**** IP划分
--现实中,存在多种不同网络,如,因特网,电信网,有线电视网,而且每种网络拥有的主机设备的数量也不同,每台主机设备都需要一个唯一的IP地址,所以需要对IPv4地址空间内的所有IPv4进行
划分:A类,B类,C类,D类,E类,划分的依据是:根据不同的网络,现在或预计将来的主机数量
--A类,B类,C类地址都属于单播地址,D类地址属于组播地址,E类地址保留
--A类地址:单播地址,网络号占据前8个bit位,MSB位为0表示该地址为A类地址,剩余7位自由,所以,可描述的网络数为2^7=128;
主机号占据24个bit位,所以,主机数为2^24=16777216;不难得出:A类地址的范围是:0.0.0.0 ~ 127.255.255.255
--B类地址:单播地址,网络号占据前16个bit位,最高两位为10表示该地址为B类地址,剩余14位自由,所以,可描述的网络数为2^14=16384;
主机号占据16个bit位,所以,主机数为2^16=65536;不难得出:B类地址的范围是:128.0.0.0 ~ 191.255.255.255
--C类地址:单播地址,网络号占据前24个bit位,最高三位为110表示该地址为C类地址,剩余21位自由,所以,可描述的网络数为2^21=2097152;
主机号占据8个bit位,所以,主机数为2^8=256,不难得出C类地址的范围是:192.0.0.0 ~ 223.255.255.255
--D类地址:组播地址,最高四位为1110表示该地址为D类地址,剩余28位自由,所以D类地址的范围是:224.0.0.0 ~ 239.255.255.255
--E类地址:保留,最高四位为1111表示该地址为E类地址,剩余28位自由,所以E类地址的范围是:240.0.0.0 ~ 255.255.255.255

--上面提到IPv4不够用的问题,理想情况是不到43亿个IP都能充分使用,不过这是不可能的,原因是:由于网络环境的复杂性,笼统的管理整个IPv4地址空间在技术层次是做不到的,
所以,解决的方案就是对整个IPv4地址空间,依照不同网络,现在或预计将来的主机数量进行类别的划分,该方案确实实现了对整个IP地址空间的管理,但是引入的问题就是IP使用效率下降,
原因不难理解,某个公司申请了一个C类网段:192.168.19.x,该网段规定了可以提供255个IP,如果这个公司只有100台电脑需要接入网络,那么有155个IP地址就浪费掉了,
因为除该公司外的任何人都不可能使用到该网段的IP地址,而如果该公司有300个人,那么IP肯定不够用,解决方案有两个,第一个是:再申请另一个网段192.168.18.x,这样的话,有210个IP浪费掉了,
第二个方案是:放弃掉C类的192.168.19.x,去申请一个B类的网段:128.168.19.x,这样的话该网段就可以有65536个可使用的IP,且不说300个员工的规模能否申请到这个网段的IP,如果说老板很有钱,也
有关系搞到了这么一个网段来用,那么,就会有65236个IP就浪费掉了,这就是上面说的,为什么43亿个IPv4无法充分使用的原因了

**** 可变长度子网掩码VLSM
--子网掩码的作用:子网掩码表征一个32bit位的IP地址中,网络号和主机号各自占据的位数

--子网掩码的生成:子网掩码和IPv4地址位数一样,从左到右,对比IP地址中,将网络号对应的位全部填充1,主机号对应的位全部填充0,就生成了一个子网掩码

--子网掩码的意义:决定了IP地址的网络号位数;决定了两个IP是否在同一网段;根本上提供了子网划分的手段;

--边界子网掩码:每个IP地址都对应一个子网掩码,但是我们重点讨论的是边界上的子网掩码,因为边界子网掩码决定了子网之间的边界,事实上,边界子网掩码就是默认子网掩码

--默认子网掩码:子网掩码是根据IPv4地址的网络号与主机号的情况填充1或0而形成,对IPv4地址空间的划分形成5类IP,每一类的IP(D,E除外)都定义好了网络号的位数以及主机的位数
这两个位数具有特别的含义,它有"范围中最大"的意思在里面,比如,C类网络,网络号占据24位,主机号占据8位,这就是说C类网络最大能表示2^24个网络,每个网络最大能有2^8个主机,
不要轻视最大的含义,这就是说网络号在0~24,主机在0~8之间都是合法的,取24位网络号和8位网络号,按照子网掩码的生成方法就可以制作出C类网络的边界子网掩码了,也就是C类网络的
默认子网掩码,当然,A,B的推理同理,下面给出A,B,C的默认子网掩码:
-A类网络的默认子网掩码:255.0.0.0       
-B类网络的默认子网掩码:255.255.0.0
-C类网络的默认子网掩码:255.255.255.0       

--最终目的:根据实际情况得出不同子网的子网掩码,是子网划分的最终目的.比如,某公司从因特网申请到一个C类网段,也就拥有了225个IP地址,该公司想针对自己部门的情况,把这255个IP地址
划分为3个子网,每个子网的IP数根据各个部门的人数情况而定,人数决定了IP中的主机字段,相应的也就决定了网络号字段,也就决定了最终的子网掩码以及整个IP的网络标识

--网络子网标识符:IP地址与子网掩码按位与操作,形成的结果称为,网络/子网标识符,该标识符可以用来判断两个网络是否属于同一网段

--子网的表示方法:网络标识符/网络号位数,如:192.168.19.192/26,通过该子网可以得出以下信息:该子网属于C类网络,所以有24位原生网络号;该子网有26个网络号,说明8位主机字段中扩展了
2位作为子网字段,剩余6位描述主机,该子网有2^6-2=62个主机,所以子网掩码为255.255.255.192

--子网掩码由主机或路由器使用,用于确定如何从一台主机对应的IP地址获取网络号以及子网信息,即确定一个32个bit位的IP地址从哪个bit位到哪个bit位是网络/子网号,哪个bit到哪个bit是主机号

--IP子网掩码与对应的IP地址长度相同,为32位

--IP子网掩码的配置方式可以静态:手动配置,也可以是动态:DHCP模式

--IP子网掩码纯碎是站点(网络,网段)内部的局部问题,因特网路由系统的其余部分不需要子网掩码的知识,因为站点之外的路由器做出决策是基于IP划分的网络号,不需要网络/子网或主机部分
**** 子网划分
--现状:从IPv4地址空间的划分来看,不难发现,A类网络只可以有128个,依据规定,A类网段下可以有多达1677万个IP,差不多是深圳或香港的总人口数,能使用这样规模的IP的组织可不多,
那究竟是哪126个人霸占了这126个网段呢,后面有给出参考;B类网络可以有1.63万个左右,依据规定,B类网段下可以有6.5万左右的IP,这样的规模,一些大学,大公司,研究所能搞到;
C类网络可以有209万个左右,依照规定,C类网段下可以有256台主机,这就是一些小公司以及普罗大众可以使用的网络

--为什么需要子网划分:一切看上去都那么美好,可是实际并非如此,一个显而易见的问题是,通过IP的划分,因特网中一共可以有的IPV4网络数量为:A类(2^8) + B类(2^16) + C类(2^24) =  211.3664万个
因特网通过网络号(网段)来唯一标识哪个网络,但是呢,每个网络里面依据IP划分类别的不同,少则有256台主机,多则有1677万台主机,实际使用时,好比上级给每个部门发了一个蛋糕,但是上级不负责
为部门的每一个员工切分蛋糕,这256个IP或者1677万个IP就是这个蛋糕,部门需要自己来决定怎么切分这个蛋糕,所以需要将这么多的IP根据实际情况(如部门分类)再划分为一些子网,以满足实际需求

--子网寻址的思想:该方法的核心思想是因特网通过IP类别划分中的网络号(网段)来识别具体是211.3664万个网络中的哪一个,然后由该网络(网段)的拥有者(公司)来进一步管理该网络(网段)
下的所有主机IP,实际上就是在"IP划分"以后的"主机字段"中,根据实际使用的主机情况,进一步划分出子网号,和主机数,这样做的好处在于,第一,没有改变IP划分的结构,第二,因特网只用考虑哪个网段就行,
至于该网段下怎么来划分这些IP,则交给该网段的拥有者来使用子网掩码进行划分子网即可

--子网寻址的必要性:诸如A类网络和B类网络有大量主机需要管理,因此需要将这些主机划分开来,分别管理:
-情形一:某公司申请到了一个B类网络,最大可以有65536个主机IP,该公司有这多的IP,所以可能希望拿出6000个划分给工程部,2000个给研发部,4000个给行政部,1000个给人力资源部,
40000个给销售部,剩下12536的给生产部,这些网络之间互相独立管理,构成该公司整个B类网络子网
-情形二:某研发中心成立后,员工规模在400人左右,需要接入因特网,每个员工都享有一台主机,该研发中心由中科院管辖,其网络受中科院的管理中心管理,而中科院有一个B类网络,此时,中科院可以
在该网段中划分一个子网给该研发部门使用

--子网划分的焦点:在主机字段,而不在子网ID字段,因为子网ID表征该子网还可以再进行划分子网的个数,我们已经从A,B,C类网络划分了一次子网,不必要再从子网划分子网了,所以,关注的
焦点应该是主机字段,根据不同情况具体需要的主机数来确定该占用多少个bit的主机位,然后用32减去主机位得出网络号占据的位数,然后求出子网掩码,然后目的就达到了

--子网结构:子网号IP+用户子网IP+广播IP,构成一个子网,所有子网构成某一网段,所有网段构成IPv4地址空间

--子网划分经典案例:(以主机数为依据,给出子网掩码和子网标识)
    某公司在因特网中申请到了一个C类网络(网段),用于组建自己的网络,该网络的网络号为192.168.19.0/24,即IP地址范围为:192.168.19.0 ~ 192.168.19.255共256个IP
目前该公司有5个部门需要组建自己的网络,即需要划分5个子网,所以,用户可以使用的IP只有256-10=246个,下面是这些部门的设备的情况:
注意:子网标识和子网广播IP不包含在内; 
销售部:100台计算机,为其分配128-2=126个IP,即主机号占据7个bit位,网络号就占据32-7=25个bit位,所以:
       子网标识为:192.168.19.0/25,起始IP为:192.168.19.1,终止IP为192.168.19.126,子网广播IP为192.168.19.127,子网掩码为:255.255.255.128
技术部:60台计算机,为其分配64-2=62个IP,即主机号占据6个bit位,网络号就占据32-6=26个bit位,所以:
       子网标识为:192.168.19.128/26,起始IP为:192.168.19.129,终止IP为192.168.19.190,子网广播IP为192.168.19.191,子网掩码为:255.255.255.192
工程部:20台计算机,为其分配32-2=30个IP,即主机号占据5个bit位,网络号就占据32-5=27个bit位,所以:
       子网标识为:192.168.19.192/27,起始IP为:192.168.19.193,终止IP为192.168.19.222,子网广播IP为192.168.19.223,子网掩码为:255.255.255.224
生产部:10台计算机,为其分配16-2=14个IP,即主机号占据4个bit位,网络号就占据32-4=28个bit位,所以:
       子网标识为:192.168.19.224/28,起始IP为:192.168.19.225,终止IP为192.168.19.238,子网广播IP为192.168.19.239,子网掩码为:255.255.255.240
行政部:10台计算机,为其分配16-2=14个IP,即主机号占据4个bit位,网络号就占据32-4=28个bit位,所以:
       子网标识为:192.168.19.240/28,起始IP为:192.168.19.240,终止IP为192.168.19.254,子网广播IP为192.168.19.255,子网掩码为:255.255.255.240     
备注:最后一个子网掩码比较特殊不要弄错,其实只要知道子网掩码是刻画一个32bit位的IP地址中,网络号所占bit位数以及主机所占bit位数,结合上面讲过的子网掩码的生成过程,就能理解了

--判断两个子网是否在同一网段:
    已知,两个子网IP,192.168.19.237/28和192.168.19.249/28,请分析这两个子网IP是否在同一个网段:
-->依据:子网标识符是判断两个IP是否在同一网段的唯一证据,子网号相同的两个IP就在同一网段,否则就不在同一网段
-->192.168.19.237/28是一个C类网络,立即推出网络号位数为24位,而该IP的网络号位数为28位,说明从C类网络的主机字段拿出了4位来作为子网划分,所以,该IP的子网掩码是:255.255.255.240
-->192.168.19.249/28是一个C类网络,立即推出网络号位数为24位,而该IP的网络号位数为28位,说明从C类网络的主机字段拿出了4位来作为子网划分,所以,该IP的子网掩码是:255.255.255.240
-->子网号等于IP地址与子网掩码的位与:192.168.19.237 & 255.255.255.240 = 192.168.19.224/28 ; 192.168.19.249 & 255.255.255.240 = 192.168.19.240/28
-->由于子网号192.168.19.244/28 不等于 192.168.19.240/28,所以这两个IP不在同一网段

--子网划分的特点:
-子网字段和主机字段是由站点指定的,而不是由网络号分类决定
-子网字段和主机字段由站点管理员根据自身需求情况进行分配,比如,该站点拥有的是一个B类网络,网络号占了16位,剩下的16位由站点管理员来划分,假设该站点是中科院所有,中科院下面有16个研发机构,
8所附属大学,4所国际学术交流中心,2个国家专项项目组,中科院旗下的这30个组织互相之间独立,每个组织使用一个单独的网络,而且,这个30个组织中主机最多的是大学,有1800台电脑需要联网,
主机最少的是国家专项项目组,只需要20台电脑需要联网,基于这样的情况,中科院的这个B类网络大概可以这样划分,子网/主机部分的16位中,使用5位用作子网号,2^5=32,可以划分32个子网,够30个组织使用,
剩下的11位作为主机号,2^11-2=2046,每个子网可以拥有2046个子网IP(注意,当前子网的第一个地址和最后一个地址不能使用),够中科院所有组织中电脑最多的大学,1800台电脑同时使用
**** 广播地址
--从上面子网划分中,每个子网中都划分出了子网广播地址,这种地址的特点是,主机字段的所有bit位全部为1
--子网广播也被称为定向广播
--广播地址的作用:广播地址发出的IP数据报可以发送给子网中的所有IP主机

--已知某一子网IP地址为192.168.19.149/26,求该子网的广播地址:
-->依据:子网掩码取反之后同子网IP地址进行或运算,得到的IP就是该子网的广播地址
-->由192.168.19.149/26推导出该子网IP的子网掩码为:255.255.255.192
-->将子网掩码取反之后为:0.0.0.63
-->广播地址为:0.0.0.63 | 192.168.19.149 = 192.168.19.191 

--子网广播涉及网络安全问题,所以至今因特网仍然禁止使用子网广播,即RFC2644标准规定,路由器现在默认禁止转发子网广播,甚至完全省略支持能力 

--本地网络广播:有一个特殊用途的IP地址:255.255.255.255被保留为本地网络广播,它根本不会被路由器转发

--注意:目前路由器虽然可能不转发广播,但是,除非被中断明确禁止,子网广播和同一网络中的本地网络广播将工作,这是因为这种广播不需要路由器,如果存在这种广播的话,链路层的广播机制会支持他们

--广播地址通常与某些协议一起使用,如TCP,UDP,ICMP

--IPV6中没有任何广播地址,IPv6仅仅适用于组播地址
**** 网关
--用来配置两个不同网段的主机之间通讯
--网关实质上就是路由器
--路由器里面有路由表,路由表里面记录了当前主机所在网络的地址和下一跳路由器地址的两种信息
--一个IP数据报经过该路由器时,会去查找路由表,如果当前主机所在网络与下一跳路由器地址在同一网段,则直接交付IP数据报;如果当前主机所在网络与最近的下一链路不在同一网段,则将IP数据报
转发到下一路由器
--网关地址:我们经常需要配置一个网关地址,当IP数据报传输到某设备,如果在该设备上的所有网络接口中都找不到与IP数据报携带的IP地址在同一网段的IP,则该IP数据报会被转发到网关地址去
因为,它认为网关设备会对这个ip数据包实现正确的转发

--网关为设备提供许多高级服务:DHCP,DNS
**** 是谁霸占了A类地址:
3.0.0.0/8：通用电气
6.0.0.0/8：美国国防部
9.0.0.0/8：IBM
11.0.0.0/8：美国国防部
12.0.0.0/8：AT&T贝尔实验室
13.0.0.0/8：施乐
15.0.0.0/8：HP
16.0.0.0/8：DEC
17.0.0.0/8：苹果
18.0.0.0/8：MIT
19.0.0.0/8：福特汽车
22.0.0.0/8：美国国防部
23.0.0.0/8：APNIC（亚太地区）
24.0.0.0/8：APNIC
25.0.0.0/8：英国国防部
26.0.0.0/8：美国国防部
27.0.0.0/8：亚太地区NIC
29.0.0.0/8：美国国防部
30.0.0.0/8：美国国防部
32.0.0.0/8：ARIN（北美等地）
34.0.0.0/8：ARIN
35.0.0.0/8：ARIN
36.0.0.0/8：APNIC
42.0.0.0/8：APNIC
49.0.0.0/8：APNIC
55.0.0.0/8：波音
56.0.0.0/8：邮政局
58.0.0.0/8：APNIC
59.0.0.0/8：APNIC
60.0.0.0/8：APNIC
61.0.0.0/8：APNIC
110.0.0.0/8：APNIC
111.0.0.0/8：APNIC
112.0.0.0/8：APNIC
......
直到
126.0.0.0/8：APNIC
之后大部分都是IANA保留，微软、SUN这些之后的网络巨头却不在这当中，可能是没有抢到吧,哈哈,同时这里面一些公司早已倒闭或者被兼并

世界上四个掌管IP地址分配的四个组织：
APNIC (Asia Pacific Network Information Centre) - 亚太地区
ARIN (American Registry for Internet Numbers) - 北美、南部非洲
LACNIC (Regional Latin-American and Caribbean IP Address Registry) – 拉美和加勒比海地区
RIPE NCC (Réseaux IP Européens) - 欧洲、中东、中亚、北部非洲


中国所获得的IPv4地址情况：
大陆IPv4地址总数为74,391,296个，合4A+111B+31C
台湾IPv4地址总数为16,280,064个，合248B+106C 
香港IPv4地址总数为06,288,640个，合95B+245C 
澳门IPv4地址总数为00,144,640个，合2B+53C

**** 是谁有幸使用B类地址:
*** ARP协议
**** 基础
--ARP只是在IP地址和MAC地址之间做映射,它的ARP帧并不封装其他协议的数据报或者被其他协议数据报封装

--MAC帧里面包含了IP数据报,真正待发送的数据被协议栈封装在了ip数据报的载荷字段,数据经过ARP后IP数据报被抽取出来在网络中传输,到达目的主机之前在封装在MAC帧里,再由协议栈识别MAC帧

--在IPv4网络中,数据的交付都是以IP数据报的形式进行的,该交付过程除了需要知道交付给谁(who:MAC地址),还需要知道
交付到哪里(where:IP地址),所以,需要使用ARP协议实现在IP地址和MAC地址之间的映射

--地址解析是发现两个地址之间的映射关系的过程,ARP协议提供了从网络层32位逻辑IP地址到数据链路层48位物理MAC地址的动态映射,之所以说是动态映射,
那是因为ARP操作与用户或系统管理员是无关的,无需手动配置

--ARP工作在正常模式下,仅仅只适用于广播网络,链路层能将一个消息交付到它连接的所有网络设备,在非广播网络下,则需要更复杂的映射协议

--提供ARP方向操作的是RARP,逆地址解析协议,用于缺少磁盘驱动器的系统,目前已经很少使用

--数据链路层提供了一个MAC帧,该帧里面有2个48位的MAC地址,用来定位该MAC帧是由哪台主机发出的,要发送给哪台主机,该帧的数据区存放了IP数据报

--IP数据报被封装在了MAC帧里面,IP数据报中提供了源IP地址和目的IP地址,用来定位该MAC帧是从哪发出的,要发送到哪里去

--路由器提供远程访问的桥梁,通过路由器可以实现远程IP数据报的转发,当然在局域网(以太网)内可以直接交付IP数据报而不需要通过路由器

--请求方自己有一个IP,应答方自己也有一个IP,请求方通过给出应答方的IP来请求和应答方的通讯

--请求方的IP地址和MAC地址,应答方的IP地址都已经知道,还缺应答方的MAC地址不知道,所以,除应答方的MAC地址外,其余3个都会被封装在MAC帧里面

--请求方在子网中广播封装了目的IP的MAC帧,请求数据报被广播到了子网内部的所有网络设备,只有IP为目的IP的网络设备会回应请求方,实际上回应的就是自己的MAC地址

--请求方在收到响应方回答的MAC地址之后,记录在内存中,以供以后使用

--发送方现在可以将响应方的MAC地址,封装到MAC帧里面,将要发送的IP数据报也封装在MAC帧里面,给响应方发送数据报

--ARP缓存:ARP协议会去维护每个主机和路由器上的路由表(ARP缓存),该缓存提供每个主机网络层IP地址到数据链路层MAC地址的最新映射,之所以说是最新映射,是因为一组IP<-->MAC地址
映射的生命是20分钟

**** ARP帧格式
--前14个字节构成标准的以太网头部
-DST:6个字节,目的MAC地址,标识发送给谁,对于ARP请求,因为还不知道对方的MAC地址,所以填充全1,即填充一个广播地址,给网络中的每个设备都发送ARP请求
-SRC:6个字节,源MAC地址,标识谁发出的,对于ARP请求,填充自己的MAC地址
-长度或类型:2个字节,当字段值小于或等于1500,表示长度,当字段值大于或等于1536,表示类型,多数情况下,该字段用来确定头部后面的数据类型,常见类型有:
IPv4:0x0800,IPv6:0x86DD,ARP:0x0806,Q标签帧:0x8100,注意,如果该字段为0x8100,那么表示该帧携带802.1q标准的VALN ID或虚拟局域网
由于这里是标识ARP请求,所以该字段必须为0x0806

--硬件类型:2个字节,指出硬件地址类型,对于以太网,该值为1

--协议类型:2字节,指出映射的协议地址类型,对于IPv4地址,该值为0x0800,当MAC帧包含IPv4数据报时,该字段可能与MAC帧的类型字段一致

--硬件大小:1字节,指出硬件地址的字节数,对于以太网中使用IPV4地址的ARP请求或应答,该值为6,因为MAC地址占6个字节

--协议大小:1字节,指出协议地址的字节数,对于以太网中使用ipv4地址的arp请求或应答,该值为4,因为IPv4地址栈4个字节

--OP:该字段指出操作类型:1,ARP请求;2,ARP应答;3,RARP请求;4,RARP应答

--发送方MAC地址:与以太网头部中的DST重复

--发送方协议地址:对于IPV4,为发送主机的IP地址

--目的MAC地址:与以太网头部中的SRC不同,对于ARP请求,该字段填充0而不是1

--目的协议地址:对于IPV4地址,为目的主机的IP地址

备注:当某主机收到一个ARP请求时,该主机首先填充自己的硬件地址:SRC,然后将发送方MAC地址与目的MAC地址互换,将发送方协议地址与目的协议地址互换,将OP字段设置为2(应答),然后响应ARP请求
*** IP协议
**** IP协议基础
--IP是TCP/IP协议族中的核心协议,所有TCP,UDP,ICMP,IGMP都是通过IP数据报(分组)传输的
--IP提供的是一种尽力而为,无连接的数据报交付服务,尽力而为的含义是,不保证IP数据报能成功到达目的地
--IP不是简单的丢弃所有不必要的流量,例如,当一台路由器临时用尽了缓冲区时,IP提供的处理方案是,丢弃掉最后到达的一些数据报
--IP的交付不可靠,任何可靠的交付都由传输层的TCP协议提供
--IP提供无连接服务,这意味着IP不维护路由器中的任何链接状态信息
--IP数据报之间都是独立的,这意味着IP数据报的交付可不按照顺序交付
--同一主机先后发出的两个IP数据报A,B在网络中传输,A和B可以独立路由,B可以在A之前先到达目的主机,A或B可以在传输过程中发生损坏,而IP的上层TCP需要处理这些意外错误
--IP协议给每一台联网设备规定一个地址,确定where参数
--IP数据报可以被分片,每个分片自身仍然是一个独立的IP数据报,总长度字段反应具体的分片长度

**** IP分组格式:(IPv4)
IP头部字段:
-版本字段:4个bit位,标识IPv4或IPv6:当字段值为4,表示该IP分组是IPv4,当字段值为6,表示该IP分组是IPv6,注意,这两个协议是不能互相操作的,所以主机或者路由器必须分别处理,称为双栈
-Internet头部长度:IHL,4个bit位,用于保存ipv4头部中32位字的数量,所以,ipv4的头部中最多可以有15个32位字,即60字节,这个字段的正常值是5
-区分服务字段:DS,6个bit位,该字段用于支持Internet上不同类型的服务,IP数据报通过预定义模式设置某些位,来转发不同的数据报
-阻塞通知字段:ENC,2个bit位,路由器再转发分组时,会设置这两个bit位,当TCP协议发现在某路由结点处数据流量过大时,会通过设置这两个位来告知发送方降低发送速率,这样可以在路由器过载而被迫
丢弃流量之前缓解阻塞
-总长度字段:2个字节,记录ipv4数据报的总长度,通过该字段与IHL字段,可以知道IP数据报的数据部分从哪开始,有多少字节,由于该字段为2字节,所以整个IP分组最大65535字节
尽管能够发送这么大的数据报,但是链路层的MAC帧(最大2000字节)不能携带这么多数据给IP分组,所以IP分组不可能有这么大,同时,协议已经规定死了主机接收的IPV4数据包不能大于
576字节,很多使用UDP传输数据的运用程序都限定ipv4数据报的大小为512字节以避免超过576的限制
-标识字段:2个字节,标识由主机IPV4发送的数据报,为了避免数据报分片之间相互混淆,发送主机在每次发送数据报时都会将内部的一个计数器加一,并将该计数器的值赋值到该标识字段 
该字段对于实现IPV4数据报分片十分重要
-生存期:TTL,8个bit位,用于设置一个数据报可以经过的路由器数量的上限,发送方将其初始化为某一个值,每台路由器在转发该数据报时会将该值减1,当减到0时,该数据报就会被丢弃,并使用
ICMP消息通知发送方,这个设计可以防止一个数据报由于某些原因,比如路由环路而导致该数据报永远被困在网络中出不去
-协议字段:8个bit位,该字段包含一个数字,用于表示数据报有效载荷部分的数据类型,常用的类型有:TCP:6,UDP:17,通过该字段还可以用于鉴别其封装协议是否为一种传输协议
-头部校验和:2个字节,该字段仅仅用于校验ipv4的头部,这一点很重要,这里就能看出来为什么说IP协议是一种尽力而为的不可靠的交付了,因为没有对IP数据报的数据部分进行校验,为了
确保IP数据报的有效载荷部分的正确传输,封装在IP数据报(分组)中的那些协议,ICMP,IGMP,UDP,TCP,等在自己数据报中都有做过一个涵盖头部和数据的校验和,并将结果存在头部中的某一个位置
不对IP数据报的数据区域校验有两个显而易见的理由:第一,IP数据报在网络中各个路由结点之间穿梭,TTL字段每穿梭一个路由器都会减一,校验和务必发生改变,所以,每次交付都需要校验一次首部,
但是,一个IP数据报会在网络中发生频繁的交付,若对IP数据报的数据区域也进行校验的话,就造成极大开销
第二,分层的目的就是模块化,IP数据报的数据区放的自然是那些封装在IP数据报里面的协议ICMP,IGMP,UDP,TCP等,这些协议的分组应该在自己协议实现的那个层去校验的
头部校验和使用的是一种Internet校验,它和循环冗余校验不同,它是能力不如循环冗余校验强,但是大多是Internet协议都使用该校验方法
-源IP地址:标识该IP数据报从哪台主机发出
-目标IP地址:标识该IP数据报将被发送到哪
-IP选项字段:长度可变,最多40字节,IP支持一些可供数据报选择的选项,但由于IPV4头部大小的限制以及相关的安全问题,很多选项已经不在适用或可取,选项的范围以32位为界,如果有必要,使用0来
填充不使用的字段,以满足IHL32位位宽的要求,目前,多数的标准化选项在Internet中很少或从未使用
-IP数据:长度可变,最大65515字节

**** IP转发
--IP的转发分为两种情况:发送方和接收方通过,点到点连接,以太网(局域网)连接情况下的转发;发送方和接收方通过路由器(非玩具路由器)实现转发(远程转发);
--IP数据报的来源:传输层向网络层交付的数据报;网络接口层(数据链路层经过ARP协议后)向网络层交付的数据报
Blog creation time:[2017-09-05 二 08:57]
** DONE [#D] theme:传输层										 :@Blog:@TCP:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:32]
*** 基础
--传输层完成数据在两台主机的端到端的传输

--IP地址和MAC地址唯一标识哪个地方的哪台主机,而端口号却可以标识这台主机上的哪个进程

--传输层通过识别端口号来向不同的用户运用进程递交数据

--传输层的数据报称为报文段
*** 端口
--端口与运用层的运用进程是绑定在一起的,比如80端口与HTTP进程绑定,21端口与文件传输FTP进程绑定
--端口实际上是运输层的地址,用于区分运用层的不同进程
--端口号相当于邮箱,帮助协议辨认发送和接收进程
--端口号是抽象的,不与主机上的任何物理实体相关
--传输协议TCP,UDP,SCTP使用目的端口,来帮助分离从IP层进入的数据,因为IP层是根据IPv4头部中的协议字段,将进入的IP数据报分离到特定的传输协议
--端口号在不同的传输协议之间是独立的,即TCP端口号只能被TCP使用,UDP端口号只能被UDP使用,这意味着两个不同的服务器可以使用相同的端口号和IP地址,只要他们使用不同的传输协议
--一个服务可以同时由TCP和UDP协议提供,而且这两个传输协议的端口号通常是一样的
**** 常见的端口
TCP 0= Reserved
TCP 1=TCP Port Service Multiplexer
TCP 2=Death
TCP 5=Remote Job Entry,yoyo
TCP 7=Echo
TCP 11=Skun
TCP 12=Bomber
TCP 16=Skun
TCP 17=Skun
TCP 18=消息传输协议，skun
TCP 19=Skun
TCP 20=FTP Data,Amanda
TCP 21=文件传输,Back Construction,Blade Runner,Doly Trojan,Fore,FTP trojan,Invisible FTP,Larva,WebEx,WinCrash
TCP 22=远程登录协议
TCP 23=远程登录（Telnet),Tiny Telnet Server (= TTS)
TCP 25=电子邮件(SMTP),Ajan,Antigen,Email Password Sender,Happy 99,Kuang2,ProMail trojan,Shtrilitz,Stealth,Tapiras,Terminator,WinPC,WinSpy,Haebu Coceda
TCP 27=Assasin
TCP 28=Amanda
TCP 29=MSG ICP
TCP 30=Agent 40421
TCP 31=Agent 31,Hackers Paradise,Masters Paradise,Agent 40421
TCP 37=Time,ADM worm
TCP 39=SubSARI
TCP 41=DeepThroat,Foreplay
TCP 42=Host Name Server
TCP 43=WHOIS
TCP 44=Arctic
TCP 48=DRAT
TCP 49=主机登录协议
TCP 50=DRAT
TCP 51=IMP Logical Address Maintenance,Fuck Lamers Backdoor
TCP 52=MuSka52,Skun
TCP 53=DNS,Bonk (DOS Exploit)
TCP 54=MuSka52
TCP 58=DMSetup
TCP 59=DMSetup
TCP 63=whois++
TCP 64=Communications Integrator
TCP 65=TACACS-Database Service
TCP 66=Oracle SQL*NET,AL-Bareki
TCP 67=Bootstrap Protocol Server
TCP 68=Bootstrap Protocol Client
TCP 69=TFTP,W32.Evala.Worm,BackGate Kit,Nimda,Pasana,Storm,Storm worm,Theef,Worm.Cycle.a
TCP 70=Gopher服务，ADM worm
TCP 79=用户查询（Finger),Firehotcker,ADM worm
TCP 80=超文本服务器（Http),Executor,RingZero
TCP 81=Chubo,Worm.Bbeagle.q
TCP 82=Netsky-Z
TCP 88=Kerberos krb5服务
TCP 99=Hidden Port
TCP 102=消息传输代理
TCP 108=SNA网关访问服务器
TCP 109=Pop2
TCP 110=电子邮件（Pop3),ProMail
TCP 113=Kazimas,Auther Idnet
TCP 115=简单文件传输协议
TCP 118=SQL Services,Infector 1.4.2
TCP 119=新闻组传输协议（Newsgroup(Nntp)),Happy 99
TCP 121=JammerKiller,Bo jammerkillah
TCP 123=网络时间协议(NTP),Net Controller
TCP 129=Password Generator Protocol
TCP 133=Infector 1.x
TCP 135=微软DCE RPC end-point mapper服务
TCP 137=微软Netbios Name服务（网上邻居传输文件使用）
TCP 138=微软Netbios Name服务（网上邻居传输文件使用）
TCP 139=微软Netbios Name服务（用于文件及打印机共享）
TCP 142=NetTaxi
TCP 143=Internet 邮件访问协议版本 4（IMAP4)
TCP 146=FC Infector,Infector
TCP 150=NetBIOS Session Service
TCP 156=SQL服务器
TCP 161=Snmp
TCP 162=Snmp-Trap
TCP 170=A-Trojan
TCP 177=X Display管理控制协议
TCP 179=Border网关协议（BGP)
TCP 190=网关访问控制协议（GACP)
TCP 194=Irc
TCP 197=目录定位服务（DLS)
TCP 220=Internet 邮件访问协议版本 3（IMAP3)
TCP 256=Nirvana
TCP 315=The Invasor
TCP 371=ClearCase版本管理软件
TCP 389=Lightweight Directory Access Protocol (LDAP)
TCP 396=Novell Netware over IP
TCP 420=Breach
TCP 421=TCP Wrappers
TCP 443=安全服务（HTTPS）
TCP 444=Simple Network Paging Protocol(SNPP)
TCP 445=Microsoft-DS
TCP 455=Fatal Connections
TCP 456=Hackers paradise,FuseSpark
TCP 458=苹果公司QuickTime
TCP 513=Grlogin
TCP 514=RPC Backdoor
UDP 520=Rip
TCP 531=Rasmin,Net666
TCP 544=kerberos kshell
TCP 546=DHCP Client
TCP 547=DHCP Server
TCP 548=Macintosh文件服务
TCP 555=Ini-Killer,Phase Zero,Stealth Spy
TCP 569=MSN
TCP 605=SecretService
TCP 606=Noknok8
TCP 660=DeepThroat
TCP 661=Noknok8
TCP 666=Attack FTP,Satanz Backdoor,Back Construction,Dark Connection Inside 1.2
TCP 667=Noknok7.2
TCP 668=Noknok6
TCP 669=DP trojan
TCP 692=GayOL
TCP 707=Welchia,nachi
TCP 777=AIM Spy
TCP 808=RemoteControl,WinHole
TCP 815=Everyone Darling
TCP 901=Backdoor.Devil
TCP 911=Dark Shadow
TCP 990=ssl加密
TCP 993=IMAP
TCP 999=DeepThroat
TCP 1000=Der Spaeher
TCP 1001=Silencer,WebEx,Der Spaeher
TCP 1003=BackDoor
TCP 1010=Doly
TCP 1011=Doly
TCP 1012=Doly
TCP 1015=Doly
TCP 1016=Doly
TCP 1020=Vampire
TCP 1023=Worm.Sasser.e
TCP端口（动态端口）
TCP 1024=NetSpy.698(YAI)
TCP 1025=NetSpy.698,Unused Windows Services Block
TCP 1026=Unused Windows Services Block
TCP 1027=Unused Windows Services Block
TCP 1028=Unused Windows Services Block
TCP 1029=Unused Windows Services Block
TCP 1030=Unused Windows Services Block
TCP 1033=Netspy
TCP 1035=Multidropper
TCP 1042=Bla
TCP 1045=Rasmin
TCP 1047=GateCrasher
TCP 1050=MiniCommand
TCP 1059=nimreg
TCP 1069=Backdoor.TheefServer.202
TCP 1070=Voice,Psyber Stream Server,Streaming Audio Trojan
TCP 1080=Wingate,Worm.BugBear.B,Worm.Novarg.B
TCP 1090=Xtreme,VDOLive
TCP 1092=LoveGate
TCP 1095=Rat
TCP 1097=Rat
TCP 1098=Rat
TCP 1099=Rat
TCP 1110=nfsd-keepalive
TCP 1111=Backdoor.AIMVision
TCP 1155=Network File Access
TCP 1170=Psyber Stream Server,Streaming Audio trojan,Voice
TCP 1200=NoBackO
TCP 1201=NoBackO
TCP 1207=Softwar
TCP 1212=Nirvana,Visul Killer
TCP 1234=Ultors
TCP 1243=BackDoor-G,SubSeven,SubSeven Apocalypse
TCP 1245=VooDoo Doll
TCP 1269=Mavericks Matrix
TCP 1313=Nirvana
TCP 1349=BioNet
TCP 1433=Microsoft SQL服务
TCP 1441=Remote Storm
TCP 1492=FTP99CMP(BackOriffice.FTP)
TCP 1503=NetMeeting T.120
TCP 1509=Psyber Streaming Server
TCP 1600=Shivka-Burka
TCP 1688=Key Management Service(密钥管理服务)
TCP 1703=Exloiter 1.1
TCP 1720=NetMeeting H.233 call Setup
TCP 1723=VPN 网关（PPTP）
TCP 1731=NetMeeting音频调用控制
TCP 1807=SpySender
TCP 1966=Fake FTP 2000
TCP 1976=Custom port
TCP 1981=Shockrave
TCP 1990=stun-p1 cisco STUN Priority 1 port
TCP 1990=stun-p1 cisco STUN Priority 1 port
TCP 1991=stun-p2 cisco STUN Priority 2 port
TCP 1992=stun-p3 cisco STUN Priority 3 port,ipsendmsg IPsendmsg
TCP 1993=snmp-tcp-port cisco SNMP TCP port
TCP 1994=stun-port cisco serial tunnel port
TCP 1995=perf-port cisco perf port
TCP 1996=tr-rsrb-port cisco Remote SRB port
TCP 1997=gdp-port cisco Gateway Discovery Protocol
TCP 1998=x25-svc-port cisco X.25 service (XOT)
TCP 1999=BackDoor,TransScout
TCP 2000=Der Spaeher,INsane Network
TCP 2002=W32. Beagle .AX @mm
TCP 2001=Transmisson scout
TCP 2002=Transmisson scout
TCP 2003=Transmisson scout
TCP 2004=Transmisson scout
TCP 2005=TTransmisson scout
TCP 2011=cypress
TCP 2015=raid-cs
TCP 2023=Ripper,Pass Ripper,Hack City Ripper Pro
TCP 2049=NFS
TCP 2115=Bugs
TCP 2121=Nirvana
TCP 2140=Deep Throat,The Invasor
TCP 2155=Nirvana
TCP 2208=RuX
TCP 2255=Illusion Mailer
TCP 2283=HVL Rat5
TCP 2300=PC Explorer
TCP 2311=Studio54
TCP 2556=Worm.Bbeagle.q
TCP 2565=Striker
TCP 2583=WinCrash
TCP 2600=Digital RootBeer
TCP 2716=Prayer Trojan
TCP 2745=Worm.BBeagle.k
TCP 2773=Backdoor,SubSeven
TCP 2774=SubSeven2.1&2.2
TCP 2801=Phineas Phucker
TCP 2989=Rat
TCP 3024=WinCrash trojan
TCP 3127=Worm.Novarg
TCP 3128=RingZero,Worm.Novarg.B
TCP 3129=Masters Paradise
TCP 3150=Deep Throat,The Invasor
TCP 3198=Worm.Novarg
TCP 3210=SchoolBus
TCP 3332=Worm.Cycle.a
TCP 3333=Prosiak
TCP 3389=超级终端（远程桌面）
TCP 3456=Terror
TCP 3459=Eclipse 2000
TCP 3700=Portal of Doom
TCP 3791=Eclypse
TCP 3801=Eclypse
TCP 3996=Portal of Doom,RemoteAnything
TCP 4000=腾讯QQ客户端
TCP 4060=Portal of Doom,RemoteAnything
TCP 4092=WinCrash
TCP 4242=VHM
TCP 4267=SubSeven2.1&2.2
TCP 4321=BoBo
TCP 4444=Prosiak,Swift remote
TCP 4500=W32.HLLW.Tufas
TCP 4567=File Nail
TCP 4590=ICQTrojan
TCP 4899=Remote Administrator服务器
TCP 4950=ICQTrojan
TCP 5000=WindowsXP服务器，Blazer 5,Bubbel,Back Door Setup,Sockets de Troie
TCP 5001=Back Door Setup,Sockets de Troie
TCP 5002=cd00r,Shaft
TCP 5011=One of the Last Trojans (OOTLT)
TCP 5025=WM Remote KeyLogger
TCP 5031=Firehotcker,Metropolitan,NetMetro
TCP 5032=Metropolitan
TCP 5190=ICQ Query
TCP 5321=Firehotcker
TCP 5333=Backage Trojan Box 3
TCP 5343=WCrat
TCP 5400=Blade Runner,BackConstruction1.2
TCP 5401=Blade Runner,Back Construction
TCP 5402=Blade Runner,Back Construction
TCP 5471=WinCrash
TCP 5512=Illusion Mailer
TCP 5521=Illusion Mailer
TCP 5550=Xtcp,INsane Network
TCP 5554=Worm.Sasser
TCP 5555=ServeMe
TCP 5556=BO Facil
TCP 5557=BO Facil
TCP 5569=Robo-Hack
TCP 5598=BackDoor 2.03
TCP 5631=PCAnyWhere data
TCP 5632=PCAnyWhere
TCP 5637=PC Crasher
TCP 5638=PC Crasher
TCP 5698=BackDoor
TCP 5714=Wincrash3
TCP 5741=WinCrash3
TCP 5742=WinCrash
TCP 5760=Portmap Remote Root Linux Exploit
TCP 5880=Y3K RAT
TCP 5881=Y3K RAT
TCP 5882=Y3K RAT
TCP 5888=Y3K RAT
TCP 5889=Y3K RAT
TCP 5900=WinVnc
TCP 6000=Backdoor.AB
TCP 6006=Noknok8
TCP 6129=Dameware Nt Utilities服务器
TCP 6272=SecretService
TCP 6267=广外女生
TCP 6400=Backdoor.AB,The Thing
TCP 6500=Devil 1.03
TCP 6661=Teman
TCP 6666=TCPshell.c
TCP 6667=NT Remote Control,Wise 播放器接收端口
TCP 6668=Wise Video广播端口
TCP 6669=Vampyre
TCP 6670=DeepThroat,iPhone
TCP 6671=Deep Throat 3.0
TCP 6711=SubSeven
TCP 6712=SubSeven1.x
TCP 6713=SubSeven
TCP 6723=Mstream
TCP 6767=NT Remote Control
TCP 6771=DeepThroat
TCP 6776=BackDoor-G,SubSeven,2000 Cracks
TCP 6777=Worm.BBeagle
TCP 6789=Doly Trojan
TCP 6838=Mstream
TCP 6883=DeltaSource
TCP 6912=Shit Heep
TCP 6939=Indoctrination
TCP 6969=GateCrasher,Priority,IRC 3
TCP 6970=RealAudio,GateCrasher
TCP 7000=Remote Grab,NetMonitor,SubSeven1.x
TCP 7001=Freak88
TCP 7201=NetMonitor
TCP 7215=BackDoor-G,SubSeven
TCP 7001=Freak88,Freak2k
TCP 7300=NetMonitor
TCP 7301=NetMonitor
TCP 7306=NetMonitor,NetSpy 1.0
TCP 7307=NetMonitor,ProcSpy
TCP 7308=NetMonitor,X Spy
TCP 7323=Sygate服务器端
TCP 7424=Host Control
TCP 7511=聪明基因
TCP 7597=Qaz
TCP 7609=Snid X2
TCP 7626=冰河
TCP 7777=The Thing
TCP 7789=Back Door Setup,ICQKiller
TCP 7983=Mstream
TCP 8000=腾讯OICQ服务器端，XDMA
TCP 8010=Wingate,Logfile
TCP 8011=WAY2.4
TCP 8080=WWW 代理，Ring Zero,Chubo,Worm.Novarg.B
TCP 8102=网络神偷
TCP
8181=W32.Erkez.D@mm
TCP 8520=W32.Socay.Worm
TCP 8594=I-Worm/Bozori.a
TCP 8787=BackOfrice 2000
TCP 8888=Winvnc
TCP 8897=Hack Office,Armageddon
TCP 8989=Recon
TCP 9000=Netministrator
TCP 9325=Mstream
TCP 9400=InCommand 1.0
TCP 9401=InCommand 1.0
TCP 9402=InCommand 1.0
TCP 9872=Portal of Doom
TCP 9873=Portal of Doom
TCP 9874=Portal of Doom
TCP 9875=Portal of Doom
TCP 9876=Cyber Attacker
TCP 9878=TransScout
TCP 9989=Ini-Killer
TCP 9898=Worm.Win32.Dabber.a
TCP 9999=Prayer Trojan
TCP 10067=Portal of Doom
TCP 10080=Worm.Novarg.B
TCP 10084=Syphillis
TCP 10085=Syphillis
TCP 10086=Syphillis
TCP 10101=BrainSpy
TCP 10167=Portal Of Doom
TCP 10168=Worm.Supnot.78858.c,Worm.LovGate.T
TCP 10520=Acid Shivers
TCP 10607=Coma trojan
TCP 10666=Ambush
TCP 11000=Senna Spy
TCP 11050=Host Control
TCP 11051=Host Control
TCP 11223=Progenic,Hack ’99KeyLogger
TCP 11831=TROJ_LATINUS.SVR
TCP 12076=Gjamer,MSH.104b
TCP 12223=Hack’99 KeyLogger
TCP 12345=GabanBus,NetBus 1.6/1.7,Pie Bill Gates,X-bill
TCP 12346=GabanBus,NetBus 1.6/1.7,X-bill
TCP 12349=BioNet
TCP 12361=Whack-a-mole
TCP 12362=Whack-a-mole
TCP 12363=Whack-a-mole
TCP12378=W32/Gibe@MM
TCP 12456=NetBus
TCP 12623=DUN Control
TCP 12624=Buttman
TCP 12631=WhackJob,WhackJob.NB1.7
TCP 12701=Eclipse2000
TCP 12754=Mstream
TCP 13000=Senna Spy
TCP 13010=Hacker Brazil
TCP 13013=Psychward
TCP 13223=Tribal Voice的聊天程序PowWow
TCP 13700=Kuang2 The Virus
TCP 14456=Solero
TCP 14500=PC Invader
TCP 14501=PC Invader
TCP 14502=PC Invader
TCP 14503=PC Invader
TCP 15000=NetDaemon 1.0
TCP 15092=Host Control
TCP 15104=Mstream
TCP 16484=Mosucker
TCP 16660=Stacheldraht (DDoS)
TCP 16772=ICQ Revenge
TCP 16959=Priority
TCP 16969=Priority
TCP 17027=提供广告服务的Conducent"adbot"共享软件
TCP 17166=Mosaic
TCP 17300=Kuang2 The Virus
TCP 17490=CrazyNet
TCP 17500=CrazyNet
TCP 17569=Infector 1.4.x + 1.6.x
TCP 17777=Nephron
TCP 18753=Shaft (DDoS)
TCP 19191=蓝色火焰
TCP 19864=ICQ Revenge
TCP 20000=Millennium II (GrilFriend)
TCP 20001=Millennium II (GrilFriend)
TCP 20002=AcidkoR
TCP 20034=NetBus 2 Pro
TCP 20168=Lovgate
TCP 20203=Logged,Chupacabra
TCP 20331=Bla
TCP 20432=Shaft (DDoS)
TCP 20808=Worm.LovGate.v.QQ
TCP 213 35=Tribal Flood Network,Trinoo
TCP 21544=Schwindler 1.82,GirlFriend
TCP 21554=Schwindler 1.82,GirlFriend,Exloiter 1.0.1.2
TCP 22222=Prosiak,RuXUploader2.0
TCP 22784=Backdoor.Intruzzo
TCP 23432=Asylum 0.1.3
TCP 23444=网络公牛
TCP 23456=Evil FTP,Ugly FTP,WhackJob
TCP 23476=Donald Dick
TCP 23477=Donald Dick
TCP 23777=INet Spy
TCP 26274=Delta
TCP 26681=Spy Voice
TCP 27374=Sub Seven 2.0+,Backdoor.Baste
TCP 27444=Tribal Flood Network,Trinoo
TCP 27665=Tribal Flood Network,Trinoo
TCP 29431=Hack Attack
TCP 29432=Hack Attack
TCP 29104=Host Control
TCP 29559=TROJ_LATINUS.SVR
TCP 29891=The Unexplained
TCP 30001=Terr0r32
TCP 30003=Death,Lamers Death
TCP 30029=AOL trojan
TCP 30100=NetSphere 1.27a,NetSphere 1.31
TCP 30101=NetSphere 1.31,NetSphere 1.27a
TCP 30102=NetSphere 1.27a,NetSphere 1.31
TCP 30103=NetSphere 1.31
TCP 30303=Sockets de Troie
TCP 30722=W32.Esbot.A
TCP 30947=Intruse
TCP 30999=Kuang2
TCP 31336=Bo Whack
TCP 31337=Baron Night,BO client,BO2,Bo Facil,BackFire,Back Orifice,DeepBO,Freak2k,NetSpy
TCP 31338=NetSpy,Back Orifice,DeepBO
TCP 31339=NetSpy DK
TCP 31554=Schwindler
TCP 31666=BOWhack
TCP 31778=Hack Attack
TCP 31785=Hack Attack
TCP 31787=Hack Attack
TCP 31789=Hack Attack
TCP 31791=Hack Attack
TCP 31792=Hack Attack
TCP 32100=PeanutBrittle
TCP 32418=Acid Battery
TCP 33333=Prosiak,Blakharaz 1.0
TCP 33577=Son Of Psychward
TCP 33777=Son Of Psychward
TCP 33911=Spirit 2001a
TCP 34324=BigGluck,TN,Tiny Telnet Server
TCP 34555=Trin00 (Windows) (DDoS)
TCP 35555=Trin00 (Windows) (DDoS)
TCP 36794=Worm.Bugbear-A
TCP 37651=YAT
TCP 40412=The Spy
TCP 40421=Agent 40421,Masters Paradise.96
TCP 40422=Masters Paradise
TCP 40423=Masters Paradise.97
TCP 40425=Masters Paradise
TCP 40426=Masters Paradise 3.x
TCP 41666=Remote Boot
TCP 43210=Schoolbus 1.6/2.0
TCP 44444=Delta Source
TCP 44445=Happypig
TCP 45576=未知代理
TCP 47252=Prosiak
TCP 47262=Delta
TCP 47878=BirdSpy2
TCP 49301=Online Keylogger
TCP 50505=Sockets de Troie
TCP 50766=Fore,Schwindler
TCP 51966=CafeIni
TCP 53001=Remote Windows Shutdown
TCP 53217=Acid Battery 2000
TCP 54283=Back Door-G,Sub7
TCP 54320=Back Orifice 2000,Sheep
TCP 54321=School Bus .69-1.11,Sheep,BO2K
TCP 57341=NetRaider
TCP 58008=BackDoor.Tron
TCP 58009=BackDoor.Tron
TCP 58339=ButtFunnel
TCP 59211=BackDoor.DuckToy
TCP 60000=Deep Throat
TCP 60068=Xzip 6000068
TCP 60268=DaYangou_bigppig
TCP 60411=Connection
TCP 60606=TROJ_BCKDOR.G2.A
TCP 61466=Telecommando
TCP 61603=Bunker-kill
TCP 63485=Bunker-kill
TCP 65000=Devil,DDoS
TCP 65432=Th3tr41t0r,The Traitor
TCP 65530=TROJ_WINMITE.10
TCP 65535=RC,Adore Worm/Linux
UDP端口（静态端口）
UDP 1=Sockets des Troie
UDP 9=Chargen
UDP 19=Chargen
UDP 69=Pasana
UDP 80=Penrox
UDP 371=ClearCase版本管理软件
UDP 445=公共Internet文件系统（CIFS)
UDP 500=Internet密钥交换（IP安全性 ,IKE)
UDP端口（动态端口）
UDP 1025=Maverick’s Matrix 1.2 - 2.0
UDP 1026=Remote Explorer 2000
UDP 1027=UC聊天软件，Trojan.Huigezi.e
UDP 1028=3721上网助手（用途不明，建议用户警惕！），KiLo,SubSARI
UDP 1029=SubSARI
UDP 1031=Xot
UDP 1032=Akosch4
UDP 1104=RexxRave
UDP 1111=Daodan
UDP 1116=Lurker
UDP 1122=Last 2000,Singularity
UDP 1183=Cyn,SweetHeart
UDP 1200=NoBackO
UDP 1201=NoBackO
UDP 1342=BLA trojan
UDP 1344=Ptakks
UDP 1349=BO dll
UDP 1561=MuSka52
UDP 1701=VPN网关（L2TP）
UDP 1772=NetControle
UDP 1978=Slapper
UDP 1985=Black Diver
UDP 2000=A-trojan,Fear,Force,GOTHIC Intruder,Last 2000,Real 2000
UDP 2001=Scalper
UDP 2002=Slapper
UDP 2015=raid-cs
UDP 2018=rellpack
UDP 2130=Mini BackLash
UDP 2140=Deep Throat,Foreplay,The Invasor
UDP 2222=SweetHeart,Way
UDP 2339=Voice Spy
UDP 2702=Black Diver
UDP 2989=RAT
UDP 3150=Deep Throat
UDP 3215=XHX
UDP 3333=Daodan
UDP 3801=Eclypse
UDP 3996=Remote Anything
UDP 4128=RedShad
UDP 4156=Slapper
UDP 4500=sae-urn/ (IP安全性，IKE NAT遍历）
UDP 5419=DarkSky
UDP 5503=Remote Shell Trojan
UDP 5555=Daodan
UDP 5882=Y3K RAT
UDP 5888=Y3K RAT
UDP 6112=Battle .net Game
UDP 6666=KiLo
UDP 6667=KiLo
UDP 6766=KiLo
UDP 6767=KiLo,UandMe
UDP 6838=Mstream Agent-handler
UDP 7028=未知木马
UDP 7424=Host Control
UDP 7788=Singularity
UDP 7983=MStream handler-agent
UDP 8012=Ptakks
UDP 8090=Aphex’s Remote Packet Sniffer
UDP 8127=9_119,Chonker
UDP 8488=KiLo
UDP 8489=KiLo
UDP 8787=BackOrifice 2000
UDP 8879=BackOrifice 2000
UDP 9325=MStream Agent-handler
UDP 10000=XHX
UDP 10067=Portal of Doom
UDP 10084=Syphillis
UDP 10100=Slapper
UDP 10167=Portal of Doom
UDP 10498=Mstream
UDP 10666=Ambush
UDP 11225=Cyn
UDP 12321=Protoss
UDP 12345=BlueIce 2000
UDP12378=W32/Gibe@MM
UDP 12623=ButtMan,DUN Control
UDP 15210=UDP remote shell backdoor server
UDP 15486=KiLo
UDP 16514=KiLo
UDP 16515=KiLo
UDP 18753=Shaft handler to Agent
UDP 20433=Shaft
UDP 21554=GirlFriend
UDP 22784=Backdoor.Intruzzo
UDP 23476=Donald Dick
UDP 25123=MOTD
UDP 26274=Delta Source
UDP 26374=Sub-7 2.1
UDP 26444=Trin00/TFN2K
UDP 26573=Sub-7 2.1
UDP 27184=Alvgus trojan 2000
UDP 27444=Trinoo
UDP 29589=KiLo
UDP 29891=The Unexplained
UDP 30103=NetSphere
UDP 31320=Little Witch
UDP 31335=Trin00 DoS Attack
UDP 31337=Baron Night,BO client,BO2,Bo Facil,BackFire,Back Orifice,DeepBO
UDP 31338=Back Orifice,NetSpy DK,DeepBO
UDP 31339=Little Witch
UDP 31340=Little Witch
UDP 31416=Lithium
UDP 31787=Hack aTack
UDP 31789=Hack aTack
UDP 31790=Hack aTack
UDP 31791=Hack aTack
UDP 33390=未知木马
UDP 34555=Trinoo
UDP 35555=Trinoo
UDP 43720=KiLo
UDP 44014=Iani
UDP 44767=School Bus
UDP 46666=Taskman
UDP 47262=Delta Source
UDP 47785=KiLo
UDP 49301=OnLine keyLogger
UDP 49683=Fenster
UDP 49698=KiLo
UDP 52901=Omega
UDP 54320=Back Orifice
UDP 54321=Back Orifice 2000
UDP 54341=NetRaider Trojan
UDP 61746=KiLO
UDP 61747=KiLO
UDP 61748=KiLO
UDP 65432=The Traitor
*** UDP协议
**** 基础
--UDP协议:用户数据报协议
--UDP在传输数据之前不需要先建立器连接,所以他比TCP使用更小的开销
--UDP虽然不需要建立连接,但是同样需要绑定端口建立关联
--UDP协议不提供差错纠正,队列管理,重复消除,流量控制,阻塞控制
--UDP协议提供差错检测,即有校验机制
--使用UDP的运用程序,必须自己实现数据包如何发送和处理的工作
--想要保证数据被可靠的投递或正确排序,运用程序必须自己实现这些保护功能
--UDP把运用程序传给网络层的IP数据报发送出去,但是并不保证他们能够到达目的地
--没有协议机制防止高速的UDP流量对其他网络用户的消极影响
--广播和组播操作更多的是使用像UDP这样的无连接传输
--UDP协议是保留消息边界的
--例如:有三个信息块,大小分别是1k,2k,4k,这三个信息块已经到达接收方的缓冲区,此时接收方使用UDP协议来接收这三个信息块到接收缓冲区中去,此时,无论配置
接收缓冲区多大,比如配置了8k,即便缓冲区里面的三个数据块总共只有7k,但是,UDP协议要求必须接收三次,依次将三个数据块接收到8k的接收缓冲区中去,也就是说,
UDP协议保留了消息边界
--UDP数据报大小超过MTU时,将会发生切片,数据报被分成多个IP层分组
**** UDP帧格式
--IPv4头部:占20字节,值得一提的是其中的IPv4协议字段值用17来标识UDP
--8字节的UDP头部:
-2字节的源端口号:发送方某进程A的端口,该字节可选,如果发送者不要求对方回复的话,该字段被设置为0
-2字节的目的端口号:接收方的端口
-2字节的长度字段:UDP头部和UDP数据的总长度,字段的最小值是8,即只包含UDP头部,即发送一个带0字节的UDP数据是允许的
-2字节的UDP校验和:由初始发送方计算得到,传输过程中不会被修改,由接收方校验比较
--可变长度的数据段
*** TCP协议
--TCP协议:传输控制协议
--TCP协议提供面向连接的服务
--TCP传输的信道是一个全双工的信道

--TCP协议是面向流传输的,它把数据当做一串数据流,所以TCP协议是不保留消息边界的协议,所以如果需要消息边界的话,运用程序需要自己实现发送方的消息边界
例如:有三个信息块,大小分别是1k,2k,4k,,这三个信息块已经到达接收方的缓冲区,此时接收方使用TCP协议来接收这三个信息块到接收缓冲区中去,此时,只要将
接收缓冲区设置在7k以上,比如8k,那么,三个数据块一次性就被接收完成了,也就是说TCP协议没有保留消息边界

--TCP负责发现传输中的问题,一旦发现问题就发出信号,要求重新传输,直到所有数据都安全正确的传输到目的地

Blog creation time:[2017-09-05 二 08:58]
** DONE [#D] theme:运用层										 :@Blog:@TCP:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:32]
Blog creation time:[2017-09-05 二 08:58]
** DONE [#D] theme:相关配置										 :@Blog:@TCP:
	- State "DONE"       from "TODO"       [2017-09-05 二 09:32]
*** 静态模式下配置本机IP地址,子网掩码,网关范式
--lwip_comm_default_ip_set函数专门用于在静态模式下配置ip,子网掩码,网关
--lwip_comm_default_ip_set在lwip_comm_init中调用,用户在调用lwip_comm_init之前可以将使用按键配置lwip_comm_default_ip_set函数
中提供的ip,子网掩码,网关等,在lwip_comm_init后会生效
*** 静态模式下读本机IP地址,子网掩码,网关范式
u8 buf[30];
sprintf((char*)buf,"Static IP:%d.%d.%d.%d",lwip_dev.ip[0],lwip_dev.ip[1],lwip_dev.ip[2],lwip_dev.ip[3],)

-->LCD显示:LCDShowString(30,130,210,16,16,buf);
-->USART1显示:printf("Static IP:%s",buf);
*** DHCP模式下读本机IP地址,子网掩码,网关范式
参见os_lwip_task.c中的lwip_dhcp_task函数	
Blog creation time:[2017-09-05 二 08:59]
